{"ast":null,"code":"function linearYOnX(a) {\n  a.sort(function (c, a) {\n    return parseFloat(c.x) - parseFloat(a.x);\n  });\n  var b,\n      d,\n      e,\n      f,\n      g = [],\n      h = [],\n      j = 0,\n      k = 0,\n      l = 0,\n      o = 0,\n      p = a.length,\n      i = [];\n\n  for (var _b = 0; _b < a.length; _b++) {\n    (e = +a[_b].x, f = +a[_b].y, !(isNaN(e) || isNaN(f))) && (g.push(e), h.push(f));\n  }\n\n  p = g.length;\n\n  for (var _b2 = 0; _b2 < p; _b2++) {\n    j += g[_b2], k += h[_b2];\n  }\n\n  j /= p, k /= p;\n\n  for (var _b3 = 0; _b3 < p; _b3++) {\n    l += (g[_b3] - j) * (h[_b3] - k), o += (g[_b3] - j) * (g[_b3] - j);\n  }\n\n  return 0 == o ? [[], []] : (b = l / o, d = k - b * j, i.push({\n    x: g[0],\n    y: b * g[0] + d\n  }), i.push({\n    x: g[p - 1],\n    y: b * g[p - 1] + d\n  }), [[], i]);\n}\n\nfunction linearXOnY(a) {\n  a.sort(function (c, a) {\n    return parseFloat(c.y) - parseFloat(a.y);\n  });\n  var b,\n      d,\n      e,\n      f,\n      g = [],\n      h = [],\n      j = 0,\n      k = 0,\n      l = 0,\n      o = 0,\n      p = a.length,\n      i = [];\n\n  for (var _b4 = 0; _b4 < a.length; _b4++) {\n    (e = +a[_b4].x, f = +a[_b4].y, !(isNaN(e) || isNaN(f))) && (g.push(e), h.push(f));\n  }\n\n  p = g.length;\n\n  for (var _b5 = 0; _b5 < p; _b5++) {\n    j += g[_b5], k += h[_b5];\n  }\n\n  j /= p, k /= p;\n\n  for (var _b6 = 0; _b6 < p; _b6++) {\n    l += (g[_b6] - j) * (h[_b6] - k), o += (h[_b6] - k) * (h[_b6] - k);\n  }\n\n  return 0 == o ? [[], []] : (b = l / o, d = j - b * k, i = [], i.push({\n    x: b * h[0] + d,\n    y: h[0]\n  }), i.push({\n    x: b * h[p - 1] + d,\n    y: h[p - 1]\n  }), [[], i]);\n}\n\nexport default function getLinearRegressionPoints(a, b) {\n  return +b ? linearYOnX(a) : linearXOnY(a);\n}","map":null,"metadata":{},"sourceType":"module"}