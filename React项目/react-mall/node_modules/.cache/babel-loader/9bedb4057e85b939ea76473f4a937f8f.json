{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _assertThisInitialized from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { stubFN, pluckNumber, pluck, toRaphaelColor, dehashify, hashify, isIE, convertColor, getLightColor, getValidColor } from '../../../../../../fc-core/src/lib';\nimport { ComponentInterface } from '../../../../../../fc-core/src/component-interface';\nvar UNDEF,\n    legendManager,\n    gLegendRef,\n    compositionKeys = {},\n    TRACKER_FILL = 'rgba(192,192,192,' + (isIE ? .002 : 1e-6) + ')',\n    FORMER_SLIDER_INDEX = !1,\n    LATER_SLIDER_INDEX = !0,\n    PERCENT_STR = '%',\n    COMMA_STR = ',',\n    DEF_COLOR = '#000000',\n    hasOwnProp = {}.hasOwnProperty,\n    M = 'M',\n    L = 'L';\n\nfunction merge(e, t) {\n  return function e(t, o) {\n    var n, i;\n\n    for (i in t) {\n      hasOwnProp.call(t, i) && (n = t[i], o[i] === UNDEF ? o[i] = n : 'object' == typeof n && null !== n && e(n, o[i]));\n    }\n  }(e, t), t;\n}\n\nfunction getValidHexColor(e) {\n  return getValidColor(e || DEF_COLOR) || DEF_COLOR;\n}\n\nfunction getOppositeColor(e) {\n  return getLightColor(e, 1);\n}\n\nfunction normalizeFontSizeAppend(e) {\n  var t,\n      o = e.fontSize + '';\n  return o ? (t = o.replace(/(\\d+)(px)*/, '$1px'), e.fontSize = t, e) : e;\n}\n\nfunction isInvalid(e) {\n  return !!(e === UNDEF || 'undefined' == typeof e || null === e || isNaN(e));\n}\n\ncompositionKeys.CAPTION = 'CAPTION', compositionKeys.LEGEND_BODY = 'LEGEND_BODY', compositionKeys.AXIS_LABEL = 'LEGEND_LABEL', compositionKeys.LEGEND_AXIS = 'LEGEND_AXIS', compositionKeys.RANGE = 'RANGE', compositionKeys.AXIS_VALUE = 'AXIS_VALUE', legendManager = function () {\n  function e(e) {\n    var o,\n        n,\n        i,\n        a = t.getFromEnv('number-formatter');\n\n    for (o = 0, n = e.length; o < n; o++) {\n      (i = e[o].maxvalue, !!i) && (e[o].maxvalue = a.getCleanValue(i));\n    }\n  }\n\n  var t,\n      o = {};\n  return o.legendCarpetConf = {\n    spreadFactor: .85,\n    allowDrag: !1,\n    captionAlignment: 'center',\n    padding: {\n      v: 3,\n      h: 3\n    },\n    style: {\n      fill: '#e4d9c1',\n      stroke: '#c4b89d'\n    }\n  }, o.legendCaptionConf = {\n    spreadFactor: .2,\n    padding: {\n      v: 2,\n      h: 2\n    },\n    style: {\n      fill: '#786B50',\n      fontFamily: 'sans-serif',\n      fontSize: '12px',\n      fontWeight: 'bold',\n      fontStyle: 'normal'\n    },\n    bound: {\n      style: {\n        stroke: 'none'\n      }\n    }\n  }, o.legendBodyConf = {\n    spreadFactor: .8,\n    padding: {\n      v: 2,\n      h: 2\n    },\n    bound: {\n      style: {\n        stroke: 'none'\n      }\n    }\n  }, o.legendAxisConf = {\n    legendAxisHeight: 11,\n    spreadFactor: .4,\n    padding: {\n      v: 1,\n      h: 1\n    },\n    style: {\n      stroke: 'none',\n      \"stroke-opacity\": 0,\n      \"stroke-width\": 1\n    },\n    line: {\n      grooveLength: 3,\n      offset: 8,\n      style: {\n        stroke: 'rgba(255, 255, 255, 0.65)',\n        \"stroke-width\": 1.5\n      }\n    },\n    shadow: {\n      style: {\n        stroke: 'none',\n        fill: toRaphaelColor({\n          FCcolor: {\n            alpha: '25,0,0',\n            angle: 360,\n            color: '000000,FFFFFF,FFFFFF',\n            ratio: '0,30,40'\n          }\n        })\n      }\n    },\n    bound: {\n      style: {\n        stroke: 'none'\n      }\n    }\n  }, o.sliderGroupConf = {\n    showTooltip: 1,\n    outerCircle: {\n      rFactor: 1.4,\n      style: {\n        fill: TRACKER_FILL,\n        stroke: '#757575',\n        \"stroke-width\": 3\n      }\n    },\n    innerCircle: {\n      rFactor: .65,\n      style: {\n        fill: TRACKER_FILL,\n        stroke: '#FFFFFF'\n      }\n    }\n  }, o.axisTextItemConf = {\n    spreadFactor: .3,\n    padding: {\n      v: 1,\n      h: 1\n    },\n    style: {\n      fill: '#786B50',\n      fontFamily: 'sans-serif',\n      fontSize: '12px',\n      fontWeight: 'normal',\n      fontStyle: 'normal'\n    }\n  }, {\n    init: function init(e) {\n      t = e.chart;\n    },\n    legacyDataParser: function legacyDataParser(o, n) {\n      var i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s,\n          c,\n          h,\n          p,\n          m,\n          u,\n          f = {},\n          x = t.getFromEnv('number-formatter');\n      if (!o) return !1;\n\n      for (f.mapByPercent = m = !!pluckNumber(o.mapbypercent, 0), i = o.color || [], o.minvalue === UNDEF && (o.minvalue = n.min === UNDEF ? 0 : m ? 0 : n.min), o.maxvalue === UNDEF && (o.maxvalue = n.max === UNDEF ? 100 : m ? 100 : n.max), u = !1, (d = 0, s = i.length); d < s; d++) {\n        if (i[d].maxvalue) {\n          u = !0;\n          break;\n        }\n      }\n\n      for (u || (i = []), r = o.code, c = f.colorRange = [], f.gradient = !!pluckNumber(o.gradient, 1), i.length ? r = getValidHexColor(r) : (r ? (l = getValidHexColor(r), r = getValidHexColor()) : (r = getValidHexColor(), l = getOppositeColor(r)), i.push({\n        code: l,\n        maxvalue: o.maxvalue,\n        label: UNDEF\n      })), e(i), i = i.sort(function (e, t) {\n        return e.maxvalue - t.maxvalue;\n      }), h = p = o.minvalue && x.getCleanValue(o.minvalue), p = (h !== UNDEF || null !== h) && (m ? h + PERCENT_STR : x.legendValue(h)), c.push({\n        code: dehashify(r),\n        value: h,\n        displayValue: p,\n        label: o.startlabel\n      }), (d = 0, s = i.length); d < s; d++) {\n        (a = i[d], g = getValidHexColor(a.code || a.color), h = p = a.maxvalue, !isNaN(parseInt(h, 10))) && (p = (h !== UNDEF || null !== h) && (m ? h + PERCENT_STR : x.legendValue(h)), c.push({\n          code: dehashify(g),\n          value: h,\n          displayValue: p,\n          label: a.label || a.displayvalue\n        }));\n      }\n\n      return c[c.length - 1].label = o.endlabel || a.label, f;\n    },\n    getDefaultConf: function getDefaultConf(e) {\n      return o[e];\n    }\n  };\n}();\n\nvar GLegend =\n/*#__PURE__*/\nfunction (_ComponentInterface) {\n  _inherits(GLegend, _ComponentInterface);\n\n  _createClass(GLegend, [{\n    key: \"getType\",\n    value: function getType() {\n      return 'gradientLegend';\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'gLegend';\n    }\n  }]);\n\n  function GLegend() {\n    var _this;\n\n    _classCallCheck(this, GLegend);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLegend).call(this)), gLegendRef = _assertThisInitialized(_this), _this.enabled = !1, _this.drawOptions = {}, _this.components = {};\n    return _this;\n  }\n\n  _createClass(GLegend, [{\n    key: \"setColorRange\",\n    value: function setColorRange(e) {\n      var t = this.drawOptions.colorRange = e;\n      t && t._preparationGoneWrong && (this._dontPlot = !0);\n    }\n  }, {\n    key: \"configureAttributes\",\n    value: function configureAttributes() {\n      var e,\n          t,\n          o,\n          n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s = this,\n          c = s.getFromEnv('chart'),\n          h = s.getFromEnv('dataSource').chart,\n          p = s.conf = {},\n          m = h.outcnvbasefont,\n          u = h.outcnvbasefontsize,\n          f = h.outcnvbasefontcolor,\n          x = c.config.dataLabelStyle;\n      legendManager.init({\n        chart: c\n      }), s.data = s.getFromEnv('dataSource').colorrange;\n      s._dontPlot || (s.drawOptions = {\n        smartLabel: s.getFromEnv('smartLabel'),\n        gLegend: s\n      }, s._dontPlot = !1, s._recalculateLogicalSpace = !0, p.caption = pluck(h.legendcaption), p.legendPosition = pluck(h.legendposition, 'bottom').toLowerCase(), p.showLegend = pluckNumber(h.showlegend, 1), p.interactiveLegend = pluckNumber(h.interactivelegend, 1), p.showLegendLabels = pluckNumber(h.showlegendlabels, 1), e = h.legenditemfontcolor || f, t = h.legenditemfont || m, o = h.legenditemfontsize || u, n = pluckNumber(h.legenditemfontbold, 0), i = h.legendcaptionfontcolor || f, a = h.legendcaptionfont || m, r = h.legendcaptionfontsize || u, l = pluckNumber(h.legendcaptionfontbold, 1), d = h.legendaxisbordercolor ? hashify(dehashify(h.legendaxisbordercolor)) : UNDEF, g = d ? pluckNumber(h.legendaxisborderalpha, 100) / 100 : UNDEF, p.axisTextItemConf = {\n        style: {\n          fill: e ? convertColor(pluck(e)) : x.color,\n          fontFamily: t ? pluck(t) : x.fontFamily,\n          fontSize: o ? pluckNumber(o) : x.fontSize.match(/\\d+/)[0],\n          fontWeight: n ? 'bold' : x.fontWeight\n        }\n      }, p.legendCaptionConf = {\n        style: {\n          fill: i ? convertColor(pluck(i)) : x.color,\n          fontFamily: a ? pluck(a) : x.fontFamily,\n          fontSize: r ? pluckNumber(r) : x.fontSize.match(/\\d+/)[0],\n          fontWeight: l ? 'bold' : x.fontWeight,\n          fontStyle: 'normal'\n        }\n      }, p.legendAxisConf = {\n        legendAxisHeight: 11,\n        style: {\n          stroke: d,\n          \"stroke-opacity\": g\n        },\n        line: {\n          style: {\n            stroke: convertColor(pluck(h.legendscalelinecolor, 'FFF8E9'), pluckNumber(h.legendscalelinealpha, 100)),\n            \"stroke-width\": pluckNumber(h.legendscalelinethickness)\n          }\n        }\n      }, p.sliderGroupConf = {\n        showTooltip: pluckNumber(h.showtooltip, 1),\n        outerCircle: {\n          rFactor: pluckNumber(h.sliderdiameterfactor),\n          style: {\n            stroke: convertColor(pluck(h.legendpointerbordercolor, '757575'), pluckNumber(h.legendpointerborderalpha, 100))\n          }\n        },\n        innerCircle: {\n          rFactor: pluckNumber(h.sliderholediameterfactor),\n          style: {\n            stroke: convertColor(pluck(h.legendpointercolor, 'FFFFFF'), pluckNumber(h.legendpointeralpha, 100))\n          }\n        }\n      }, p.legendCarpetConf = {\n        spreadFactor: pluckNumber(h.legendspreadfactor),\n        allowDrag: !!pluckNumber(h.legendallowdrag, 0),\n        captionAlignment: pluck(h.legendcaptionalignment, 'center'),\n        style: {\n          fill: convertColor(pluck(h.legendbgcolor, 'e4d9c1'), pluckNumber(h.legendbgalpha, 100)),\n          stroke: convertColor(pluck(h.legendbordercolor, 'c4b89d'), pluckNumber(h.legendborderalpha, 100)),\n          \"stroke-width\": pluckNumber(h.legendborderthickness, 1)\n        }\n      });\n    }\n  }, {\n    key: \"postConfigureInit\",\n    value: function postConfigureInit() {\n      var e,\n          t,\n          o,\n          n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s,\n          c,\n          h = this,\n          p = h.conf;\n      h.elem = {}, p.interactiveLegend ? (i = merge(legendManager.getDefaultConf('sliderGroupConf'), p.sliderGroupConf), this.sGroup ? (n = h.elem.sGroup = this.sGroup, n.configure(i), h.elem.sGroup.gLegend = h) : (this.sGroup = h.elem.sGroup = n = new SliderGroup(i), n.configure(i), h.elem.sGroup.gLegend = h)) : (this.sGroup && this.sGroup.dispose(), this.sGroup && delete this.sGroup), i = merge(legendManager.getDefaultConf('legendCarpetConf'), p.legendCarpetConf), i.legendPosition = p.legendPosition, c = legendManager.getDefaultConf('legendBodyConf'), 'bottom' === p.legendPosition ? (h.drawOptions.refSideKey = 'canvasWidth', h.drawOptions.refOffsetKey = 'canvasLeft', a = merge(legendManager.getDefaultConf('axisTextItemConf'), p.axisTextItemConf), c.legendPosition = 'bottom', s = merge(legendManager.getDefaultConf('legendAxisConf'), p.legendAxisConf), s.legendPosition = 'bottom', a.legendPosition = 'bottom') : (h.drawOptions.refSideKey = 'canvasHeight', h.drawOptions.refOffsetKey = 'canvasTop', a = merge(legendManager.getDefaultConf('axisTextItemConf'), p.axisTextItemConf), c.legendPosition = 'right', s = merge(legendManager.getDefaultConf('legendAxisConf'), p.legendAxisConf), s.legendPosition = 'right', a.legendPosition = 'right'), Object.keys(this.components).length || (this.components.LegendCarpet = new LegendCarpet(), this.components.LegendBody = new LegendBody(), this.components.LegendAxis = new LegendAxis(), this.components.LegendValues = new LegendValues(), p.showLegendLabels && (this.components.LegendLabels = new LegendLabels())), o = this.components.LegendAxis, d = this.components.LegendValues, t = this.components.LegendCarpet, r = this.components.LegendBody, p.showLegendLabels && (l = this.components.LegendLabels), this.components.LegendCarpet.configure(i), this.components.LegendValues.configure(a), this.components.LegendAxis.configure(s), this.components.LegendBody.configure(h.drawOptions.colorRange, c, a), p.showLegendLabels && l.configure(a), p.caption ? (g = merge(legendManager.getDefaultConf('legendCaptionConf'), p.legendCaptionConf), this.componentCaption && Object.keys(this.componentCaption).length ? this.componentCaption.configure(p.caption, g) : (e = this.componentCaption = new LegendCaption(), e.configure(p.caption, g)), t.addCompositions(this.componentCaption, compositionKeys.CAPTION)) : (t.removeCompositions(compositionKeys.CAPTION), this.componentCaption && this.componentCaption.dispose(), delete this.componentCaption), n && o.addCompositions(n, compositionKeys.RANGE), l && r.addCompositions(l, compositionKeys.AXIS_LABEL), r.addCompositions(o, compositionKeys.LEGEND_AXIS), r.addCompositions(d, compositionKeys.AXIS_VALUE), t.addCompositions(r, compositionKeys.LEGEND_BODY), h.elem.gl = new LegendBase(t);\n    }\n  }, {\n    key: \"getValueRange\",\n    value: function getValueRange() {\n      var e,\n          t,\n          o = this,\n          n = o.elem && o.elem.sGroup,\n          i = n.sliders,\n          a = n.extremes;\n      return e = i['false'].currPos, t = a[1] - a[0] + i['true'].currPos, [{\n        min: n.getValueFormPixel(e),\n        max: n.getValueFormPixel(t)\n      }];\n    }\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      var e = this;\n      e.elem && e.elem.gl && e.elem.gl.dispose(), e.elem = {}, _get(_getPrototypeOf(GLegend.prototype), \"_dispose\", this).call(this);\n    }\n  }, {\n    key: \"getCalculatedLogicalSpace\",\n    value: function getCalculatedLogicalSpace() {\n      return this._logicalArea;\n    }\n  }, {\n    key: \"setCalculatedLogicalSpace\",\n    value: function setCalculatedLogicalSpace(e) {\n      this._logicalArea = e;\n    }\n  }, {\n    key: \"getLogicalSpace\",\n    value: function getLogicalSpace(e) {\n      var t,\n          o,\n          n,\n          i = this,\n          a = i.conf,\n          r = {\n        height: 0,\n        width: 0\n      },\n          l = i.drawOptions,\n          d = i.getFromEnv('chartConfig');\n      return i._recalculateLogicalSpace ? i._dontPlot ? r : (i._recalculateLogicalSpace = !1, i.postConfigureInit(), !a.showLegend) ? r : (o = l.refSideKey, n = l.refOffsetKey, i.drawOptions.refSide = d[o], i.drawOptions.refOffset = d[n], i.drawOptions.maxOtherSide = e || i.drawOptions.maxOtherSide, i.elem.gl && (t = i.elem.gl.getLogicalSpace(i.drawOptions, !0), i.elem.gl && i.setCalculatedLogicalSpace(t)), i.getCalculatedLogicalSpace()) : (o = l.refSideKey, n = l.refOffsetKey, i.drawOptions.refSide = d[o], i.drawOptions.refOffset = d[n], i.drawOptions.maxOtherSide = e || i.drawOptions.maxOtherSide, t = i.elem.gl.getLogicalSpace(i.drawOptions, !0), i.setCalculatedLogicalSpace(t), i.getCalculatedLogicalSpace() || r);\n    }\n  }, {\n    key: \"resetLegend\",\n    value: function resetLegend() {\n      var e,\n          t = this;\n      e = t.elem && t.elem.sGroup, e && e.reset();\n    }\n  }, {\n    key: \"allocatePosition\",\n    value: function allocatePosition() {\n      var e,\n          t,\n          o,\n          n,\n          i,\n          a,\n          r = this.getFromEnv('chart'),\n          l = r.config,\n          d = this,\n          g = d.conf || {},\n          s = g.legendPosition,\n          c = l.canvasLeft,\n          h = l.canvasTop,\n          p = l.canvasWidth,\n          m = l.canvasHeight,\n          u = l.marginBottom,\n          f = l.marginRight;\n      r.config.gLegendEnabled && (e = this.getCalculatedLogicalSpace(), o = g.width = e.width, n = g.height = e.height, 'bottom' === s ? (t = p - o, i = c + (0 > t ? 0 : t / 2), a = l.height - e.height - u - (l.actionBarHeight || 0)) : (t = m - n, a = h + (0 > t ? 0 : t / 2), i = l.width - e.width - f), g.xPos = i, g.yPos = a);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var e = this.getFromEnv('chart'),\n          t = e.getFromEnv('dataSource').colorrange,\n          o = this,\n          n = o.conf || {},\n          i = e.hasGradientLegend;\n      !e.config.gLegendEnabled || t && i && o.drawLegendComponent(n.xPos, n.yPos, {\n        parentGroup: e.getContainer('parentgroup'),\n        animationManager: e.getFromEnv('animationManager')\n      });\n    }\n  }, {\n    key: \"drawLegendComponent\",\n    value: function drawLegendComponent(e, t, o) {\n      var n,\n          i,\n          a = this,\n          r = a.conf;\n      return a._dontPlot ? void 0 : r.showLegend ? void (a.drawOptions.animationManager = o.animationManager, a.drawOptions.parentGroup = o.parentGroup, a.drawOptions.x = e, a.drawOptions.y = t, a.drawOptions.maxOtherSide = a.drawOptions.maxOtherSide || o.maxOtherSide, i = a.elem.gl.draw(a.drawOptions), n = i.getBBox(), r.xPos = n.x, r.yPos = n.y, r.height = n.height, r.width = n.width, a.enabled = !0) : void (a.enabled = !1);\n    }\n  }]);\n\n  return GLegend;\n}(ComponentInterface);\n\nvar LegendBase =\n/*#__PURE__*/\nfunction () {\n  function LegendBase(e) {\n    _classCallCheck(this, LegendBase);\n\n    this.carpet = e;\n  }\n\n  _createClass(LegendBase, [{\n    key: \"draw\",\n    value: function draw(e) {\n      return this.carpet.draw(e);\n    }\n  }, {\n    key: \"getLogicalSpace\",\n    value: function getLogicalSpace(e, t) {\n      return this.carpet.getLogicalSpace(e, t);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.carpet && this.carpet.group && this.carpet.group.remove();\n    }\n  }]);\n\n  return LegendBase;\n}();\n\nvar LegendCarpet =\n/*#__PURE__*/\nfunction () {\n  function LegendCarpet(e) {\n    _classCallCheck(this, LegendCarpet);\n\n    this.conf = e, this._id = 'GL_CARPET', this.compositionsByCategory = {}, this.node = UNDEF, this.group = UNDEF, this._lSpace = UNDEF, this.autoRecalculate = !1, this.groupName = 'fc-gradient-legend', this.moveInstructions = {};\n  }\n\n  _createClass(LegendCarpet, [{\n    key: \"configure\",\n    value: function configure(e) {\n      this.conf = e;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'LegendCarpet';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'legend';\n    }\n  }, {\n    key: \"addCompositions\",\n    value: function addCompositions(e, t) {\n      this.compositionsByCategory[t] = e;\n    }\n  }, {\n    key: \"removeCompositions\",\n    value: function removeCompositions(e) {\n      delete this.compositionsByCategory[e];\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(e) {\n      var t,\n          o,\n          n = this.conf,\n          i = n.spreadFactor,\n          a = e.refSide,\n          r = e.alignment,\n          l = e.refOffset,\n          d = e.x,\n          g = e.y;\n      return 'bottom' === this.conf.legendPosition ? (t = n.width = a * i, o = e.maxOtherSide, r && (d === UNDEF || null === d) && (d = (l + a) / 2 - t / 2)) : (o = n.height = a * i, t = e.maxOtherSide, r && (g === UNDEF || null === g) && (g = (l + a) / 2 - o / 2)), {\n        width: t,\n        height: o,\n        x: d,\n        y: g\n      };\n    }\n  }, {\n    key: \"getPostCalcDecisionsH\",\n    value: function getPostCalcDecisionsH(e, t) {\n      var o,\n          n = this.conf,\n          i = n.padding,\n          a = 0;\n\n      for (o in this.moveInstructions = {}, t) {\n        a += t[o].height || 0;\n      }\n\n      e.height = a + 2 * i.v;\n    }\n  }, {\n    key: \"getLogicalSpace\",\n    value: function getLogicalSpace(e, t) {\n      var o,\n          n,\n          a,\n          r,\n          l,\n          i = this._lSpace,\n          d = ['CAPTION', 'LEGEND_BODY'],\n          g = this.conf,\n          s = g.padding,\n          c = this.compositionsByCategory,\n          h = 0,\n          p = {},\n          m = 0;\n      if (i && !t) return i.isImpure = !0, i;\n      i = this._lSpace = n = this.getBoundingBox(e), (isInvalid(i.x) || isInvalid(i.y) || isInvalid(i.height) || isInvalid(i.width)) && (this.autoRecalculate = !0), a = merge(n, {}), a.height -= 2 * s.v, a.width -= 2 * s.h, a.x += s.h, a.y += s.v;\n\n      for (var _n = 0; _n < d.length; _n++) {\n        o = c[d[_n]], o && (l = merge(a, {}), l.y += h, h = a.height * o.conf.spreadFactor, l.height = h + m, r = o.getLogicalSpace(merge(l, {}), e, t), m = l.height - r.height, p[d[_n]] = r, h = r.height);\n      }\n\n      return this.getPostCalcDecisions(n, p), this._lSpace = n, n;\n    }\n  }, {\n    key: \"setupDragging\",\n    value: function setupDragging() {\n      var e = this.group,\n          t = 0,\n          o = 0,\n          n = 0,\n          i = 0;\n      e.css({\n        cursor: 'move'\n      }), e.drag(function (a, r) {\n        t = a, o = r, e.attr({\n          transform: 't' + (n + t) + ',' + (i + o)\n        });\n      }, function () {\n        n += t, i += o;\n      }, stubFN);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(e) {\n      var t,\n          o,\n          n,\n          a,\n          r = this.conf,\n          i = this,\n          l = ['CAPTION', 'LEGEND_BODY'],\n          d = this.compositionsByCategory,\n          g = e.animationManager,\n          s = e.parentGroup;\n      this.getLogicalSpace(e, this.autoRecalculate), a = this._lSpace, this.group = t = g.setAnimation({\n        el: this.group || 'group',\n        attr: {\n          name: i.groupName\n        },\n        component: gLegendRef,\n        container: s,\n        label: 'carpetGroup'\n      }), this.node = g.setAnimation({\n        el: this.node || 'rect',\n        attr: a,\n        css: r.style,\n        component: gLegendRef,\n        container: t,\n        label: 'rect'\n      });\n\n      for (var _s = 0; _s < l.length; _s++) {\n        n = d[l[_s]], n && n.draw(r.captionAlignment, a, {\n          animationManager: g,\n          colorRange: e.colorRange,\n          numberFormatter: e.numberFormatter,\n          parentLayer: t,\n          smartLabel: e.smartLabel,\n          moveInstructions: this.moveInstructions[o],\n          gLegend: e.gLegend\n        });\n      }\n\n      return r.allowDrag && this.setupDragging(), this.node;\n    }\n  }, {\n    key: \"getPostCalcDecisions\",\n    value: function getPostCalcDecisions(e, t) {\n      return 'bottom' === this.conf.legendPosition ? this.getPostCalcDecisionsH(e, t) : this.getPostCalcDecisionsV(e, t);\n    }\n  }, {\n    key: \"getPostCalcDecisionsV\",\n    value: function getPostCalcDecisionsV(e, t) {\n      var o,\n          n,\n          i,\n          a = this.conf,\n          r = a.padding,\n          l = Number.NEGATIVE_INFINITY,\n          d = this.moveInstructions;\n\n      for (n in this.getPostCalcDecisionsH(e, t), t) {\n        o = t[n].width, l = l < o ? o : l;\n      }\n\n      for (n in e.width = l + 2 * r.h, t) {\n        o = t[n].width, i = l - o, i && (d[n] = 't' + i / 2 + ',0');\n      }\n    }\n  }]);\n\n  return LegendCarpet;\n}();\n\nvar LegendCaption =\n/*#__PURE__*/\nfunction () {\n  function LegendCaption(e, t) {\n    _classCallCheck(this, LegendCaption);\n\n    this.rawText = e, this.conf = t, this._id = 'GL_CAPTION', this.node = UNDEF, this.bound = UNDEF, this._lSpace = UNDEF, this.LegendCaption = {}, this.LegendCaption.LEFT = {\n      x: function x(e, t) {\n        return t.x + e.width / 2 + 2;\n      }\n    }, this.LegendCaption.RIGHT = {\n      x: function x(e, t) {\n        return t.x + t.width - e.width / 2 - 2;\n      }\n    }, this.LegendCaption.CENTER = {\n      x: function x() {\n        var e = arguments[1];\n        return e.x + e.width / 2;\n      }\n    };\n  }\n\n  _createClass(LegendCaption, [{\n    key: \"configure\",\n    value: function configure(e, t) {\n      this.rawText = e, this.conf = t;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'LegendCaption';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'caption';\n    }\n  }, {\n    key: \"getLogicalSpace\",\n    value: function getLogicalSpace(e, t, o) {\n      var n,\n          i,\n          a,\n          r,\n          l = this.conf,\n          d = l.padding,\n          g = this._lSpace,\n          s = this.rawText,\n          c = t.gLegend.getFromEnv('chartConfig');\n      return g && !o ? (g.isImpure = !0, g) : (g = this._lSpace = {\n        bound: {\n          height: 0,\n          width: 0\n        },\n        node: {\n          logicArea: UNDEF,\n          smartText: UNDEF\n        }\n      }, n = t.smartLabel, !s) ? g.bound : (i = merge(e, {}), i.height -= 2 * d.v, i.width -= 2 * d.h, i.x += d.h, i.y += d.v, n.useEllipsesOnOverflow(c.useEllipsesWhenOverflow), r = merge(this.conf.style, {}), normalizeFontSizeAppend(r), n.setStyle(this._metaStyle = r), a = n.getSmartText(s, i.width, i.height), i.height = a.height, i.width = a.width, e.height = a.height + 2 * d.v, e.width = a.width + 2 * d.h, g.node.smartText = a, g.node.logicArea = i, g.bound = e, e);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var e,\n          t,\n          o,\n          n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s,\n          c = this.conf,\n          h = c.bound || {};\n      return 3 <= arguments.length ? (r = arguments[0], l = arguments[1], d = arguments[2]) : 2 <= arguments.length && (r = arguments[0], d = arguments[1]), e = d.parentLayer, s = d.animationManager, this.group = t = s.setAnimation({\n        el: this.group || 'group',\n        attr: {\n          name: 'legend-caption'\n        },\n        css: c.style,\n        component: gLegendRef,\n        container: e\n      }), this.getLogicalSpace(l, d), i = this._lSpace, g = i.node, n = i.bound, this.bound = o = s.setAnimation({\n        el: this.bound || 'rect',\n        attr: n,\n        css: h.style,\n        container: t,\n        component: gLegendRef\n      }), a = 'string' == typeof r ? this.LegendCaption[r.toUpperCase()].x(g.smartText, l || g.logicArea) : r, this.node = s.setAnimation({\n        el: this.node || 'text',\n        attr: {\n          text: g.smartText.text,\n          x: a,\n          y: g.logicArea.y + g.smartText.height / 2,\n          lineHeight: this._metaStyle.lineHeight,\n          fill: c.style.fill\n        },\n        container: t,\n        component: gLegendRef\n      }), {\n        group: t,\n        bound: o,\n        node: this.node\n      };\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.group.remove(), this.bound.remove(), this.node.remove();\n    }\n  }]);\n\n  return LegendCaption;\n}();\n\nvar LegendBody =\n/*#__PURE__*/\nfunction () {\n  function LegendBody(e, t, o) {\n    _classCallCheck(this, LegendBody);\n\n    this.colorRange = e, this.conf = t, this.childTextConf = o, this._id = 'GL_BODY', this.bound = UNDEF, this.group = UNDEF, this.compositionsByCategory = {}, this._lSpace = UNDEF, this.SC_STACK = [compositionKeys.AXIS_LABEL, compositionKeys.LEGEND_AXIS, compositionKeys.AXIS_VALUE], this.DARW_STACK = [compositionKeys.AXIS_VALUE, compositionKeys.LEGEND_AXIS, compositionKeys.AXIS_LABEL];\n  }\n\n  _createClass(LegendBody, [{\n    key: \"configure\",\n    value: function configure(e, t, o) {\n      this.colorRange = e, this.conf = t, this.childTextConf = o, this.compositionsByCategory = {};\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'LegendBody';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'legend';\n    }\n  }, {\n    key: \"addCompositions\",\n    value: function addCompositions(e, t) {\n      this.compositionsByCategory[t] = e;\n    }\n  }, {\n    key: \"getSpaceTaken\",\n    value: function getSpaceTaken(e) {\n      return 'bottom' === this.conf.legendPosition ? e.height : e.width;\n    }\n  }, {\n    key: \"getLogicalSpace\",\n    value: function getLogicalSpace(e, t, o) {\n      var n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s = this._lSpace,\n          c = this.conf,\n          h = c.padding,\n          p = this.compositionsByCategory,\n          m = 0;\n      if (s && !o) return s.isImpure = !0, s;\n\n      for (s = this._lSpace = {\n        bound: {\n          height: 0,\n          width: 0\n        },\n        node: {\n          logicArea: UNDEF\n        }\n      }, r = merge(e, {}), r.height -= 2 * h.v, r.width -= 2 * h.h, r.x += h.h, r.y += h.v, l = this.getCompositionPlotAreaFor(r), t.colorRange = this.colorRange, (d = 0, g = this.SC_STACK.length); d < g; d++) {\n        (n = p[this.SC_STACK[d]]) && (i = l(a, n.conf.spreadFactor), a = n.getLogicalSpace(merge(i, {}), t, o), m += this.getSpaceTaken(a));\n      }\n\n      return this.updateEffectivePlotArea(e, r, m), s.node.logicArea = r, s.bound = e, e;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var e,\n          t,\n          o,\n          n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s = this.childTextConf,\n          c = this.conf,\n          h = c.bound.style || {},\n          p = this.compositionsByCategory;\n\n      for (3 <= arguments.length ? (a = arguments[1], l = arguments[2]) : 2 <= arguments.length && (l = arguments[1]), t = l.parentLayer, e = l.animationManager, this.getLogicalSpace(a, l), r = this._lSpace, this.group = i = e.setAnimation({\n        el: this.group || 'group',\n        attr: {\n          name: 'legend-body',\n          transform: 't0,0'\n        },\n        css: s.style,\n        container: t,\n        component: gLegendRef\n      }), this.bound = o = e.setAnimation({\n        el: this.bound || 'rect',\n        attr: r.bound,\n        css: h,\n        container: i,\n        component: gLegendRef\n      }), l.colorRange = this.colorRange, l.parentLayer = i, (d = 0, g = this.DARW_STACK.length); d < g; d++) {\n        (n = p[this.DARW_STACK[d]]) && n.draw(l);\n      }\n\n      return l.moveInstructions && i.attr({\n        transform: l.moveInstructions\n      }), {\n        bound: o,\n        group: i\n      };\n    }\n  }, {\n    key: \"getCompositionPlotAreaFor\",\n    value: function getCompositionPlotAreaFor(e) {\n      var t,\n          o = 'bottom' === this.conf.legendPosition;\n      return t = merge(e, {}), function (n, i) {\n        return n = n || {}, o ? (t.y += n.height || 0, t.height = e.height * i) : (t.x += n.width || 0, t.width = e.width * i), t;\n      };\n    }\n  }, {\n    key: \"updateEffectivePlotArea\",\n    value: function updateEffectivePlotArea(e, t, o) {\n      var n = this.conf,\n          i = n.padding;\n      'bottom' === this.conf.legendPosition ? (t.height = o, e.height = o + 2 * i.v) : (t.width = o, e.width = o + 2 * i.h);\n    }\n  }]);\n\n  return LegendBody;\n}();\n\nvar LegendLabels =\n/*#__PURE__*/\nfunction () {\n  function LegendLabels(e) {\n    _classCallCheck(this, LegendLabels);\n\n    this.conf = e, this.node = [], this._id = 'GL_LABELS';\n  }\n\n  _createClass(LegendLabels, [{\n    key: \"configure\",\n    value: function configure(e) {\n      this.conf = e;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'label';\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'LegendLabel';\n    }\n  }, {\n    key: \"getEffectivePlotArea\",\n    value: function getEffectivePlotArea(e) {\n      var t = this.conf,\n          o = t.padding;\n      return e.height -= 2 * o.v, e.width -= 2 * o.h, e.x += o.h, e.y += o.v, e;\n    }\n  }, {\n    key: \"getLogicalSpace\",\n    value: function getLogicalSpace(e, t, o) {\n      var n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s,\n          c,\n          h,\n          p,\n          m,\n          u,\n          f,\n          x,\n          y,\n          w,\n          C,\n          L,\n          S,\n          b,\n          v,\n          F,\n          _ = Math.max,\n          A = 'bottom' === this.conf.legendPosition,\n          E = this._lSpace,\n          P = this.conf,\n          I = P.padding,\n          R = [],\n          T = t.gLegend.getFromEnv('chartConfig'),\n          O = [];\n      if (E && !o) return E.isImpure = !0, E;\n\n      for (n = t.colorRange, i = t.smartLabel, h = n.getCumulativeValueRatio(), a = n.colorRange, E = this._lSpace = {\n        bound: {\n          height: 0,\n          width: 0\n        },\n        node: {\n          logicArea: UNDEF,\n          smartTexts: []\n        }\n      }, u = E.node.smartTexts, s = merge(e, {}), x = this.getEffectivePlotArea(s), F = A ? x.width : x.height, i.useEllipsesOnOverflow(T.useEllipsesWhenOverflow), v = merge(P.style, {}), normalizeFontSizeAppend(this._metaStyle = v), i.setStyle(v), y = i.getSmartText('W'), (r = 0, l = a.length); r < l; r++) {\n        if (c = a[r].label, !c) {\n          u[r] = UNDEF;\n          continue;\n        }\n\n        O.push({\n          oriIndex: r,\n          label: c\n        });\n      }\n\n      if (l = O.length, 0 === l) return {\n        height: 0,\n        width: 0\n      };\n\n      for (p = 1 < l ? (h[O[l - 1].oriIndex] - h[O[0].oriIndex]) / 2 * F / 100 : _(h[O[0].oriIndex], 100 - h[O[0].oriIndex]) / 2 * F / 100, m = p, A ? (S = i.getSmartText(O[0].label, m, x.height), S.x = h[O[0].oriIndex] * x.width / 100, d = S.x + S.width) : (S = i.getSmartText(O[0].label, m, x.width), S.y = h[O[0].oriIndex] * x.height / 100, d = S.y + S.width), R.push(S.height), u[O[0].oriIndex] = S, A ? (S = i.getSmartText(O[l - 1].label, m, x.height), S.x = h[O[l - 1].oriIndex] * x.width / 100, g = S.x - S.width) : (S = i.getSmartText(O[l - 1].label, m, x.width), S.y = h[O[l - 1].oriIndex] * x.height / 100, g = S.y - S.width), R.push(S.height), u[O[l - 1].oriIndex] = S, L = d, r = 1; r < l - 1; r++) {\n        c = O[r].label, b = O[r].oriIndex, S = UNDEF, w = r + 1 === l - 1 ? g : h[O[r + 1].oriIndex] * F / 100, C = h[O[r].oriIndex] * F / 100, p = Math.min(C - L, w - C), p > 2 * y.width && (A ? (S = i.getSmartText(c, p, x.height), S.x = h[b] * x.width / 100) : (S = i.getSmartText(c, p, x.width), S.y = h[b] * x.height / 100), L = p, R.push(S.height)), u[O[r].oriIndex] = S;\n      }\n\n      return f = _.apply(Math, R), A ? (x.height = f, e.height = f + 2 * I.v) : (x.width = f, e.width = f + 2 * I.v), E.node.logicArea = x, E.bound = e, e;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var e,\n          t,\n          o,\n          n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s,\n          c,\n          h = 'bottom' === this.conf.legendPosition,\n          p = this.conf,\n          m = p.bound && p.bound.style || {\n        stroke: 'none'\n      },\n          u = {};\n      2 <= arguments.length && arguments[1] ? (n = arguments[0], r = arguments[1]) : 1 <= arguments.length && (r = arguments[0]), c = r.animationManager, e = r.parentLayer, this.getLogicalSpace(n, r), a = this._lSpace, d = a.node.logicArea, g = a.node.smartTexts, this.group = o = c.setAnimation({\n        el: this.group || 'group',\n        attr: {\n          name: 'legend-labels'\n        },\n        container: e,\n        component: gLegendRef\n      }), this.bound = t = c.setAnimation({\n        el: this.bound || 'rect',\n        attr: a.bound,\n        css: m,\n        container: o,\n        component: gLegendRef\n      });\n\n      for (var _e = 0; _e < this.node.length; _e++) {\n        this.node[_e].remove();\n      }\n\n      for (this.node = [], l = 0, s = g.length; l < s; l++) {\n        (i = g[l], !!i) && (h ? (u.y = d.y + i.height / 2, u.x = l === s - 1 ? d.x + i.x - i.width / 2 : l ? d.x + i.x : d.x + i.x + i.width / 2) : (u.x = d.x + i.height / 2, u.y = l === s - 1 ? d.y + i.y - i.width / 2 : l ? d.y + i.y : d.y + i.y + i.width / 2), this.node.push(c.setAnimation({\n          el: 'text',\n          attr: {\n            text: i.text,\n            x: u.x,\n            y: u.y,\n            lineHeight: this._metaStyle.lineHeight,\n            fill: p.style.fill,\n            transform: h ? 'R0' : 'R270,' + u.x + ',' + u.y\n          },\n          container: o,\n          component: gLegendRef\n        })));\n      }\n\n      return {\n        group: o,\n        bound: t,\n        node: this.node\n      };\n    }\n  }]);\n\n  return LegendLabels;\n}();\n\nvar LegendAxis =\n/*#__PURE__*/\nfunction () {\n  function LegendAxis(e) {\n    _classCallCheck(this, LegendAxis);\n\n    this.conf = e, this._id = 'FL_AXIS', this.node = UNDEF, this.group = UNDEF, this.shadow = UNDEF, this.markerLine = UNDEF, this.compositionsByCategory = {};\n  }\n\n  _createClass(LegendAxis, [{\n    key: \"configure\",\n    value: function configure(e) {\n      this.conf = e;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'LegendAxis';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'axis';\n    }\n  }, {\n    key: \"addCompositions\",\n    value: function addCompositions(e, t) {\n      this.compositionsByCategory[t] = e;\n    }\n  }, {\n    key: \"getLogicalSpace\",\n    value: function getLogicalSpace() {\n      var e,\n          t,\n          o,\n          n,\n          i,\n          a,\n          r,\n          l = 'bottom' === this.conf.legendPosition,\n          d = arguments[0],\n          g = arguments[2],\n          s = this._lSpace,\n          c = this.conf,\n          h = c.padding,\n          p = c.legendAxisHeight,\n          m = this.compositionsByCategory,\n          u = 0;\n      return s && !g ? (s.isImpure = !0, s) : (s = this._lSpace = {\n        bound: {\n          height: 0,\n          width: 0\n        },\n        node: {\n          logicArea: UNDEF\n        }\n      }, i = merge(d, {}), i.height -= 2 * h.v, i.width -= 2 * h.h, i.x += h.h, i.y += h.v, e = p / 2 + c.line.offset, t = p / 2, n = m[compositionKeys.RANGE], n && (a = n.sliders['false'], r = a.conf.outerCircle.rFactor * p, t += u = Math.max(r / 2 - p / 2, 0)), l ? (i.y += u, i.height = o = t + e + u, d.height = o + 2 * h.v) : (i.x += u, i.width = o = t + e + u, d.width = o + 2 * h.v), s.node.logicArea = i, s.bound = d, d);\n    }\n  }, {\n    key: \"getDrawableAxisArea\",\n    value: function getDrawableAxisArea(e) {\n      var t = this.conf,\n          o = 'bottom' === this.conf.legendPosition,\n          n = e.x,\n          i = e.y,\n          a = o ? e.width : t.legendAxisHeight,\n          l = o ? t.legendAxisHeight : e.height,\n          d = t.legendAxisHeight / 2;\n      return {\n        x: n,\n        y: i,\n        width: a,\n        height: l,\n        r: d\n      };\n    }\n  }, {\n    key: \"preDrawingRangeParamV\",\n    value: function preDrawingRangeParamV(e) {\n      var t = e.x + e.width / 2,\n          o = e.width;\n      return {\n        x: t,\n        calculationBase: o,\n        rangeStart: e.y,\n        rangeEnd: e.y + e.height,\n        prop: 'x'\n      };\n    }\n  }, {\n    key: \"preDrawingRangeParamH\",\n    value: function preDrawingRangeParamH(e) {\n      var t = e.y + e.height / 2,\n          o = e.height;\n      return {\n        y: t,\n        calculationBase: o,\n        rangeStart: e.x,\n        rangeEnd: e.x + e.width,\n        prop: 'y'\n      };\n    }\n  }, {\n    key: \"preDrawingRangeParam\",\n    value: function preDrawingRangeParam(e) {\n      return 'bottom' === this.conf.legendPosition ? this.preDrawingRangeParamH(e) : this.preDrawingRangeParamV(e);\n    }\n  }, {\n    key: \"getScaleMarkerPathStrH\",\n    value: function getScaleMarkerPathStrH(e, t) {\n      var o,\n          n,\n          i,\n          a,\n          r,\n          l = merge(e, {}),\n          d = this.conf,\n          g = d.line,\n          s = '',\n          c = '';\n\n      for (l.x += l.r, l.width -= 2 * l.r, r = l.y + l.height, (o = 0, n = t.length); o < n; o++) {\n        i = t[o], a = l.x + i * l.width / 100, s += M + a + COMMA_STR + (r - g.grooveLength) + L + a + COMMA_STR + (r + g.offset);\n      }\n\n      return c += M + l.x + COMMA_STR + (r + g.offset) + L + (l.x + l.width) + COMMA_STR + (r + g.offset), s + c;\n    }\n  }, {\n    key: \"getColorGradientH\",\n    value: function getColorGradientH(e) {\n      return {\n        axis: e.getBoxFill(),\n        shadow: toRaphaelColor({\n          FCcolor: {\n            alpha: '25,0,0',\n            angle: 90,\n            color: '000000,FFFFFF,FFFFFF',\n            ratio: '0,30,40'\n          }\n        })\n      };\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var e,\n          t,\n          o,\n          n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s,\n          c,\n          h,\n          p,\n          m = this.conf,\n          u = m.bound || {},\n          f = m.line,\n          x = u.style || {},\n          y = this.compositionsByCategory;\n\n      for (o in 2 <= arguments.length ? (t = arguments[0], c = arguments[1]) : 1 <= arguments.length && (c = arguments[0]), h = c.animationManager, e = c.parentLayer, n = c.colorRange, i = n.getCumulativeValueRatio(), this.getLogicalSpace(t, c), s = this._lSpace, this.group = r = h.setAnimation({\n        el: this.group || 'group',\n        attr: {\n          name: 'legend-axis'\n        },\n        container: e,\n        component: gLegendRef\n      }), this.bound = h.setAnimation({\n        el: this.bound || 'rect',\n        attr: s.bound,\n        css: x,\n        component: gLegendRef,\n        container: r\n      }), g = this.getDrawableAxisArea(s.node.logicArea), d = this.getColorGradient(n), m.style.fill = d.axis, m.shadow.style.fill = d.shadow, this.node = h.setAnimation({\n        el: this.node || 'rect',\n        attr: g,\n        css: m.style,\n        container: r,\n        component: gLegendRef\n      }), this.shadow = h.setAnimation({\n        el: this.shadow || 'rect',\n        attr: g,\n        css: m.shadow.style,\n        container: r,\n        component: gLegendRef\n      }), p = this.getScaleMarkerPathStr(g, i), this.path = h.setAnimation({\n        el: this.path || 'path',\n        attr: {\n          path: p\n        },\n        css: f.style,\n        container: r,\n        component: gLegendRef\n      }), y) {\n        a = y[o], o === compositionKeys.RANGE ? (l = this.preDrawingRangeParam(g), c[l.prop] = l[l.prop], c.key = l.prop, c.rCalcBase = l.calculationBase, c.parentLayer = r, a.draw(l.rangeStart, l.rangeEnd, c)) : void 0;\n      }\n    }\n  }, {\n    key: \"getScaleMarkerPathStr\",\n    value: function getScaleMarkerPathStr(e, t) {\n      return 'bottom' === this.conf.legendPosition ? this.getScaleMarkerPathStrH(e, t) : this.getScaleMarkerPathStrV(e, t);\n    }\n  }, {\n    key: \"getColorGradient\",\n    value: function getColorGradient(e) {\n      return 'bottom' === this.conf.legendPosition ? this.getColorGradientH(e) : this.getColorGradientV(e);\n    }\n  }, {\n    key: \"getScaleMarkerPathStrV\",\n    value: function getScaleMarkerPathStrV(e, t) {\n      var o,\n          n,\n          i,\n          a,\n          r,\n          l = merge(e, {}),\n          d = this.conf,\n          g = d.line,\n          s = '',\n          c = '';\n\n      for (l.y += l.r, l.height -= 2 * l.r, a = l.x + l.width, (o = 0, i = t.length); o < i; o++) {\n        n = t[o], r = l.y + n * l.height / 100, s += M + (a - g.grooveLength) + COMMA_STR + r + L + (a + g.offset) + COMMA_STR + r;\n      }\n\n      return c += M + (a + g.offset) + COMMA_STR + l.y + L + (a + g.offset) + COMMA_STR + (l.y + l.height), s + c;\n    }\n  }, {\n    key: \"getColorGradientV\",\n    value: function getColorGradientV(e) {\n      return {\n        axis: e.getBoxFill(!0),\n        shadow: toRaphaelColor({\n          FCcolor: {\n            alpha: '25,0,0',\n            angle: 360,\n            color: '000000,FFFFFF,FFFFFF',\n            ratio: '0,30,40'\n          }\n        })\n      };\n    }\n  }]);\n\n  return LegendAxis;\n}();\n\nvar Slider =\n/*#__PURE__*/\nfunction () {\n  function Slider(e, t, o) {\n    _classCallCheck(this, Slider);\n\n    this.conf = t.conf, this.sliderIndex = e, this.rangeGroup = t.sliderGroup, this._id = o, this.node = UNDEF, this.tracker = UNDEF, this.currPos = 0, this.swing = [];\n  }\n\n  _createClass(Slider, [{\n    key: \"configure\",\n    value: function configure(e, t, o) {\n      this.conf = t.conf, this.sliderIndex = e, this.rangeGroup = t.sliderGroup, this._id = o, this.currPos = 0, this.swing = [];\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'slider';\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'Slider';\n    }\n  }, {\n    key: \"updateSwingRange\",\n    value: function updateSwingRange(e, t) {\n      this.swing[+e] = t;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(e, t, o, n) {\n      var i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s,\n          c = Math.ceil,\n          h = n.parentLayer,\n          p = this,\n          m = n.animationManager,\n          u = this.conf,\n          f = u.outerCircle,\n          w = u.innerCircle,\n          C = m.getFromEnv('chart').config,\n          L = c(f.rFactor * n.rCalcBase / 2),\n          S = c(w.rFactor * n.rCalcBase / 2),\n          b = 'L' - S,\n          v = n.gLegend.getFromEnv('toolTipController'),\n          F = this.sliderIndex;\n      return u.outerRadius = L, u.innerRadius = S, this._scaleVal = t, w.style['stroke-width'] = b, l = c(f.style['stroke-width'] / 2), S += l, a = this.node = m.setAnimation({\n        el: this.node || 'group',\n        attr: {\n          name: 'fc-gl-slider',\n          cursor: 'pointer',\n          transform: 't0,0'\n        },\n        container: h,\n        component: gLegendRef\n      }), 'x' === n.key ? (d = o, g = e, g += F ? -S : +S) : (d = e, g = o, d += F ? -S : +S), this.oCircle = m.setAnimation({\n        el: this.oCircle || 'circle',\n        attr: {\n          cx: d,\n          cy: g,\n          r: L\n        },\n        css: f.style,\n        container: a,\n        component: gLegendRef\n      }), this.iCircle = m.setAnimation({\n        el: this.iCircle || 'circle',\n        attr: {\n          cx: d,\n          cy: g,\n          r: S\n        },\n        css: w.style,\n        container: a,\n        component: gLegendRef\n      }), s = this.tracker = m.setAnimation({\n        el: this.tracker || 'circle',\n        attr: {\n          cx: d,\n          cy: g,\n          r: L + 5,\n          fill: TRACKER_FILL,\n          stroke: TRACKER_FILL,\n          cursor: 'pointer'\n        },\n        container: a,\n        component: gLegendRef\n      }), a.attr({\n        transform: 'x' === n.key ? 't0,' + p.currPos : 't' + p.currPos + ',' + 0\n      }), i = C.showToolTip ? t : '', v.enableToolTip(s, i), this._dragAPI = r = this.getDragAPI('x' === n.key), s.undrag(), s.drag(r.dragging, r.dragStart, r.dragEnd), {\n        translateAscending: L + l\n      };\n    }\n  }, {\n    key: \"getDragAPI\",\n    value: function getDragAPI(e) {\n      var t,\n          o,\n          n,\n          i,\n          a = this,\n          r = a.node,\n          l = a.sliderIndex,\n          g = a.rangeGroup,\n          d = a.conf.innerRadius,\n          s = d;\n      return {\n        dragging: function dragging(c) {\n          var h, p, m, u, f;\n          return c.stopPropagation(), m = e ? c.data[1] : c.data[0], l ? (h = t[0] - t[1] + s, p = 0) : (h = 0, p = t[1] - t[0] - s), f = a.currPos + m, f < h ? m += h - f : f > p && (m -= f - p), r.attr({\n            transform: e ? 't0,' + (a.currPos + m) : 't' + (a.currPos + m) + ',' + 0\n          }), o = m, n && clearTimeout(n), n = setTimeout(function () {\n            g.updateWhenInRest(a, a.currPos + m);\n          }, 100), u = g.updateWhenInMove(a, a.currPos + m), a.conf.showTooltip && a.tracker.data('__FC_tooltipText', u), i = !0, !0;\n        },\n        dragStart: function dragStart(e) {\n          e.stopPropagation(), t = a.swing, i = !1, g.dragStarted(a);\n        },\n        dragEnd: function dragEnd() {\n          var e;\n          g.dragCompleted(a, i, a.currPos + o);\n          i && (n && clearTimeout(n), n = setTimeout(function () {\n            g.updateWhenInRest(a, a.currPos);\n          }, 100), a.currPos += o, e = t[+l] + a.currPos, g.updateRange(a, e));\n        }\n      };\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.node.remove(), this.oCircle.remove(), this.iCircle.remove(), this.tracker.remove(), delete this;\n    }\n  }]);\n\n  return Slider;\n}();\n\nvar SliderGroup =\n/*#__PURE__*/\nfunction () {\n  function SliderGroup(e) {\n    _classCallCheck(this, SliderGroup);\n\n    var t = {};\n    this._id = 'GL_SG1', this.conf = e, t.conf = e, this.extremes = [], this.sliders = {}, this.min = void 0, this.max = void 0, t.sliderGroup = this, this.valueRange = [], this.callbacks = [], this.sliders[FORMER_SLIDER_INDEX] = new Slider(FORMER_SLIDER_INDEX, t, this._id + '_' + 0), this.sliders[LATER_SLIDER_INDEX] = new Slider(LATER_SLIDER_INDEX, t, this._id + '_' + 1);\n  }\n\n  _createClass(SliderGroup, [{\n    key: \"configure\",\n    value: function configure(e) {\n      var t = {};\n      this.min = void 0, this.max = void 0, this.conf = e, t.conf = e, t.sliderGroup = this, this.sliders[FORMER_SLIDER_INDEX].configure(FORMER_SLIDER_INDEX, t, this._id + '_' + 0), this.sliders[LATER_SLIDER_INDEX].configure(LATER_SLIDER_INDEX, t, this._id + '_' + 1);\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'slider';\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'SliderGroup';\n    }\n  }, {\n    key: \"initRange\",\n    value: function initRange(e, t) {\n      var o = e.sliderIndex;\n      this.extremes[+o] = t;\n    }\n  }, {\n    key: \"updateRange\",\n    value: function updateRange(e, t) {\n      var o = e.sliderIndex,\n          n = this.sliders,\n          i = n[!o];\n      i.updateSwingRange(o, t);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var e = {};\n      e.conf = this.conf, e.sliderGroup = this, this.min = void 0, this.max = void 0, this.sliders[FORMER_SLIDER_INDEX].configure(FORMER_SLIDER_INDEX, e, this._id + '_' + 0), this.sliders[LATER_SLIDER_INDEX].configure(LATER_SLIDER_INDEX, e, this._id + '_' + 1), this.draw.apply(this, this._drawParams);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(e, t, o) {\n      var n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g = Math.ceil,\n          s = this.sliders,\n          c = s[!1],\n          h = s[!0],\n          p = o.colorRange,\n          m = p.colorRange,\n          u = p.data.mapByPercent,\n          f = o.gLegend.getFromEnv('number-formatter');\n      return this._fcChart = o.gLegend.getFromEnv('chart'), this.getValueFormPixel = function (e, t, o, n) {\n        this.getValueFormPixel = function (i) {\n          return e + (t - e) / (n - o) * i;\n        };\n      }, this.updateWhenInMove = function (e, t) {\n        this.updateWhenInMove = function (o, n) {\n          var i,\n              a,\n              r = this.extremes,\n              l = o.sliderIndex;\n          return i = l ? r[1] - r[0] + n : n, a = this.getValueFormPixel(i), a = t ? parseFloat(a).toFixed(2) + PERCENT_STR : e.legendValue(a), a;\n        };\n      }, this._drawParams = [e, t, o], this.updateWhenInMove(f, u), a = c.conf.outerCircle, i = c.conf.innerCircle, r = g(i.rFactor * o.rCalcBase / 2), r += g(a.style['stroke-width'] / 2), this.extremes[0] = e + r, this.extremes[1] = t - r, l = this.extremes[1] - this.extremes[0], this.min = this.min ? this.min : m[0].value, this.max = this.max ? this.max : m[m.length - 1].value, d = m[m.length - 1].value - m[0].value, c.currPos = l * (this.min - m[0].value) / d, h.currPos = l * (this.max - m[0].value) / d - l, n = c.draw(e, u ? f.legendPercentValue(this.min) : f.legendValue(this.min), o[o.key], o), n = h.draw(t, u ? f.legendPercentValue(this.max) : f.legendValue(this.max), o[o.key], o), c.swing = this.extremes.slice(0), h.swing = this.extremes.slice(0), c.swing[1] += h.currPos, h.swing[0] += c.currPos, this.getValueFormPixel(m[0].value, m[m.length - 1].value, this.extremes[0], this.extremes[1]), n;\n    }\n  }, {\n    key: \"updateWhenInRest\",\n    value: function updateWhenInRest(e, t) {\n      var o,\n          n,\n          i = this.sliders,\n          a = this.extremes,\n          r = e.sliderIndex;\n      r ? (o = i[!r].currPos, n = a[1] - a[0] + t) : (o = t, n = a[1] - a[0] + i[!r].currPos), this.min = +this.getValueFormPixel(o).toFixed(2), this.max = +this.getValueFormPixel(n).toFixed(2), this.gLegend.fireEvent('rangeUpdated', [{\n        min: this.min,\n        max: this.max\n      }]);\n    }\n  }, {\n    key: \"dragStarted\",\n    value: function dragStarted(e) {\n      var t = this.sliders,\n          o = this.extremes,\n          n = e.conf,\n          i = this._fcChart;\n      i.fireChartInstanceEvent('legendpointerdragstart', {\n        pointerIndex: +e.sliderIndex,\n        pointers: [{\n          value: this.getValueFormPixel(t['false'].currPos)\n        }, {\n          value: this.getValueFormPixel(o[1] - o[0] + t['true'].currPos)\n        }],\n        legendPointerHeight: n.outerRadius,\n        legendPointerWidth: n.innerRadius,\n        outerRadius: n.outerRadius,\n        innerRadius: n.innerRadius\n      }, [i.id]);\n    }\n  }, {\n    key: \"dragCompleted\",\n    value: function dragCompleted(e, t, o) {\n      var n,\n          i,\n          a = this.sliders,\n          r = this.extremes,\n          l = e.conf,\n          d = this.getValueFormPixel(a['false'].currPos),\n          g = this.getValueFormPixel(r[1] - r[0] + a['true'].currPos),\n          s = this._fcChart;\n      e.sliderIndex ? (n = d, i = this.getValueFormPixel(r[1] - r[0] + o)) : (n = this.getValueFormPixel(o), i = g), t && s.fireChartInstanceEvent('legendrangeupdated', {\n        previousMinValue: d,\n        previousMaxValue: g,\n        minValue: n,\n        maxValue: i\n      }, [s.id]), s.fireChartInstanceEvent('legendpointerdragstop', {\n        pointerIndex: +e.sliderIndex,\n        pointers: [{\n          value: n\n        }, {\n          value: i\n        }],\n        legendPointerHeight: l.outerRadius,\n        legendPointerWidth: l.innerRadius,\n        outerRadius: l.outerRadius,\n        innerRadius: l.innerRadius\n      }, [s.id]);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.sliders[FORMER_SLIDER_INDEX].dispose(), this.sliders[LATER_SLIDER_INDEX].dispose();\n    }\n  }]);\n\n  return SliderGroup;\n}();\n\nvar LegendValues =\n/*#__PURE__*/\nfunction (_LegendLabels) {\n  _inherits(LegendValues, _LegendLabels);\n\n  function LegendValues() {\n    var _this2;\n\n    _classCallCheck(this, LegendValues);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(LegendValues).call(this, arguments[0])), _this2._id = 'GL_VALUES', _this2.node = [];\n    return _this2;\n  }\n\n  _createClass(LegendValues, [{\n    key: \"configure\",\n    value: function configure(e) {\n      this.conf = e;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'LegendValues';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'legend';\n    }\n  }, {\n    key: \"getLogicalSpace\",\n    value: function getLogicalSpace(e, t, o) {\n      var n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s,\n          c,\n          h,\n          p,\n          m,\n          u,\n          f,\n          x,\n          y,\n          w,\n          C,\n          L,\n          S,\n          b,\n          v,\n          F,\n          _,\n          A,\n          E = Math.min,\n          P = Math.max,\n          I = 'bottom' === this.conf.legendPosition,\n          R = this._lSpace,\n          T = this.conf,\n          O = T.padding,\n          D = t.gLegend.getFromEnv('chartConfig'),\n          G = [],\n          V = [];\n\n      if (R && !o) return R.isImpure = !0, R;\n\n      for (n = t.colorRange, i = t.smartLabel, a = n.colorRange, g = n.getCumulativeValueRatio(), R = this._lSpace = {\n        bound: {\n          height: 0,\n          width: 0\n        },\n        node: {\n          logicArea: UNDEF,\n          smartTexts: []\n        }\n      }, A = R.node.smartTexts, S = merge(e, {}), S.height -= 2 * O.v, S.width -= 2 * O.h, S.x += O.h, S.y += O.v, i.useEllipsesOnOverflow(D.useEllipsesWhenOverflow), _ = merge(T.style, {}), normalizeFontSizeAppend(this._metaStyle = _), i.setStyle(_), F = i.getSmartText('W'), d = a.length, I ? (p = s = (g[d - 1] - g[0]) / 2 * S.width / 100, v = a[0].displayValue, r = i.getSmartText('string' != typeof v && v !== UNDEF && v.toString() || v, p, S.height), r.x = g[0] * S.width / 100, m = r.x + r.width, G.push(r.height)) : (p = s = (g[d - 1] - g[0]) / 2 * S.height / 100, r = i.getSmartText(a[0].displayValue, S.width, p), r.y = g[0] * S.height / 100, x = r.y + r.width, V.push(r.width)), A[0] = r, I ? (r = i.getSmartText(a[d - 1].displayValue, p, S.height), r.x = g[d - 1] * S.width / 100, f = r.x - r.width, G.push(r.height), u = m) : (r = i.getSmartText(a[d - 1].displayValue, S.width, p), r.y = g[d - 1] * S.height / 100, w = r.y - r.height, V.push(r.width), y = x), A[d - 1] = r, l = 1; l < d - 1; l++) {\n        r = UNDEF, b = a[l].displayValue, I ? (c = l + 1 === d - 1 ? f : g[l + 1] * S.width / 100, h = g[l] * S.width / 100, s = E(h - u, c - h), s > 1.5 * F.width && (r = i.getSmartText(b, 2 * s, S.height), r.x = g[l] * S.width / 100, u = s, G.push(r.height))) : (c = l + 1 === d - 1 ? w : g[l + 1] * S.height / 100, h = g[l] * S.height / 100, s = E(h - y, c - h), s > 2 * F.height && (r = i.getSmartText(b, S.width, 2 * s), r.y = g[l] * S.height / 100, y = s, V.push(r.width))), A[l] = r;\n      }\n\n      return I ? (C = P.apply(Math, G), S.height = C, e.height = C + 2 * O.v) : (L = P.apply(Math, V), S.width = L, e.width = L + 2 * O.h), R.node.logicArea = S, R.bound = e, e;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var e,\n          t,\n          o,\n          n,\n          i,\n          a,\n          r,\n          l,\n          d,\n          g,\n          s,\n          c,\n          h,\n          p,\n          m = this.conf,\n          u = 'bottom' === m.legendPosition,\n          f = m.bound && m.bound.style || {\n        stroke: 'none'\n      },\n          x = {};\n      2 <= arguments.length && arguments[1] ? (n = arguments[0], r = arguments[1]) : 1 <= arguments.length && (r = arguments[0]), p = r.animationManager, e = r.parentLayer, l = r.colorRange, d = l.getCumulativeValueRatio(), this.getLogicalSpace(n, r), i = this._lSpace, a = i.node.logicArea, c = i.node.smartTexts, this.group = o = p.setAnimation({\n        el: this.group || 'group',\n        attr: {\n          name: 'legend-values'\n        },\n        container: e,\n        component: gLegendRef\n      }), this.bound = t = p.setAnimation({\n        el: this.bound || 'rect',\n        attr: i.bound,\n        css: f,\n        container: o,\n        component: gLegendRef\n      });\n\n      for (var _e2 = 0; _e2 < this.node.length; _e2++) {\n        this.node[_e2].remove();\n      }\n\n      for (this.node = [], g = 0, s = d.length; g < s; g++) {\n        (h = c[g], !!h) && (u ? (x.y = a.y + h.height / 2, x.x = g === s - 1 ? a.x + h.x - h.width / 2 : g ? a.x + h.x : a.x + h.x + h.width / 2) : (x.x = a.x + h.width / 2, x.y = g === s - 1 ? a.y + h.y - h.height / 2 : g ? a.y + h.y : a.y + h.y + h.height / 2), this.node.push(p.setAnimation({\n          el: 'text',\n          attr: {\n            text: h.text,\n            x: x.x,\n            y: x.y,\n            lineHeight: this._metaStyle.lineHeight,\n            fill: m.style.fill\n          },\n          container: o,\n          component: gLegendRef\n        })));\n      }\n\n      return {\n        group: o,\n        bound: t\n      };\n    }\n  }]);\n\n  return LegendValues;\n}(LegendLabels);\n\nexport default GLegend;","map":null,"metadata":{},"sourceType":"module"}