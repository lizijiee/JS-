{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { ComponentInterface } from '../../../../fc-core/src/component-interface';\nimport Annotation from '../../../../fc-features/src/annotation/ext-annotation';\nimport { addDep, getDep } from '../../../../fc-core/src/dependency-manager';\nimport mapsAnimation from '../_internal/map-entities.animation';\nimport { pluck, imprint, extend2, parseTooltext, pluckNumber, parseUnsafeString, hasSVG, toRaphaelColor, trimString, convertColor } from '../../../../fc-core/src/lib';\nimport { priorityList } from '../../../../fc-core/src/schedular';\nimport raphaelShapesLitepath from '../../../../fc-core/src/_internal/redraphael/redraphael-shapes/redraphael-shapes.litepath';\n\nvar UNDEF,\n    Raphael = getDep('redraphael', 'plugin'),\n    userAgent = window.navigator.userAgent,\n    isIE = /msie/i.test(userAgent) && !window.opera,\n    COMMA = ',',\n    BLANK = '',\n    POSITION_TOP = 'top',\n    POSITION_BOTTOM = 'bottom',\n    POSITION_RIGHT = 'right',\n    POSITION_LEFT = 'left',\n    POSITION_MIDDLE = 'middle',\n    POSITION_CENTER = 'center',\n    CRISP = 'crisp',\n    math = window.Math,\n    mathMin = math.min,\n    mathMax = math.max,\n    isStrokeReg = /stroke/ig,\n    isWebKit = /AppleWebKit/.test(userAgent),\n    mathCeil = math.ceil,\n    colorize = function colorize(a, b) {\n  var c = b ? extend2(a.FCcolor, b, !1, !0) : {\n    FCcolor: a\n  };\n  return c.toString = toRaphaelColor, c;\n},\n    pruneStrokeAttrs = function pruneStrokeAttrs(a, b) {\n  var c,\n      d = {};\n  if (b = b || 1, !a || 'object' != typeof a) return d;\n\n  for (c in a) {\n    isStrokeReg.test(c) || ('stroke-width' === c ? (d[c] = +a[c] / b, isWebKit && (d[c] = d[c] && mathCeil(d[c]) || 0)) : d[c] = a[c]);\n  }\n\n  return d;\n},\n    getTextWrapWidth = {\n  right: function right() {\n    return arguments[1];\n  },\n  left: function left(a, b) {\n    return a - b;\n  },\n  center: function center(a, b) {\n    return 2 * mathMin(b, a - b);\n  }\n},\n    getTextWrapHeight = {\n  top: function top() {\n    return arguments[1];\n  },\n  middle: function middle(a, b) {\n    return 2 * mathMin(b, a - b);\n  },\n  bottom: function bottom(a, b) {\n    return a - b;\n  }\n},\n    convertArrayToIdMap = function convertArrayToIdMap(a) {\n  var b,\n      c = a && a.length || 0,\n      d = {};\n\n  for (; c--;) {\n    b = a[c], b.id !== UNDEF && (d[b.id.toLowerCase()] = b);\n  }\n\n  return d;\n};\n\naddDep({\n  name: 'mapsAnimation',\n  type: 'animationRule',\n  extension: mapsAnimation\n}), raphaelShapesLitepath(Raphael);\n\nvar Entities =\n/*#__PURE__*/\nfunction (_ComponentInterface) {\n  _inherits(Entities, _ComponentInterface);\n\n  function Entities() {\n    var _this;\n\n    _classCallCheck(this, Entities);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Entities).call(this)), _this.components = {};\n    return _this;\n  }\n\n  _createClass(Entities, [{\n    key: \"getName\",\n    value: function getName() {\n      return 'entities';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'dataset';\n    }\n  }, {\n    key: \"configureAttributes\",\n    value: function configureAttributes(a) {\n      if (!a) return;\n      this.JSONData = {\n        data: a\n      };\n      var b,\n          c,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l = this,\n          m = l.getFromEnv('chart'),\n          n = m.jsonData,\n          o = l.config,\n          p = n.map || n.chart,\n          q = [],\n          r = l.getFromEnv('colorManager'),\n          s = n.entitydef || [];\n\n      for (g in !o.attachEvent && r && (l.addExtEventListener('legendUpdate', function () {\n        if (k = arguments[1], 'legend' === k.component) l.legendInteractivity(k.legendItem, k.colorObj);else for (q = k.maxMinArray, h = q.length, j = 0; j < h; j++) {\n          l.updateEntityColors(q[j].min, q[j].max);\n        }\n      }, r), o.attachEvent = !0), b = n.data && n.data[0] && n.data[0].data ? l.JSONData = n.data[0].data || [] : l.JSONData = n.data || [], o.useSNameAsId = pluckNumber(p.usesnameasid, 0), this._redefineEntities(s), c = l.components.data, o.showTooltip = pluckNumber(p.showtooltip, 1), o.showHoverEffect = pluckNumber(p.showhovereffect, 0), b = convertArrayToIdMap(b), l.calculateDataLimits(), n.colorrange || l.detachChild(l.getChildren('colorRange') && l.getChildren('colorRange')[0].getId()), c) {\n        e = b[g], f = c[g], e ? this._configureEntity(g, f, imprint(Entities._sanitizeEntityOptions(extend2({}, e)), f.config)) : this._configureEntity(g, f, f.config);\n      }\n    }\n  }, {\n    key: \"updateEntityColors\",\n    value: function updateEntityColors(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = this,\n          j = i.components.data,\n          k = i.getFromEnv('chart'),\n          l = {\n        \"fill-opacity\": 0\n      };\n\n      for (f in j) {\n        c = j[f], d = c.config, e = d.cleanValue, g = d.alphaArr || [], h = {\n          \"fill-opacity\": g[0] / 100 || 1\n        }, e < a || e > b ? (Entities.setCustomAttrs(c, l, k), c.hidden = !0) : (c.hidden = !1, Entities.setCustomAttrs(c, h, k));\n      }\n    }\n  }, {\n    key: \"legendInteractivity\",\n    value: function legendInteractivity(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j = this,\n          k = j.getFromEnv('chart'),\n          l = j.components.data,\n          m = a.config,\n          n = a.hasState('hidden'),\n          o = j.getFromEnv('colorManager'),\n          p = {},\n          q = {\n        \"fill-opacity\": 0\n      };\n\n      for (c in k.getFromEnv('animationManager').setAnimationState('legendInteraction'), l) {\n        l.hasOwnProperty(c) && (d = l[c], m = d.config, e = m.cleanValue, h = o.getColorObj(e), f = m.visibleEntityAttr, p['fill-opacity'] = f['fill-opacity'], g = n ? p : q, b.code === (!h.outOfRange && h.code) && (d.hidden = !n, Entities.setCustomAttrs(d, g, k), n ? a && a.removeLegendState('hidden') : a.setLegendState('hidden')));\n      }\n    }\n  }, {\n    key: \"calculateDataLimits\",\n    value: function calculateDataLimits() {\n      var a,\n          b,\n          c,\n          d,\n          e = this,\n          f = e.getFromEnv('chart'),\n          g = e.config,\n          h = f.jsonData,\n          j = h.data || [],\n          k = this.getFromEnv('number-formatter'),\n          l = +Infinity,\n          m = -Infinity;\n\n      for (d = 0, c = j.length; d < c; d++) {\n        b = j[d].value, a = k.getCleanValue(b), l = mathMin(l, a), m = mathMax(m, a);\n      }\n\n      g.max = m, g.min = l;\n    }\n  }, {\n    key: \"_configureEntity\",\n    value: function _configureEntity(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q,\n          r,\n          s,\n          t,\n          u,\n          v,\n          w,\n          x,\n          y,\n          z,\n          A = this,\n          B = A.getFromEnv('chart'),\n          C = A.config,\n          D = this.getFromEnv('number-formatter'),\n          E = B.config,\n          F = E.entityOpts,\n          G = b.config,\n          H = b.labelConfig,\n          I = c.value,\n          J = G.cleanValue = D.getCleanValue(I),\n          K = G.formattedValue = J === UNDEF ? UNDEF : D.dataLabels(J),\n          L = pluckNumber(c.showtooltip, F.showTooltip),\n          M = this._getDefaultTooltip(b, c, A),\n          N = {\n        formattedValue: K,\n        sName: c.shortLabel,\n        lName: c.label\n      },\n          O = F.dataLabels.style,\n          P = G.toolText = L ? parseUnsafeString(pluck(parseTooltext(pluck(c.tooltext, F.tooltext, M), [1, 2, 7, 38, 39], N, c))) : BLANK,\n          Q = G.borderColor = pluck(c.bordercolor, F.borderColor),\n          R = G.borderAlpha = pluck(c.borderalpha, F.borderAlpha),\n          S = G.borderThickness = pluckNumber(c.borderthickness, F.borderThickness),\n          T = F.hoverOnNull,\n          U = G.useHoverColor = pluckNumber(c.showhovereffect, c.usehovercolor, T ? F.showHoverEffect : isNaN(I) ? 0 : F.showHoverEffect),\n          V = G.labelAlignment,\n          W = A.getFromEnv('colorManager');\n\n      if (b.hidden = !1, G.showLabel = pluckNumber(c.showlabel, F.showLabels), G.labelPadding = pluckNumber(c.labelpadding, F.labelPadding), G.fontFamily = pluck(c.font, O.fontFamily), G.fontSize = pluckNumber(parseInt(c.fontsize, 10), parseInt(O.fontSize, 10)), G.fontBold = pluckNumber(c.fontbold, 0), G.fontColor = pluck(c.fontcolor, O.color), G.connectorColor = pluck(c.labelconnectorcolor, F.connectorColor), G.connectorAlpha = pluck(c.labelconnectoralpha, F.connectorAlpha), G.hoverBorderThickness = pluckNumber(c.borderhoverthickness, c.hoverborderthickness, F.hoverBorderThickness), G.hoverBorderColor = pluck(c.borderhovercolor, c.hoverbordercolor, F.hoverBorderColor, G.borderColor), G.hoverBorderAlpha = pluck(c.borderhoveralpha, c.hoverborderalpha, F.hoverBorderAlpha, G.borderAlpha), G.connectorThickness = pluckNumber(c.labelconnectorthickness, F.connectorThickness), G.origConnectorThickness = G.connectorThickness, G.borderThickness = S, G.link = c.link, G.isVisible = !0, G.id = a, G.originalId = c.origId, null !== J && (d = W && W.getColor(J), d && !d.outOfRange && (t = d.code, d.oriAlpha !== UNDEF && (u = d.oriAlpha + ''))), pluck(c.color, c.alpha, c.angle, c.ratio) === UNDEF ? (r = colorize({\n        color: pluck(t, F.fillColor),\n        alpha: pluck(u, F.fillAlpha),\n        angle: pluck(F.fillAngle),\n        ratio: pluck(F.fillRatio)\n      }), q = colorize({\n        color: pluck(F.nullEntityColor),\n        alpha: pluck(F.nullEntityAlpha),\n        angle: pluck(F.nullEntityAngle),\n        ratio: pluck(F.nullEntityRatio)\n      }), m = null === J ? q : r, h = m.FCcolor.color, j = m.FCcolor.alpha, k = m.FCcolor.angle, l = m.FCcolor.ratio) : (h = pluck(c.color, t, F.fillColor), j = pluck(c.alpha, u, F.fillAlpha), k = pluck(c.angle, F.fillAngle), l = pluck(c.ratio, F.fillRatio), m = colorize({\n        color: h,\n        alpha: j,\n        angle: k,\n        ratio: l\n      })), P === BLANK && (C.showTooltip = 0), G.visibleEntityAttr = {\n        stroke: convertColor(Q, R),\n        fill: (G.fillColor = m).toString(),\n        \"fill-opacity\": j / 100\n      }, z = j.split(COMMA), G.alphaArr = z, U && (pluck(c.fillhovercolor, c.fillhoveralpha, c.fillhoverangle, c.fillhoverratio, c.hoverfillcolor, c.hoverfillalpha, c.hoverfillratio, c.hoverfillangle) === UNDEF ? (!F.hoverColorObject && (F.hoverColorObject = colorize({\n        color: F.hoverFillColor,\n        alpha: F.hoverFillAlpha,\n        angle: F.hoverFillAngle,\n        ratio: F.hoverFillRatio\n      })), s = F.hoverColorObject) : (h = pluck(c.fillhovercolor, c.hoverfillcolor, F.hoverFillColor), j = pluck(c.fillhoveralpha, c.hoverfillalpha, F.hoverFillAlpha), k = pluck(c.fillhoverangle, c.hoverfillangle, F.hoverFillAngle), l = pluck(c.fillhoverratio, c.hoverfillratio, F.hoverFillRatio), s = colorize({\n        color: h,\n        alpha: j,\n        angle: k,\n        ratio: l\n      })), G.hoverColor = s), H || (H = b.labelConfig = {}), n = G.fontColor, o = G.fontFamily, p = G.fontBold, P = G.toolText, e = G.link, V ? (f = V[0], g = V[1]) : (f = POSITION_CENTER, g = POSITION_MIDDLE), H.align = f, H.vAlign = g, H.bgColor = BLANK, H.borderColor = BLANK, H.fontColor = n, H.fontFamily = o, H.fontBold = p, H.toolText = P, H.link = e, 'object' == typeof G.options) for (v = G.entityLabels = G.entityLabels || [], x = G.labels || [], y = x.length; y--;) {\n        v[y] || (v[y] = {\n          config: {}\n        }), H = v[y].config, V = x[y].labelAlignment, V ? (f = V[0], g = V[1]) : (f = POSITION_CENTER, g = POSITION_MIDDLE), H.align = f, H.vAlign = g, H.displayValue = A.getDisplayValue(b, x[y], G.options.isDataEnabled, !y, c), H.bgColor = BLANK, H.borderColor = BLANK, H.toolText = P, H.align = f, H.vAlign = g, H.bgColor = BLANK, H.borderColor = BLANK, H.fontColor = n, H.fontFamily = o, H.fontBold = p, H.toolText = P;\n      } else w = {\n        shortText: G.shortLabel,\n        text: G.label\n      }, H.displayValue = A.getDisplayValue(b, w, !0, !0, c);\n    }\n  }, {\n    key: \"getDisplayValue\",\n    value: function getDisplayValue(a, b, c, d, e) {\n      var f,\n          g = this.getFromEnv('chart'),\n          h = g.config.entityOpts,\n          i = a.config,\n          j = i.cleanValue,\n          k = i.formattedValue,\n          l = h.labelSepChar;\n      return c ? d && 'undefined' != typeof e.displayvalue ? f = e.displayvalue : (f = pluck(h.includeNameInLabels ? h.useShortName ? b.shortText : b.text : ''), h.includeValueInLabels && null !== j && (f = f === UNDEF ? k : f + l + k)) : f = i.label, f;\n    }\n  }, {\n    key: \"_redefineEntities\",\n    value: function _redefineEntities(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o = this,\n          p = o.config,\n          q = o.getFromEnv('chart'),\n          r = {},\n          s = {},\n          t = q.config.entities,\n          u = p.useSNameAsId,\n          v = 0;\n\n      for (b = a.length; b--;) {\n        if (c = a[b], d = c.internalid, e = c.newid ? c.newid : d, f = c.sname, g = c.lname, n = t[d], d = trimString(d), e = trimString(e), e = e && e.toLowerCase(), n) {\n          for (m in r[e] = j = {\n            origId: d\n          }, s[d] = !0, n) {\n            j[m] = n[m];\n          }\n\n          j.shortLabel = f || n.shortLabel, j.label = g || n.label, j.showhovereffect = c.showhovereffect, j.fillhovercolor = c.fillhovercolor, j.fillhoveralpha = c.fillhoveralpha, j.fillhoverangle = c.fillhoverangle, j.fillhoverratio = c.fillhoverratio, j.borderhoverthickness = c.borderhoverthickness;\n        }\n      }\n\n      for (h in l = o.components.data, l || (l = o.components.data = {}), r) {\n        h = h.toLowerCase(), l[h] || (l[h] = {\n          config: {}\n        }), l[h].config = r[h], v += 1;\n      }\n\n      for (h in k = l, t) {\n        if (j = t[h], h = trimString(h), !s[h]) {\n          for (m in u ? (n = k[j.shortLabel.toLowerCase()], !n && (n = k[j.shortLabel.toLowerCase()] = {}), n.config = {}, n.origId = j.shortLabel) : (n = k[h.toLowerCase()], !n && (n = k[h.toLowerCase()] = {}), n.config = {}, n.config.origId = h), j) {\n            n.config[m] = j[m];\n          }\n\n          v += 1;\n        }\n      }\n\n      p.entityCount = v;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var a,\n          b = this,\n          c = b.config,\n          d = b.getFromEnv('chart'),\n          e = hasSVG ? 200 : 10;\n      b.createContainer(), this.config.ready = !1, c.BATCH_SIZE = e, c.labelBatchSize = hasSVG ? 200 : 20, a = this._batchRender(), a(0), d.config.entityFlag = !0, d.checkComplete();\n    }\n  }, {\n    key: \"_batchRender\",\n    value: function _batchRender() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f = this,\n          g = f.config,\n          h = f.getFromEnv('chart'),\n          j = h.config.entities.firstEntity,\n          k = f.components.data,\n          l = g.BATCH_SIZE,\n          m = g.entityKeys = j ? f._getKeys(j, k) : Object.keys(k),\n          n = g.entityLength = m.length,\n          o = function o(g) {\n        for (a = g, c = 0; m[a] !== UNDEF;) {\n          if (b = k[m[a]], e = f.drawEntity(b, l), c += e, b.config.drawn && (d = a === n - 1 ? b : k[m[a - 1]], d && (d.config.drawn = !1, d.config.outlineStartIndex = UNDEF), a++), c >= l) {\n            f.addJob('entityDraw', o.bind(this, a), priorityList.entitydraw);\n            break;\n          }\n        }\n\n        a === n && (f._addEventListenersToEntities(0), f.initComplete());\n      };\n\n      return o;\n    }\n  }, {\n    key: \"_addEventListenersToEntities\",\n    value: function _addEventListenersToEntities(a) {\n      var b,\n          c,\n          d,\n          e,\n          f = this,\n          g = f.components.data,\n          h = f.config,\n          j = h.BATCH_SIZE,\n          k = h.entityKeys,\n          l = h.entityLength,\n          m = 0;\n\n      for (b = a; b < l; b++) {\n        if (c = g[k[b]], e = c.config, d = e.options, d && !1 === d.isDataEnabled || f.addMouseGestures(c), m++, m === j) {\n          f.addJob('_addEventListenersToEntities', f._addEventListenersToEntities.bind(this, b), priorityList.entitydraw);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"_getDefaultTooltip\",\n    value: function _getDefaultTooltip(a, b) {\n      var c,\n          d,\n          e = this,\n          f = a.config.cleanValue,\n          g = a.config.formattedValue,\n          h = e.getFromEnv('chart').config.entityOpts;\n\n      if ('object' == typeof a.config.options) {\n        if (d = b.labels && b.labels[0], !d) return UNDEF;\n        c = (h.useSNameInTooltip ? d.shortText : d.text) + (null === f ? BLANK : h.tooltipSepChar + g);\n      } else c = (h.useSNameInTooltip ? b.shortLabel : b.label) + (null === f ? BLANK : h.tooltipSepChar + g);\n\n      return c;\n    }\n  }, {\n    key: \"drawEntity\",\n    value: function drawEntity(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l,\n          m = this,\n          n = m.getFromEnv('chart'),\n          o = n.getFromEnv('animationManager'),\n          p = a.config,\n          q = hasSVG || !isIE ? 'litepath' : 'path',\n          r = n.config.entityOpts,\n          s = p.outlines,\n          t = m.getFromEnv('toolTipController'),\n          u = this.getLinkedParent().getChildContainer('plot'),\n          v = this.getLinkedParent().getChildContainer('plotShadow'),\n          w = p.toolText,\n          x = r.shadow,\n          y = [],\n          z = {};\n\n      if (m._configureEntityDrawingParams(a), p = a.config, e = p.visibleEntityAttr, l = p.shadowOptions, c = p.outlineStartIndex === UNDEF ? s.length : p.outlineStartIndex, a.graphics || (a.graphics = {}), j = 0, y = p.outlinePath || (p.outlinePath = []), k = p.customStrokeWidthModifier, 'object' == typeof p.options) {\n        for (; c--;) {\n          if (y = s[c].outline, f = !0 === p.options.isDataEnabled ? e : extend2(extend2({}, e), pruneStrokeAttrs(s[c].style, k)), g = a.graphics.outlines, g || (g = a.graphics.outlines = []), g[c] || (g[c] = {}), h = g[c].outline, f[q] = y, h = g[c].outline = o.setAnimation({\n            el: q,\n            container: u,\n            attr: f,\n            component: m,\n            label: 'path'\n          }), h.shadow(!!x && l, v), t.enableToolTip(h, w), j++, p.outlineStartIndex = c, j === b) return j;\n        }\n\n        return p.drawn = !0, j;\n      }\n\n      for (; c--;) {\n        if (d = s[c], y = d.concat(y), j++, p.outlineStartIndex = c, j === b) return p.outlinePath = y, j;\n      }\n\n      return a.graphics.outlines || (e[q] = y), Object.assign(z, e, a.hidden && {\n        \"fill-opacity\": 0\n      } || {}), a.graphics.outlines = o.setAnimation({\n        el: a.graphics.outlines || q,\n        container: u,\n        attr: z,\n        component: m,\n        label: 'path'\n      }), p.drawn = !0, p.outlineStartIndex = 0, p.outlinePath = [], a.graphics.outlines.shadow(!!x && l, v), t.enableToolTip(a.graphics.outlines, w), j;\n    }\n  }, {\n    key: \"_configureEntityDrawingParams\",\n    value: function _configureEntityDrawingParams(a) {\n      var b,\n          c = this,\n          d = c.getFromEnv('chart'),\n          e = a.config,\n          f = d.config.entityOpts,\n          g = d.config.scalingParams,\n          h = !isIE || hasSVG,\n          i = g.scaleFactor,\n          j = g.strokeWidth,\n          k = (h ? d.baseScaleFactor : 1) * j,\n          l = 1 === f.scaleBorder,\n          m = e.borderThickness,\n          n = e.alphaArr,\n          o = e.origConnectorThickness,\n          p = e.hoverBorderThickness,\n          q = e.visibleEntityAttr,\n          r = q['fill-opacity'];\n      e.shadowOptions = {\n        scalefactor: [i, i * d.config.baseScaleFactor],\n        opacity: mathMax.apply(math, n) / 100,\n        useFilter: 0\n      }, e.fillOpacity = a.hidden ? 0 : r, h ? (m = e.entityBorderThickness = l ? m * k : m / i, o /= i, b = l ? i : g.sFactor, p && (p = e.hoverBorderThickness = l ? p * k : p / i)) : (m = l ? m * j : m, b = l ? g.scaleFactor : d.baseScaleFactor), e.entityBorderThickness = m, e.connectorThickness = o, e.customStrokeWidthModifier = b, q['stroke-width'] = m, q.transform = hasSVG || !isIE ? '' : g.transformStr;\n    }\n  }, {\n    key: \"drawLabels\",\n    value: function drawLabels(a) {\n      var b,\n          c,\n          d,\n          e,\n          f = this,\n          g = a,\n          h = f.getFromEnv('chart'),\n          k = f.config,\n          l = k.labelBatchSize,\n          m = k.entityLength,\n          n = [],\n          o = h.getChildContainer('upperAnnotationGroup'),\n          p = 0,\n          q = f.getChildren('mapLabelAnnotations') && f.getChildren('mapLabelAnnotations')[p],\n          r = 0,\n          s = 0,\n          t = h.config.annotationConfig;\n\n      for (b in q || (e = new Annotation(), f.attachChild(e, 'mapLabelAnnotations'), q = f.getChildren('mapLabelAnnotations')[p], q.addCustomGroup(o)), q.destroy(), q._renderer && (q._renderer = null), t.showbelow = 0, g) {\n        if (f.drawLabel(g[b], n), r++, r === l) {\n          for (c = 0; c < n.length; c++) {\n            n[c].animationLabel = 'entityLabel';\n          }\n\n          for (d = q.addGroup(Object.assign(t, {\n            id: 'entityLabels' + p,\n            items: n,\n            animationLabel: 'entityLabelGroup'\n          }), f), c = 0; c < d.items.length; c++) {\n            d.items[c].addEventListener('fc-mouseover', n[c].onmouseover), d.items[c].addEventListener('fc-mouseout', n[c].onmouseout), d.items[c].addEventListener('fc-click', n[c].onclick);\n          }\n\n          p++, q = f.getChildren('mapLabelAnnotations') && f.getChildren('mapLabelAnnotations')[p], q || (e = new Annotation(), f.attachChild(e, 'mapLabelAnnotations'), q = f.getChildren('mapLabelAnnotations')[p], q.addCustomGroup(o)), q.destroy(), q._renderer && (q._renderer = null), r = 0, n = [];\n        } else if (s == m - 1) {\n          for (c = 0; c < n.length; c++) {\n            n[c].animationLabel = 'entityLabel';\n          }\n\n          for (d = q.addGroup(Object.assign(t, {\n            id: 'entityLabels' + p,\n            items: n,\n            animationLabel: 'entityLabelGroup'\n          }), f), c = 0; c < d.items.length; c++) {\n            d.items[c].addEventListener('fc-mouseover', n[c].onmouseover), d.items[c].addEventListener('fc-mouseout', n[c].onmouseout), d.items[c].addEventListener('fc-click', n[c].onclick);\n          }\n        }\n\n        s++;\n      }\n\n      f.drawLabelConnFn(0);\n    }\n  }, {\n    key: \"drawLabelConnFn\",\n    value: function drawLabelConnFn(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g = this,\n          h = g.config,\n          j = g.components.data,\n          k = h.BATCH_SIZE,\n          m = h.entityKeys,\n          n = m.length,\n          o = 0;\n\n      for (c = a; c < n; c++) {\n        if (f = j[m[c]], e = f.config, 'object' == typeof e.options) for (d = e.labels, b = d && d.length || 0; b--;) {\n          d[b].labelConnectors && (g.drawLabelConnectors(f, d[b].labelConnectors, g), o++);\n        } else e.labelConnectors && (g.drawLabelConnectors(f, e.labelConnectors, g), o++);\n\n        if (o === k) {\n          g.addJob('drawLabelConnectors', g.drawLabelConnFn.bind(this, c), priorityList.entitydraw);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"_getLabelObject\",\n    value: function _getLabelObject(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q,\n          r,\n          s,\n          t = this,\n          u = t.getFromEnv('chart'),\n          v = a.config,\n          w = u.config.scalingParams,\n          x = a.graphics && a.graphics.outlines,\n          y = v.fontSize,\n          z = v.labelPadding,\n          A = v.labels || [],\n          B = v.entityLabels || [];\n      return b === UNDEF ? (d = a.labelConfig, e = v.labelPosition, f = v.labelAlignment) : (r = A[b], s = B[b], d = s.config, g = d.style = r.style, e = r.labelPosition, f = r.labelAlignment), e ? (j = e[0], k = e[1]) : (l = x.getBBox(), j = l.x + l.width / 2, k = l.y + l.height / 2), f ? (m = f[0], n = f[1], m === POSITION_RIGHT ? j -= z : m === POSITION_LEFT && (j += z), n === POSITION_TOP ? k -= z : n === POSITION_BOTTOM && (k += z)) : (m = POSITION_CENTER, n = POSITION_MIDDLE), o = parseFloat(y) / w.sFactor, !c && g && (g.color && (d.fontColor = g.color), g['font-size'] && (o = parseFloat(g['font-size']) / w.sFactor), g['font-family'] && (d.fontFamily = g['font-family']), g['font-weight'] !== UNDEF && (d.fontBold = 'bold' === g['font-weight'])), d.x = j.toString(), d.y = k.toString(), d.wrap = 1, d.type = 'text', d.fontSize = o, {\n        x: j.toString(),\n        y: k.toString(),\n        wrapwidth: getTextWrapWidth[m](h, j + p) - z,\n        wrapheight: getTextWrapHeight[n](i, k + q) - z,\n        wrap: 1,\n        type: 'text',\n        align: d.align,\n        valign: d.vAlign,\n        text: d.displayValue,\n        tooltext: d.toolText,\n        css: d.link !== UNDEF && {\n          cursor: 'pointer',\n          _cursor: 'hand'\n        },\n        bgcolor: d.bgColor,\n        bordercolor: d.borderColor,\n        fillcolor: d.fontColor,\n        fontsize: d.fontSize,\n        font: d.fontFamily,\n        bold: d.fontBold,\n        onclick: function onclick(b) {\n          var c,\n              d,\n              e = a.graphics.outlines;\n          if (e instanceof Array) for (c = 0, d = e.length; c < d; c++) {\n            t.entityClick(e[c].outline, b);\n          } else t.entityClick(e, b);\n        },\n        onmouseover: function onmouseover(b) {\n          var c,\n              d,\n              e = a.graphics.outlines;\n          if (e instanceof Array) for (c = 0, d = e.length; c < d; c++) {\n            t.entityRollOver(e[c].outline, b);\n          } else t.entityRollOver(e, b);\n        },\n        onmouseout: function onmouseout(b) {\n          var c,\n              d,\n              e = a.graphics.outlines;\n          if (e instanceof Array) for (c = 0, d = e.length; c < d; c++) {\n            t.entityRollOut(e[c].outline, b);\n          } else t.entityRollOut(e, b);\n        },\n        ontouchstart: function ontouchstart(b) {\n          var c,\n              d,\n              e = a.graphics.outlines;\n          if (e instanceof Array) for (c = 0, d = e.length; c < d; c++) {\n            t.entityRollOver(e[c].outline, b);\n          } else t.entityRollOver(e, b);\n          t.entityRollOver(e, b);\n        }\n      };\n    }\n  }, {\n    key: \"drawLabel\",\n    value: function drawLabel(a, b) {\n      var c,\n          d,\n          e,\n          f = this,\n          g = a.config,\n          h = g.showLabel;\n      if (h) if ('object' == typeof g.options) for (e = g.labels, d = e && e.length || 0, c = g.options.isDataEnabled; d--;) {\n        b.push(f._getLabelObject(a, d, c, !d));\n      } else b.push(f._getLabelObject(a, UNDEF, !0, !0));\n    }\n  }, {\n    key: \"drawLabelConnectors\",\n    value: function drawLabelConnectors(a, b, c) {\n      var d,\n          e,\n          f = a.config,\n          g = this,\n          h = g.getFromEnv('chart'),\n          j = h.getFromEnv('animationManager'),\n          k = h.config.scalingParams,\n          l = c.getLinkedParent().getChildContainer('plot'),\n          m = b && b.length || 0,\n          n = f.showLabel;\n\n      for (; m--;) {\n        e = b[m], d = a.graphics.connectorElem, n ? a.graphics.connectorElem = d = j.setAnimation({\n          el: a.graphics.connectorElem || 'path',\n          attr: {\n            path: e,\n            opacity: 1,\n            transform: hasSVG || !isIE ? '' : k.transformStr,\n            stroke: convertColor(f.connectorColor, f.connectorAlpha),\n            \"shape-rendering\": CRISP,\n            \"stroke-width\": f.connectorThickness\n          },\n          container: l,\n          component: g,\n          label: 'labelConnectors'\n        }) : d && d.hide();\n      }\n    }\n  }, {\n    key: \"entityClick\",\n    value: function entityClick(a, b) {\n      var c = a.node.__entity,\n          d = this,\n          e = d.getFromEnv('chart'),\n          f = e.config.scalingParams,\n          g = a.getBBox(),\n          h = e.getFromEnv('linkClickFN'),\n          i = c.config,\n          j = i.link;\n      g.width *= f.scaleFactor, g.height *= f.scaleFactor, g.x = g.x * f.scaleFactor + f.translateX, g.y = g.y * f.scaleFactor + f.translateY, g.x2 = g.x + g.width, g.y2 = g.y + g.height, e.fireChartInstanceEvent('entityclick', i.eventArgs, b), j !== UNDEF && h.call({\n        link: j,\n        entity: c,\n        entityBox: g\n      }, !0);\n    }\n  }, {\n    key: \"entityRollOver\",\n    value: function entityRollOver(a, b) {\n      var c = a.node.__entity,\n          d = this,\n          e = c.config,\n          f = d.getFromEnv('chart'),\n          g = f.getFromEnv('animationManager'),\n          h = e.hoverAttr;\n      f.plotEventHandler(a, b, 'entityRollOver'), a.data('hovered') ? clearTimeout(c.config.timer) : e.useHoverColor && e.isVisible && !c.hidden && h && (f.config.hoverEntity = a, g.setAnimation({\n        el: a,\n        attr: h,\n        component: d,\n        state: 'updating',\n        label: 'path'\n      }), a.data('hovered', !0));\n    }\n  }, {\n    key: \"entityRollOut\",\n    value: function entityRollOut(a, b) {\n      var c,\n          d = a.node.__entity,\n          e = this,\n          f = e.getFromEnv('chart'),\n          g = f.getFromEnv('animationManager'),\n          h = d.config,\n          i = h.revertAttr;\n      f.plotEventHandler(a, b, 'entityRollOut'), d.config.timer = setTimeout(function () {\n        c = d.hidden, !0 !== c && i && (g.setAnimation({\n          el: a,\n          attr: i,\n          component: e,\n          state: 'updating',\n          label: 'path'\n        }), a.data('hovered', !1));\n      }, 100);\n    }\n  }, {\n    key: \"addMouseGestures\",\n    value: function addMouseGestures(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g = a.config,\n          h = g.originalId,\n          j = this,\n          k = a.graphics,\n          l = g.useHoverColor,\n          m = g.hoverBorderThickness,\n          n = g.hoverBorderColor,\n          o = g.hoverBorderAlpha,\n          p = g.entityBorderThickness,\n          q = g.borderColor,\n          r = g.borderAlpha,\n          s = g.link,\n          t = g.visibleEntityAttr,\n          u = function u(b) {\n        s !== UNDEF && b.css({\n          cursor: 'pointer',\n          _cursor: 'hand'\n        }), b.data('eventArgs', g.eventArgs), b.data('groupId', 'groupId' + h), b.node.__entity = a, a._listenersBinded || b.on('fc-click', j.entityClick.bind(j, b)).hover(j.entityRollOver.bind(j, b), j.entityRollOut.bind(j, b));\n      };\n\n      for (b in g.eventArgs = {\n        value: g.cleanValue,\n        label: g.label,\n        shortLabel: g.shortLabel,\n        originalId: g.origId,\n        id: g.id || g.origId\n      }, g.legacyEventArgs = {\n        value: g.value,\n        lName: g.label,\n        sName: g.shortLabel,\n        id: g.originalId || g.id\n      }, l && (g.hoverAttr = {\n        fill: toRaphaelColor(g.hoverColor)\n      }, g.revertAttr = {\n        fill: toRaphaelColor(g.fillColor),\n        stroke: toRaphaelColor(g.borderColor, g.borderAlpha)\n      }, g.revertAttr['fill-opacity'] = t['fill-opacity'], m !== p && (g.hoverAttr['stroke-width'] = pluckNumber(m, p), g.revertAttr['stroke-width'] = p), (n !== q || o !== r) && (g.hoverAttr.stroke = convertColor(n, o), g.revertAttr.stroke = convertColor(q, r))), k) {\n        if (k.hasOwnProperty(b)) if (k[b] instanceof Array) {\n          for (f = k[b], c = 0, e = f.length; c < e; c++) {\n            d = f[c].outline, u(d);\n          }\n\n          a._listenersBinded = !0;\n        } else d = k[b], u(d), a._listenersBinded = !0;\n      }\n    }\n  }, {\n    key: \"getDataLimits\",\n    value: function getDataLimits() {\n      var a = this,\n          b = a.config;\n      return {\n        max: b.max,\n        min: b.min\n      };\n    }\n  }, {\n    key: \"createContainer\",\n    value: function createContainer() {\n      var a = this,\n          b = a.getLinkedParent(),\n          c = a.getFromEnv('animationManager'),\n          d = b.getChildContainer('layer0');\n      a.getChildContainer('abovePlotGroup') || a.addChildContainer('abovePlotGroup', c.setAnimation({\n        el: 'group',\n        attr: {\n          name: 'abovePlotGroup',\n          opacity: 1\n        },\n        container: d,\n        component: a,\n        label: 'group'\n      })), a.getChildContainer('belowPlotGroup') || a.addChildContainer('belowPlotGroup', c.setAnimation({\n        el: 'group',\n        attr: {\n          name: 'belowPlotGroup',\n          opacity: 1\n        },\n        container: d,\n        component: a,\n        label: 'group'\n      }));\n    }\n  }, {\n    key: \"initComplete\",\n    value: function initComplete() {\n      var a = this,\n          b = a.getFromEnv('chart'),\n          c = a.components.data;\n      this.drawLabels(c), b.config.entitiesReady = !0, b.checkComplete();\n    }\n  }], [{\n    key: \"setCustomAttrs\",\n    value: function setCustomAttrs(a, b) {\n      var c, d;\n      a && (c = a.graphics, d = c.outlines, d.attr(b));\n    }\n  }, {\n    key: \"_sanitizeEntityOptions\",\n    value: function _sanitizeEntityOptions(a) {\n      return delete a.outlines, delete a.label, delete a.shortlabel, delete a.labelposition, delete a.labelalignment, delete a.labelconnectors, a;\n    }\n  }, {\n    key: \"_getKeys\",\n    value: function _getKeys(a, b) {\n      var c = [a],\n          d = a;\n\n      for (; b[d];) {\n        d = b[d].nextId, c.push(d);\n      }\n\n      return c;\n    }\n  }]);\n\n  return Entities;\n}(ComponentInterface);\n\nexport default Entities;","map":null,"metadata":{},"sourceType":"module"}