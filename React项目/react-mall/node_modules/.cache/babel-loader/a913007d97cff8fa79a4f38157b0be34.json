{"ast":null,"code":"import _slicedToArray from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport range from './utils/array/range';\nimport { UNDEF, safeMin } from '../lib';\nimport { bimap, deInterpolateLinear } from './scales/continuous';\nimport interpolateNumber from './utils/interpolators/number';\n\nvar errorMapping = bimap([2, 100], [80, 20], deInterpolateLinear, interpolateNumber),\n    getErrorValue = function getErrorValue(a) {\n  return 100 <= a ? .2 : 1 >= a ? 0 : errorMapping(a) / 100;\n},\n    niceInterval = function niceInterval(a) {\n  if (1 >= a) return 1;\n  var b = [],\n      c = Math.ceil(a);\n  return b[2] = c % 2, b[5] = c % 5, b[10] = c % 10, safeMin(b) + c;\n},\n    noLimitChange = function noLimitChange(a, b, c, d, e, f) {\n  var g = Math.abs;\n\n  var h,\n      i,\n      l,\n      m,\n      n,\n      o,\n      p,\n      q,\n      r,\n      s,\n      t,\n      u,\n      v = a,\n      w = Math.ceil(c * (1 - d)),\n      x = Math.floor(c * (1 + d)),\n      y = [],\n      z = function z(a) {\n    var b,\n        c,\n        d,\n        e = [10, 5, 2, 1],\n        f = e.length;\n\n    for (b = 0; b < f; ++b) {\n      if (c = a % e[b], 0 == c % 1) {\n        d = !0;\n        break;\n      }\n    }\n\n    return d;\n  },\n      A = -1,\n      B = function B(c) {\n    return z(h = (b - a) / (c + 1)) ? c : UNDEF;\n  };\n\n  for (; (!s || !t) && (++A, u = c + A, u >= x && (t = !0), m = B(u), !m) && (u = c - A, u <= w && (s = !0), m = B(u), !m);) {\n    ;\n  }\n\n  for (0 > a && 0 < b && e && (l = !0), i = 0; i < m; i++) {\n    l && 0 > v && 0 < v + h && (y.push(0), n = !0), v += h, y.push(v);\n  }\n\n  return m === UNDEF && e && (y = f.ticks(c), p = y.length, 1 < p ? (h = g(y[0] - y[1]), o = .2 * h, q = y[0], r = y[p - 1], g(a - q) <= o && 0 !== q && y.shift(), g(b - r) <= o && 0 !== r && y.pop(), (0 === q || 0 === r) && (n = !0)) : 0 === y[0] && (n = !0)), l && !n && -1 === y.indexOf(0) && (0 > a && 0 < y[0] ? y = [0].concat(y) : 0 < b && 0 > y[y.length - 1] ? y.push(0) : y = [0], n = !0), {\n    output: y,\n    interval: h,\n    isZeroTickForced: n\n  };\n},\n    domainUpdater = function domainUpdater(a, b, c, d) {\n  var _c$nice$getDomain, _c$nice$getDomain2, _c$getDomain, _c$getDomain2;\n\n  var e,\n      f,\n      g,\n      h,\n      i,\n      j,\n      k,\n      l,\n      m,\n      n,\n      o,\n      p,\n      q,\n      r,\n      s,\n      t,\n      u,\n      v,\n      w,\n      x,\n      y,\n      z,\n      A = Math.pow,\n      B = Math.LN10,\n      C = Math.log,\n      D = Math.max,\n      E = Math.abs,\n      F = Math.floor,\n      G = d.isPercent ? 0 : d.axisMinValue,\n      H = d.isPercent ? 100 : d.axisMaxValue,\n      I = !!d.adjustDiv,\n      J = d.numDivLines,\n      K = !!d.setAdaptiveMin,\n      L = d.axisRange,\n      M = 5.960464477539063e-8,\n      N = !0,\n      O = .2,\n      P = !0,\n      Q = d.xAxisLabelMode,\n      R = d.dependentInfo;\n  e = d.majorTMNumber === UNDEF ? J : D(0, J - 2), R && R.count && !R.limit && R.numDivLines !== UNDEF && (e = J = R.numDivLines, I = !1), f = e + 1, a === UNDEF && b === UNDEF && (a = 0, b = 1, N = !1), b === a && 0 === b && (b = 1, N = !1), ('categories' === Q || 'mixed' === Q) && (N = !1), N ? (h = F(C(E(b)) / B), g = F(C(E(a)) / B), i = D(g, h), j = A(10, i), 2 > E(b) / j && 2 > E(a) / j && (i--, j = A(10, i)), p = F(C(b - a) / B), q = A(10, p), 0 < b - a && 10 <= j / q && (j = q, i = p), l = (F(b / j) + 1) * j, 0 > a ? m = -1 * ((F(E(a / j)) + 1) * j) : K ? (m = F(E(a / j) - 1) * j, m = 0 > m ? 0 : m) : m = 0, !K && 0 >= b && (l = 0), n = !!(H || 0 === H), o = !!(G || 0 === G), !d.freezeLimit && (!1 === n || !0 === n && +H < b && b - +H > M ? (b = l, n = !1) : b = +H, !1 === o || !0 === o && +G > a && +G - a > M ? (a = m, o = !1) : a = +G)) : (n = !!(H || 0 === H), o = !!(G || 0 === G), !0 === n && +H >= b ? b = +H : n = !1, !0 === o && +G <= a ? a = +G : o = !1), u = [a, b], c.setDomain(u), I && !d.freezeLimit ? n || o ? (O = getErrorValue(e), x = noLimitChange(a, b, e, O, d.forceZeroTick, c), r = x.output, y = r.length, z = x.isZeroTickForced, E((e - y + (z ? 1 : 0)) / e) > O ? k = (b - a) / f : (k = 0 === y || 1 === y && z ? b - a : x.interval, d.isZeroTickForced = z, d.ticks = [a].concat(r, b), P = !1)) : (d.ticks = e ? c.nice(f).ticks(f) : c.getDomain(), k = E(d.ticks[1] - d.ticks[0]), P = !1) : n || o || d.freezeLimit ? k = (b - a) / f : ((_c$nice$getDomain = c.nice(f).getDomain(), _c$nice$getDomain2 = _slicedToArray(_c$nice$getDomain, 2), s = _c$nice$getDomain2[0], t = _c$nice$getDomain2[1], _c$nice$getDomain), j = (t - s) / f, k = niceInterval(j), t = s + k * f, (t - b) / b > O || (s - a) / a > O ? (c.setDomain([a, b]), k = (b - a) / f) : (a = s, b = t, c.setDomain([a, b]))), P && (0 > a && 0 < b && d.forceZeroTick ? (v = range(a, 0, k), w = v[v.length - 1] + k, 0 === w ? w += k : d.isZeroTickForced = !0, d.ticks = v.concat(0, range(w, b, k), b)) : d.ticks = range(a, b, k).concat(b)), (_c$getDomain = c.getDomain(), _c$getDomain2 = _slicedToArray(_c$getDomain, 2), a = _c$getDomain2[0], b = _c$getDomain2[1], _c$getDomain), d._allTicks = d.ticks.slice(), L.tickInterval = k, L.min = a, L.max = b;\n};\n\nexport default domainUpdater;","map":null,"metadata":{},"sourceType":"module"}