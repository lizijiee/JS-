{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { pluck, pluckNumber, preDefStr, extend2, TRACKER_FILL, polyPathToPath, convertColor, mapSymbolName } from '../../../../../../fc-core/src/lib';\nimport { ComponentInterface } from '../../../../../../fc-core/src/component-interface';\nimport { addDep } from '../../../../../../fc-core/src/dependency-manager';\nimport legendItemAnimation from './legend-item.animation';\n\nvar POINTER = preDefStr.POINTER,\n    NONE = 'none',\n    M = 'M',\n    L = 'L',\n    _getSymbolPath = function _getSymbolPath(a, b, c, d, e) {\n  var f,\n      g,\n      h,\n      i,\n      j,\n      k,\n      l,\n      m,\n      n,\n      o,\n      p,\n      q = [M];\n  return 'column' === e || 'dragColumn' === e || 'column3D' === e || 'realtimeColumn' === e || 'errorBar2D' === e ? (f = .25 * c, g = .5 * f, h = .7 * d, i = .4 * d, q = q.concat([a, b + d, 'l', 0, -h, f, 0, 0, h, 'z', 'm', f + g, 0, 'l', 0, -d, f, 0, 0, d, 'z', 'm', f + g, 0, 'l', 0, -i, f, 0, 0, i, 'z'])) : 'bar2D' === e || 'bar3D' === e ? (f = .3 * c, g = .6 * c, h = d / 4, i = h / 2, q = q.concat([a, b, L, a + g, b, a + g, b + h, a, b + h, 'Z', M, a, b + h + i, L, a + c, b + h + i, a + c, b + h + i + h, a, b + 2 * h + i, 'Z', M, a, b + 2 * (h + i), L, a + f, b + 2 * (h + i), a + f, b + d, a, b + d, 'Z'])) : 'area' === e || 'area3d' === e || 'areaspline' === e || 'dragArea' === e || 'realTimeArea' === e || 'splinearea' === e ? (f = .3 * c, g = .6 * c, h = .6 * d, i = .2 * d, j = .8 * d, q = q.concat([a, b + j, L, a, b + h, a + f, b + i, a + g, b + h, a + c, b + i, a + c, b + j, 'Z'])) : 'pie2D' === e || 'pie3d' === e || 'doughnut2D' === e || 'doughnut3D' === e ? (f = .5 * c, g = .9 * f, o = 1, p = 1, k = a + f + o, m = b + f - o, l = a + f - p, n = b + f + p, q = q.concat([k, m, L, k, m - g + o, 'A', g - o, g - o, 0, 0, 1, k + g - o, m, 'Z', M, l, n, L, l, n - g, 'A', g, g, 0, 1, 0, l + g, n, 'Z'])) : 'boxandwhisker2d' === e ? q = q.concat([a, b, L, a + c, b, a + c, b + d, a, b + d, 'Z']) : q = q.concat([a, b, L, a + c, b, a + c, b + d, a, b + d, 'Z']), {\n    path: q\n  };\n},\n    getAnchorProps = function getAnchorProps(a, b) {\n  var c = a.config,\n      d = a.getLinkedParent().config,\n      e = d.symbolWidth,\n      f = pluckNumber(d.padding, 4),\n      g = .5 * e,\n      h = (d.initialItemX || 0) + c._legendX + f,\n      i = (d.initialItemY || 0) + c._legendY - f,\n      j = h + d.symbolPadding + g,\n      k = i + (c._markerYGutter || 0) + d.symbolPadding + g,\n      l = mapSymbolName(c.anchorSide),\n      m = c.symbol = l && l.split('_') || [],\n      n = 'spoke' === m[0] ? 1 : 0;\n  return ('line' === c.type || c.drawLine) && (g *= .6), {\n    path: polyPathToPath([m[1] || 2, j, k, g, c.startAngle, c.spoke || n]),\n    cursor: b.cursor || POINTER,\n    stroke: b.stroke,\n    fill: b.fill,\n    \"stroke-width\": b['stroke-width'] || .5\n  };\n};\n\naddDep({\n  name: 'legendItemAnimation',\n  type: 'animationRule',\n  extension: legendItemAnimation\n});\n\nvar LegendItem =\n/*#__PURE__*/\nfunction (_ComponentInterface) {\n  _inherits(LegendItem, _ComponentInterface);\n\n  function LegendItem() {\n    var _this;\n\n    _classCallCheck(this, LegendItem);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LegendItem).call(this)), _this._stateCosmetics = {}, _this._legendState = [];\n    return _this;\n  }\n\n  _createClass(LegendItem, [{\n    key: \"getName\",\n    value: function getName() {\n      return 'legendItem';\n    }\n  }, {\n    key: \"parseLegendCosmetics\",\n    value: function parseLegendCosmetics() {\n      var a,\n          b,\n          c,\n          d = this,\n          e = this.getLinkedParent(),\n          f = e.getLegendState(),\n          g = d.getLegendState(),\n          h = ['default'],\n          j = {};\n\n      for (h = h.concat(f, g), c = 0; c < h.length; c++) {\n        a = e.getStateCosmetics(h[c]), b = d.getStateCosmetics(h[c]), a && ('function' == typeof a ? j = a(j, d) : extend2(j, a)), b && ('function' == typeof b ? j = b(j, d) : extend2(j, b));\n      }\n\n      return j;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'legendItem';\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(a) {\n      var b,\n          c,\n          d = this,\n          e = d.config;\n\n      for (b in a) {\n        if (a.hasOwnProperty(b)) if ('object' != typeof a[b]) e[b] = a[b];else {\n          var _d = e[b] ? e[b] : {};\n\n          for (c in a[b]) {\n            _d[c] = a[b][c];\n          }\n\n          e[b] = _d;\n        }\n      }\n    }\n  }, {\n    key: \"itemClickFn\",\n    value: function itemClickFn() {\n      var a = this,\n          b = a.getFromEnv('chart-attrib'),\n          c = pluckNumber(b.interactivelegend, 1),\n          d = a.getLinkedItem('owner');\n      c && d.legendInteractivity(a);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.removeEventListener('fc-click', this.click), this.removeEventListener('fc-mouseover', this.mouseover), this._dispose();\n    }\n  }, {\n    key: \"getLegendState\",\n    value: function getLegendState() {\n      return this._legendState;\n    }\n  }, {\n    key: \"hasState\",\n    value: function hasState(a) {\n      var b,\n          c,\n          d = this.getLegendState();\n\n      for (b = 0, c = d.length; b < c; b++) {\n        if (d[b] === a) return !0;\n      }\n\n      return !1;\n    }\n  }, {\n    key: \"setLegendState\",\n    value: function setLegendState(a, b) {\n      this.hasState(a) || (b ? this._legendState.push(a) : this._legendState.unshift(a)), this.asyncDraw();\n    }\n  }, {\n    key: \"removeLegendState\",\n    value: function removeLegendState(a) {\n      var b,\n          c,\n          d = 1;\n      if (a) for (b = 0, c = this._legendState.length; b < c && d; b++) {\n        a === this._legendState[b] && (this._legendState.splice(b, 1), d = 0);\n      } else this._legendState.length = 0;\n      this.asyncDraw();\n    }\n  }, {\n    key: \"removeStateCosmetics\",\n    value: function removeStateCosmetics(a) {\n      delete this._stateCosmetics[a];\n    }\n  }, {\n    key: \"setStateCosmetics\",\n    value: function setStateCosmetics(a, b) {\n      this._stateCosmetics[a] = b;\n    }\n  }, {\n    key: \"getStateCosmetics\",\n    value: function getStateCosmetics(a) {\n      return this._stateCosmetics[a];\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q,\n          r,\n          s,\n          t,\n          u,\n          v,\n          w,\n          x,\n          y,\n          z,\n          A,\n          B,\n          C,\n          D,\n          E,\n          F,\n          G,\n          H,\n          I,\n          J,\n          K,\n          N,\n          O,\n          P,\n          Q,\n          R = this.getLinkedParent(),\n          S = R.getFromEnv('chart'),\n          T = S.config,\n          U = this,\n          V = U.getFromEnv('animationManager'),\n          W = U.config,\n          X = R.config,\n          Y = X.legendHeight,\n          Z = X.symbolPadding,\n          $ = X.symbolWidth,\n          _ = X.interactiveLegend,\n          aa = X.textPadding || 2,\n          ba = pluckNumber(X.padding, 4),\n          ca = X.itemHoverStyle,\n          da = R.getChildContainer('itemGroup'),\n          ea = X.drawCustomLegendIcon,\n          fa = U.hasState('hidden'),\n          ga = {};\n      a = U.parseLegendCosmetics(), c = a.symbol, d = X.initialItemX || 0, e = X.initialItemY || 0, i = W.type, t = a.symbol.stroke || '000000', u = a.symbol.fill, b = a.symbol.lineWidth || X.lineWidth, w = W.anchorSide, x = W.drawLine, j = d + W._legendX + ba, k = e + W._legendY - ba, G = U.getGraphicalElement('legendItemBackground'), h = U.getGraphicalElement('legendItemText'), l = U.getGraphicalElement('legendItemLine'), o = U.getGraphicalElement('legendItemSymbol'), _ = pluck(W.interactiveLegend, _), _ || (a.cursor = 'default'), H = a.text, P = j + Y + aa - 2, Q = k + (W._legendTestY || 0), H.text = W.name, H.x = P, H.y = Q, g = V.setAnimation({\n        el: h || 'text',\n        attr: H,\n        component: U,\n        container: da,\n        label: 'icon'\n      }), h || (g = U.addGraphicalElement('legendItemText', g)), g.data('legendItem', W), I = !1, ea && !1 !== W.customLegendIcon ? (B = !fa && c.borderColor, C = pluck(c.borderAlpha), z = !fa && c.bgColor, A = pluck(c.bgAlpha, '100'), D = a.symbol.rawFillColor, u = fa ? a.symbol.fill : z || D, u = convertColor(u, A), E = a.symbol.rawStrokeColor, t = fa ? a.symbol.stroke : B || E || D, t = convertColor(t, C), q = .5 * $, p = j + Z + q, f = k + (W._markerYGutter || 0) + Z + q, y = mapSymbolName(c.sides), s = y && mapSymbolName(c.sides).split('_') || [], r = 'spoke' === s[0] ? 1 : 0, J = {\n        path: polyPathToPath([s[1] || 2, p, f, q, c.startAngle || 0, r]),\n        cursor: a.symbol.cursor || POINTER,\n        stroke: t,\n        fill: u,\n        \"stroke-width\": pluckNumber(c.borderThickness, 1)\n      }) : 'line' === i || x ? (f = k + (W._markerYGutter || 0) + Z + .5 * $, O = {\n        path: [M, j + Z, f, L, j + Z + $, f]\n      }, I = !0, ga = {\n        opacity: T.legendiconalpha || 1,\n        \"stroke-width\": b,\n        stroke: t,\n        cursor: a.cursor || POINTER\n      }, w && (J = getAnchorProps(U, a.symbol))) : w ? J = getAnchorProps(U, a.symbol) : 'line' !== i && (t = W.symbolStroke || t, m = _getSymbolPath(j + Z, k + (W._markerYGutter || 0) + Z, $, $, i), J = {\n        path: m.path,\n        \"stroke-width\": .5,\n        stroke: t,\n        fill: u,\n        cursor: a.cursor || POINTER\n      }), O && I ? (Object.assign(O, ga), l = V.setAnimation({\n        el: l || 'path',\n        attr: O,\n        component: U,\n        callback: function callback() {\n          this.show();\n        },\n        container: da\n      }), !U.getGraphicalElement('legendItemLine') && (l = U.addGraphicalElement('legendItemLine', l))) : l && l.hide(), J ? (J.opacity = pluckNumber(a.symbol.opacity, 1), n = V.setAnimation({\n        el: o || 'path',\n        attr: J,\n        component: U,\n        callback: function callback() {\n          this.show();\n        },\n        container: da,\n        label: 'icon'\n      }), (!o || !o.node) && (n = U.addGraphicalElement('legendItemSymbol', n)), n.data('legendItem', W)) : o && o.hide(), v = a.background && a.background.legendBackgroundColor ? convertColor(a.background.legendBackgroundColor, a.background.alpha) : TRACKER_FILL, K = {\n        x: j,\n        y: k,\n        width: W._totalWidth,\n        height: W._legendH,\n        r: 0,\n        fill: v,\n        opacity: 1,\n        \"stroke-width\": 1,\n        stroke: NONE,\n        cursor: a.symbol.cursor || POINTER\n      }, F = V.setAnimation({\n        el: G || 'rect',\n        attr: K,\n        css: N,\n        component: U,\n        label: 'background',\n        container: da\n      }), G || U.addGraphicalElement('legendItemBackground', F), F.data('legendItem', U).data('interactive', _).data('itemHoverStyle', ca).data('itemStyle', a);\n    }\n  }]);\n\n  return LegendItem;\n}(ComponentInterface);\n\nexport default LegendItem;","map":null,"metadata":{},"sourceType":"module"}