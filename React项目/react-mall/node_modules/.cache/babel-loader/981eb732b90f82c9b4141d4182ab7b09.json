{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { ComponentInterface } from '../component-interface';\nimport interpolateNumber from '../axis/utils/interpolators/number';\nimport diff from '../axis/utils/array/diff';\nimport { getCrispPath } from '../axis/cartesian';\nimport cartesianAxisRefAnimation from './cartesian-axis-ref.animation';\nimport { addDep } from '../dependency-manager';\n\nvar isValid = function isValid(a) {\n  return 'undefined' === !typeof a || null !== a;\n};\n\nvar UNDEF;\naddDep({\n  name: 'cartesianAxisRefAnimation',\n  type: 'animationRule',\n  extension: cartesianAxisRefAnimation\n});\n\nvar AxisRefVisual =\n/*#__PURE__*/\nfunction (_ComponentInterface) {\n  _inherits(AxisRefVisual, _ComponentInterface);\n\n  function AxisRefVisual() {\n    var _this;\n\n    _classCallCheck(this, AxisRefVisual);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AxisRefVisual).call(this)), _this.config.map = {}, _this.config.explicitDrawItems = {};\n    return _this;\n  }\n\n  _createClass(AxisRefVisual, [{\n    key: \"getType\",\n    value: function getType() {\n      return 'axisRefVisuals';\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'axisRefVisualsCartesian';\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h = this.getDrawingInfo(),\n          j = this.getexplicitDrawItems(),\n          k = this.config,\n          l = k.map,\n          m = {},\n          n = this.getLinkedParent(),\n          o = n.getAxes(),\n          p = [],\n          q = n.getChildContainer('axisReferenceVisualsFloor'),\n          r = n.getChildContainer('axisReferenceVisualsBottom'),\n          s = n.getChildContainer('axisReferenceVisualsMiddle'),\n          t = n.getChildContainer('axisReferenceVisualsTop'),\n          u = n.getChildContainer('axisReferenceVisualsCeil');\n\n      for (n.config.trendlines = [], n.config.vtrendlines = [], b = 0; b < o.length; ++b) {\n        p.push(o[b].axis.getId());\n      }\n\n      for (d in k.containers = [q, r, s, t, u], h) {\n        if (h.hasOwnProperty(d) && (e = this.getLinkedItem(d), 0 <= p.indexOf(e.getId()))) for (f = m[d], f || (f = m[d] = []), a = h[d], b = 0; b < a.length; ++b) {\n          g = a[b], c = g.type, 'band' === c ? f.push.apply(f, this.createBand(g, e)) : 'line' === c && f.push.apply(f, this.createLine(g, e));\n        }\n      }\n\n      if (k.isSmartDrawing) for (d in l) {\n        l.hasOwnProperty(d) && !j[d] && this.getLinkedItem(d) && (m[d] = l[d]);\n      }\n      this.resetexplicitDrawItems(), this.removeExtraElements(m);\n    }\n  }, {\n    key: \"getDrawingInfo\",\n    value: function getDrawingInfo() {\n      var a,\n          b,\n          c = {},\n          d = this.getexplicitDrawItems(),\n          e = this.isCanvasChnaged(),\n          f = this.config.isSmartDrawing = Object.keys(d).length && !e,\n          g = f ? d : this.getLinkedItem();\n\n      for (a in g) {\n        g.hasOwnProperty(a) && (b = g[a], c[a] = b.getReferenceInfo());\n      }\n\n      return c;\n    }\n  }, {\n    key: \"createLine\",\n    value: function createLine(a, b) {\n      var c,\n          d,\n          e,\n          f = this.config.containers,\n          g = f[a.layer],\n          h = b.config,\n          i = this.getFromEnv('paper'),\n          j = this.getFromEnv('chart').getName(),\n          k = this.getLinkedParent(),\n          l = this.getFromEnv('animationManager'),\n          m = this.getFromEnv('toolTipController'),\n          n = k.config,\n          o = n.trendlines,\n          p = h.isVertical,\n          q = n.canvasLeft,\n          r = n.canvasTop,\n          s = r + n.canvasHeight,\n          t = q + n.canvasWidth,\n          u = interpolateNumber(q, t),\n          v = interpolateNumber(r, s),\n          w = b.getScale(),\n          x = w.getRangeValue(a.from),\n          y = a.to !== UNDEF && w.getRangeValue(a.to) || x,\n          z = p ? ['M', q, x, 'L', t, y] : ['M', x, s, 'L', y, r],\n          A = a.attr,\n          B = a.text,\n          C = B && B.attr,\n          D = B && B.labelPosition || 0,\n          E = b.getId(),\n          F = a.id || a.from,\n          G = E + '_' + F,\n          H = this.getGraphicalElement(G),\n          I = a.handlers,\n          J = {\n        start: a.from,\n        end: a.to\n      };\n\n      for (e in A.path = getCrispPath(z, isValid(A['stroke-width']) ? A['stroke-width'] : 1).path.toString(), /trend/.test(a.id) && o.push({\n        x1: z[1],\n        y1: z[2],\n        x2: z[4],\n        y2: z[5],\n        tooltext: a.toolText,\n        tolerance: 5 > A['stroke-width'] ? 2.5 : A['stroke-width'] / 2\n      }), A['stroke-linecap'] = 'butt', H = this.addGraphicalElement(G, l.setAnimation({\n        container: g,\n        el: H || 'path',\n        attr: A,\n        component: this,\n        axis: b,\n        data: {\n          value: J,\n          path: z\n        },\n        label: 'path'\n      })), H.data('data', J), B && (c = E + '_' + F + C.text, d = this.getGraphicalElement(c), p ? (C.x = u(D), C.y = x) : (C.x = x, C.y = v(D)), C.text = B.label, C.transform = i.getSuggestiveRotation(B.labelRotation, C.x, C.y), d = this.addGraphicalElement(c, l.setAnimation({\n        container: f[B.layer],\n        el: d || 'text',\n        attr: C,\n        component: this,\n        axis: b,\n        data: {\n          value: a.from\n        },\n        label: 'text',\n        css: B.css\n      })), d.data('data', a.from)), /zoomscatter/i.test(j) || (a.toolText ? m.enableToolTip(H, a.toolText) : m.disableToolTip(H)), I) {\n        I.hasOwnProperty(e) && (H.on(e, I[e].bind(b)), d && d.on(e, I[e].bind(b)));\n      }\n\n      return B ? [G, c] : [G];\n    }\n  }, {\n    key: \"createBand\",\n    value: function createBand(a, b) {\n      var c = Math.min;\n      var d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = this.config.containers[a.layer],\n          l = b.config,\n          m = this.getFromEnv('animationManager'),\n          n = this.getFromEnv('toolTipController'),\n          o = this.getLinkedParent(),\n          p = this.getFromEnv('chart').getName(),\n          q = o.config,\n          r = l.isVertical,\n          s = q.canvasLeft,\n          t = q.canvasTop,\n          u = t + q.canvasHeight,\n          v = s + q.canvasWidth,\n          w = b.getScale(),\n          x = a.from,\n          y = a.to === UNDEF ? x : a.to,\n          z = b.getId(),\n          A = a.attr,\n          B = a.handlers;\n\n      for (i in d = 'canvasStart' === x ? r ? t : s : w.getRangeValue(x), e = 'canvasEnd' === y ? r ? u : v : w.getRangeValue(y), j = Math.abs(d - e), r ? (A.x = s, A.y = c(d, e), A.width = v - s, A.height = j) : (A.x = c(d, e), A.y = t, A.width = j, A.height = u - t), f = a.id || A.x + '_' + A.y, g = z + '_' + f, h = this.getGraphicalElement(g), /trend/.test(a.id) && o.config.vtrendlines.push({\n        x1: A.x,\n        y1: A.y,\n        x2: A.x + A.width,\n        y2: A.y + A.height,\n        tooltext: a.toolText,\n        tolerance: 5 > A['stroke-width'] ? 2.5 : A['stroke-width'] / 2,\n        isTrendZone: 1\n      }), h = this.addGraphicalElement(g, m.setAnimation({\n        container: k,\n        el: h || 'rect',\n        attr: A,\n        component: this,\n        label: 'rect'\n      })), /zoomscatter/i.test(p) || (a.toolText ? n.enableToolTip(h, a.toolText) : n.disableToolTip(h)), B) {\n        B.hasOwnProperty(i) && h.on(i, B[i].bind(b));\n      }\n\n      return [g];\n    }\n  }, {\n    key: \"removeExtraElements\",\n    value: function removeExtraElements(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h = this.config.map;\n\n      for (b in h) {\n        if (!a[b]) for (c = h[b], e = c.length, d = 0; d < e; ++d) {\n          f = this.getGraphicalElement(c[d]), f && this.removeGraphicalElement(f);\n        } else for (g = diff(h[b], a[b]), e = g.length, d = 0; d < e; ++d) {\n          f = this.getGraphicalElement(g[d]), f && this.removeGraphicalElement(f);\n        }\n      }\n\n      this.config.map = a;\n    }\n  }, {\n    key: \"setLinkedItem\",\n    value: function setLinkedItem(a, b) {\n      _get(_getPrototypeOf(AxisRefVisual.prototype), \"setLinkedItem\", this).call(this, a, b);\n\n      var c = this;\n      'axis' === b.getType() && c.addExtEventListener('preremove', function (a) {\n        c.removeLinkedItem(a.sender.getId()), c.asyncDraw();\n      }, b);\n    }\n  }, {\n    key: \"addexplicitDrawItems\",\n    value: function addexplicitDrawItems(a, b) {\n      this.config.explicitDrawItems[a] = b;\n    }\n  }, {\n    key: \"getexplicitDrawItems\",\n    value: function getexplicitDrawItems() {\n      return this.config.explicitDrawItems;\n    }\n  }, {\n    key: \"resetexplicitDrawItems\",\n    value: function resetexplicitDrawItems() {\n      this.config.explicitDrawItems = {};\n    }\n  }, {\n    key: \"isCanvasChnaged\",\n    value: function isCanvasChnaged() {\n      var a,\n          b = this.getLinkedParent().getEffectiveDimensions(),\n          c = this.config;\n      return a = JSON.stringify(b) !== JSON.stringify(c.canvasDim), c.canvasDim = b, a;\n    }\n  }]);\n\n  return AxisRefVisual;\n}(ComponentInterface);\n\nexport default AxisRefVisual;","map":null,"metadata":{},"sourceType":"module"}