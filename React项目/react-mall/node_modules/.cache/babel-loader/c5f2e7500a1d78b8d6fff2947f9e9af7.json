{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { ComponentInterface } from '../component-interface';\nimport { toRaphaelColor, RGBtoHex, HEXtoRGB } from '../lib';\n\nvar UNDEF,\n    COMMA_STR = ',',\n    getColorBetween = function getColorBetween(a, b, c) {\n  var d,\n      e,\n      f = Math.round,\n      g = a.value,\n      h = a.code,\n      i = HEXtoRGB(h),\n      j = b.value,\n      k = b.code,\n      l = HEXtoRGB(k);\n  return d = j - g, e = [f(i[0] + (l[0] - i[0]) / d * (c - g)), f(i[1] + (l[1] - i[1]) / d * (c - g)), f(i[2] + (l[2] - i[2]) / d * (c - g))], RGBtoHex(e);\n};\n\nvar GradientColorRange =\n/*#__PURE__*/\nfunction (_ComponentInterface) {\n  _inherits(GradientColorRange, _ComponentInterface);\n\n  function GradientColorRange() {\n    var _this;\n\n    _classCallCheck(this, GradientColorRange);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GradientColorRange).call(this)), _this.colorRange = {}, _this.valueRatio = {}, _this.data = {}, _this.mapByPercent = void 0;\n    return _this;\n  }\n\n  _createClass(GradientColorRange, [{\n    key: \"getType\",\n    value: function getType() {\n      return 'colorComponent';\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'gradientColorRange';\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(a) {\n      if (!a) return;\n      var b,\n          c,\n          d,\n          e = this;\n\n      for (e.data = a, e.appender = '', d = e.colorRange = a.colorRange.sort(function (a, b) {\n        return a.value - b.value;\n      }), e.valueRatio = UNDEF, e.values = [], (b = 0, c = d.length); b < c; b++) {\n        e.values.push(d[b].value);\n      }\n    }\n  }, {\n    key: \"getValueRatio\",\n    value: function getValueRatio() {\n      var a,\n          b,\n          c,\n          d = this.colorRange,\n          e = d.length,\n          f = this.valueRatio,\n          g = d[e - 1].value,\n          h = d[0].value,\n          i = 0;\n      if (f) return f;\n\n      for (f = this.valueRatio = [], b = 0; b < e; b++) {\n        a = d[b], c = (a.value - h) / (g - h), f.push(100 * (c - i)), i = c;\n      }\n\n      return f;\n    }\n  }, {\n    key: \"getCumulativeValueRatio\",\n    value: function getCumulativeValueRatio() {\n      var a,\n          b,\n          c = this.colorRange,\n          d = c.length,\n          e = c[0].value,\n          f = c[d - 1].value,\n          g = [];\n\n      for (b = 0; b < d; b++) {\n        a = c[b], g.push(100 * ((a.value - e) / (f - e)));\n      }\n\n      return g;\n    }\n  }, {\n    key: \"getBoxFill\",\n    value: function getBoxFill(a) {\n      var b,\n          c,\n          d,\n          e,\n          f = this.colorRange,\n          g = f.length,\n          h = [];\n\n      for (e = a ? 90 : 0, c = 0; c < g; c++) {\n        b = f[c], h.push(b.code);\n      }\n\n      return d = {\n        FCcolor: {\n          alpha: '100,100,100',\n          angle: e,\n          color: h.join(COMMA_STR),\n          ratio: this.getValueRatio().join(COMMA_STR)\n        }\n      }, toRaphaelColor(d);\n    }\n  }, {\n    key: \"getColorByValue\",\n    value: function getColorByValue(a) {\n      var b,\n          c,\n          d,\n          e,\n          f = this.values,\n          g = this.colorRange;\n\n      if (a !== UNDEF && null !== a) {\n        for (c = 0, b = f.length; c < b; c++) {\n          if (a === f[c]) {\n            e = g[c].code;\n            break;\n          } else if (!c && a < f[c]) {\n            d = !0;\n            break;\n          } else if (c === b - 1 && a > f[c]) {\n            d = !0;\n            break;\n          } else if (a > f[c] && a < f[c + 1]) {\n            e = getColorBetween(g[c], g[c + 1], a);\n            break;\n          }\n        }\n\n        return d ? void 0 : e;\n      }\n    }\n  }]);\n\n  return GradientColorRange;\n}(ComponentInterface);\n\nexport default GradientColorRange;","map":null,"metadata":{},"sourceType":"module"}