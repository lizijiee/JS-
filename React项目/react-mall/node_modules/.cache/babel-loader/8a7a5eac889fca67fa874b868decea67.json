{"ast":null,"code":"import _slicedToArray from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport CartesianLabelManager from './cartesian-label-manager';\nimport { BLANKSTRING, extend2, parseUnsafeString, extent } from '../lib';\nimport range from './utils/array/range';\nimport LinearScale from './scales/linear';\nimport { setDataLimit, extractStyleInfo } from './common-api';\nimport domainUpdater from './domain-updater';\nvar UNDEF;\n\nvar NumericAxis =\n/*#__PURE__*/\nfunction (_CartesianLabelManage) {\n  _inherits(NumericAxis, _CartesianLabelManage);\n\n  function NumericAxis() {\n    var _this;\n\n    _classCallCheck(this, NumericAxis);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NumericAxis).call(this)), _this.config.scale = new LinearScale();\n    return _this;\n  }\n\n  _createClass(NumericAxis, [{\n    key: \"getName\",\n    value: function getName() {\n      return 'numeric';\n    }\n  }, {\n    key: \"generateTicks\",\n    value: function generateTicks() {\n      var a = Math.abs;\n\n      var b,\n          c,\n          d,\n          e = this.getScale(),\n          f = this.config,\n          g = f.numDivLines + 1,\n          _e$getDomain = e.getDomain(),\n          _e$getDomain2 = _slicedToArray(_e$getDomain, 2),\n          h = _e$getDomain2[0],\n          i = _e$getDomain2[1],\n          j = f.axisRange,\n          k = j.min,\n          l = j.max,\n          m = f.dataLimit;\n\n      return h === k && i === l ? (domainUpdater(m.min, m.max, e, f), f.ticks) : (b = e.ticks(g), c = a(b[1] - b[0]), h === k && -1 === b.indexOf(k) && b.unshift(k), i === l && -1 === b.indexOf(l) && b.push(l), (d = a(k % c)) && (k -= d), (d = a(l % c)) && (l -= d), f._allTicks = range(k, l, c).concat(l), j.tickInterval = c, b);\n    }\n  }, {\n    key: \"setTickValues\",\n    value: function setTickValues(a) {\n      this.config.userTicks = a || [], this.config.tickValues = {\n        tickValue: []\n      };\n    }\n  }, {\n    key: \"_parseTickValues\",\n    value: function _parseTickValues(a) {\n      var b,\n          c,\n          d,\n          e,\n          f = this,\n          g = f.getFromEnv('chart'),\n          h = f.config,\n          i = a && a.length,\n          j = 0;\n\n      for (h.tickValues = {}, b = h.tickValues.tickValue = [], d = 0; d < i; d += 1) {\n        if (c = extend2({}, a[d]), e = +c.x, !c.vline) {\n          if (extractStyleInfo(c, g), e || 0 === e) c.x = e, h.irregularCatAxis = !0;else continue;\n          b.push(c), b[j].label = parseUnsafeString(b[j].label), j += 1;\n        }\n      }\n\n      h.oriCatLen = j;\n    }\n  }, {\n    key: \"calculateTicksOnLabelMode\",\n    value: function calculateTicksOnLabelMode() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h = this,\n          k = h.config,\n          l = k.xAxisLabelMode,\n          m = Object.assign([], k.userTicks),\n          n = h.getFromEnv('number-formatter');\n\n      if ('mixed' === l || 'auto' === l) {\n        if (b = [], a = n.xAxis, 'mixed' === l) for (c = 0, e = m.length; c < e; c += 1) {\n          b[m[c].x || m[c].y || c] = !0;\n        } else m = [];\n\n        for (g = h.getAxisConfig(), f = k.ticks, d = 0; d < f.length; ++d) {\n          c = f[d], b[c] || m.push({\n            label: BLANKSTRING + a.call(n, c),\n            x: c,\n            showverticalline: 0 === c ? g.showZeroPlane : 1,\n            isNumeric: !0,\n            linecolor: 0 === c ? g.zeroPlaneColor : g.divLineColor,\n            linealpha: 0 === c ? g.zeroPlaneAlpha : g.divLineAlpha,\n            linethickness: 0 === c ? g.zeroPlaneThickness : g.divLineThickness,\n            linedashed: g.divLineIsDashed,\n            linedashLen: g.divLineDashLen,\n            linedashgap: g.divLineDashGap\n          });\n        }\n      }\n\n      h._parseTickValues(m);\n    }\n  }, {\n    key: \"getInterval\",\n    value: function getInterval() {\n      return this.config.axisRange.tickInterval;\n    }\n  }, {\n    key: \"_setAxisRange\",\n    value: function _setAxisRange(a) {\n      var b,\n          c,\n          d,\n          e = a.min,\n          f = a.max,\n          g = this.config,\n          h = g.axisRange,\n          i = g.dataLimit,\n          j = g.dependentInfo;\n      if (!(e > f)) if ((i.min !== e || i.max !== f) && (c = !0), g.visibleMin !== UNDEF && !g.setPadding && !c) g.setPadding = !1;else {\n        var _extent, _extent2;\n\n        if ((_extent = extent([e, f, i.min, i.max]), _extent2 = _slicedToArray(_extent, 2), e = _extent2[0], f = _extent2[1], _extent), i.min = e, i.max = f, this.fireEvent('dataLimitSet', Object.assign({}, i)), j) {\n          var _extent3, _extent4;\n\n          if (j.limit) if (b = j.dataLimit, b) (_extent3 = extent([e, f, b.min, b.max]), _extent4 = _slicedToArray(_extent3, 2), e = _extent4[0], f = _extent4[1], _extent3), g.isDataLimitSet = !0;else return;\n          if (j.count && j.numDivLines === UNDEF) return;\n        }\n\n        domainUpdater(e, f, this.getScale(), g), d = g.isZeroTickForced ? 3 : 2, this.fireEvent('divlinesSet', g.ticks.length - d), g.tickValues && this.calculateTicksOnLabelMode(), this.setVisibleConfig(h.min, h.max);\n      }\n    }\n  }]);\n\n  return NumericAxis;\n}(CartesianLabelManager);\n\nNumericAxis.prototype.setDataLimit = setDataLimit;\nexport default NumericAxis;","map":null,"metadata":{},"sourceType":"module"}