{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _assertThisInitialized from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { pluck, pluckNumber, parseUnsafeString, POSITION_START, POSITION_END, POSITION_TOP, POSITION_BOTTOM, POSITION_MIDDLE, POSITION_RIGHT, preDefStr, BLANKSTRING, setLineHeight, getFirstValue, pluckFontSize, chartPaletteStr, TESTSTR, crispBound, extend2, convertColor, getFirstColor } from '../../../../../../fc-core/src/lib';\nimport { ComponentInterface } from '../../../../../../fc-core/src/component-interface';\nimport LegendItem from './legend-item';\nimport { addDep } from '../../../../../../fc-core/src/dependency-manager';\nimport { Scroller } from '../../../../../../fc-core/src/toolbox';\nimport legendAnimation from './index.animation';\nimport { priorityList } from '../../../../../../fc-core/src/schedular';\n\nvar UNDEF,\n    TEXT_ANCHOR_MAP = {\n  left: POSITION_START,\n  right: POSITION_END,\n  center: POSITION_MIDDLE\n},\n    math = Math,\n    mathMin = math.min,\n    mathMax = math.max,\n    mathFloor = math.floor,\n    mathCeil = math.ceil,\n    COMMA = ',',\n    NONE = 'none',\n    NORMAL = preDefStr.NORMAL,\n    BOLD = preDefStr.BOLD,\n    noneStr = preDefStr.noneStr,\n    styleValueMap = {\n  fontWeight: {\n    1: BOLD,\n    0: NORMAL\n  },\n  fontStyle: {\n    1: 'italic',\n    0: NORMAL\n  },\n  textDecoration: {\n    1: 'underline',\n    0: noneStr\n  }\n},\n    handlers = function handlers(a) {\n  var b, c;\n  return {\n    dragstart: function dragstart() {\n      b = a.config.xL || a.config.xPos, c = a.config.yL || a.config.yPos;\n    },\n    dragmove: function dragmove(d) {\n      var e,\n          f,\n          g = d.originalEvent.data[0],\n          h = d.originalEvent.data[1],\n          i = a.config,\n          j = a.getFromEnv('chartConfig'),\n          k = (i.borderWidth || 0) + 2;\n      e = mathMin(mathMax(b + g, k), j.width - i.width - k), f = mathMin(mathMax(c + h, k), j.height - i.height - k), i.xPos = i.xL = e, i.yPos = i.yL = f, a.addJob('draw', a.dragDraw, priorityList && priorityList.draw);\n    }\n  };\n};\n\naddDep({\n  name: 'legendAnimation',\n  type: 'animationRule',\n  extension: legendAnimation\n});\n\nvar Legend =\n/*#__PURE__*/\nfunction (_ComponentInterface) {\n  _inherits(Legend, _ComponentInterface);\n\n  function Legend() {\n    var _this;\n\n    _classCallCheck(this, Legend);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Legend).call(this));\n\n    var a = _assertThisInitialized(_this);\n\n    a._stateCosmetics = {}, a._legendState = [], a.dragDraw = function () {\n      a.draw();\n    }, a.drawScroll = function () {\n      a.createItemGroup();\n    }, a.config.handlers = handlers(a);\n    return _this;\n  }\n\n  _createClass(Legend, [{\n    key: \"createItem\",\n    value: function createItem(a) {\n      var b,\n          c = this;\n      return b = new LegendItem(), c.attachChild(b, 'legendItem'), b.setLinkedItem('owner', a), b.addEventListener('mouseover', function () {\n        b.setLegendState('hover', !0);\n      }), b.addEventListener('mouseout', function () {\n        b.removeLegendState('hover');\n      }), b.getId();\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(a) {\n      var b = this,\n          c = b.getChildren().legendItem;\n      if (!(a !== UNDEF)) return !1;else if (c) for (var _b = 0; _b < c.length; _b++) {\n        if (c[_b].getId() === a) return c[_b];\n      }\n    }\n  }, {\n    key: \"getSortedLegendItems\",\n    value: function getSortedLegendItems() {\n      var a,\n          b,\n          c = this,\n          d = c.getChildren('legendItem') || [],\n          e = c.config.reverselegend,\n          f = {},\n          g = [];\n\n      for (a = 0, b = d.length; a < b; a++) {\n        d[a].config.index === UNDEF ? f[b + a] = d[a] : f[d[a].config.index] = d[a];\n      }\n\n      return Object.keys(f).sort(function (a, b) {\n        return e ? b - a : a - b;\n      }).forEach(function (a) {\n        g.push(f[a]);\n      }), g;\n    }\n  }, {\n    key: \"disposeItem\",\n    value: function disposeItem(a) {\n      var b = this,\n          c = b.getItem(a);\n      c && c.remove();\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'legend';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'legend';\n    }\n  }, {\n    key: \"__setDefaultConfig\",\n    value: function __setDefaultConfig() {\n      _get(_getPrototypeOf(Legend.prototype), \"__setDefaultConfig\", this).call(this);\n\n      var a = this.config;\n      a.enabled = !0, a.symbolWidth = 12, a.borderRadius = 1, a.lastScrollPos = 0, a.oriSymbolPadding = 3, a.textPadding = 4, a.scrollY = 0, a.backgroundColor = '#FFFFFF', a.initialItemX = 0, a.title = {\n        text: BLANKSTRING,\n        x: 0,\n        y: 0,\n        padding: 2\n      }, a.scroll = {}, a.itemStyle = {};\n    }\n  }, {\n    key: \"createLegendGroup\",\n    value: function createLegendGroup() {\n      var a,\n          b = this,\n          c = b.config,\n          d = b.getFromEnv('chart'),\n          e = d.config,\n          f = b.getFromEnv('animationManager'),\n          g = .5 * (c.borderWidth || 0) + 2,\n          h = b.getContainer('legendGroup');\n      c.xL && (c.xL = mathMin(mathMax(c.xL, g), e.width - c.width - g)), c.yL && (c.yL = mathMin(mathMax(c.yL, g), e.height - c.height - g)), a = f.setAnimation({\n        el: h || 'group',\n        attr: {\n          name: 'legendGroup',\n          transform: ['T', c.xL || c.xPos, c.yL || c.yPos]\n        },\n        container: d.getChildContainer('legendGroup'),\n        component: b\n      }), h || b.addContainer('legendGroup', a);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      this.createLegendGroup(), this.drawLegendBox(), this.createItemGroup(), this.drawCaption(), this.createScrollGroup(), this.decideScroll();\n    }\n  }, {\n    key: \"decideScroll\",\n    value: function decideScroll() {\n      var a = this,\n          b = a.config,\n          c = b.scroll.enabled;\n      c ? this.createScrollBar() : b.hasScroll && (a.getChildren('legendScrollBar')[0].remove(), b.hasScroll = !1);\n    }\n  }, {\n    key: \"createItemGroup\",\n    value: function createItemGroup() {\n      var a,\n          b = this,\n          c = b.getFromEnv('animationManager'),\n          d = b.getContainer('legendGroup'),\n          e = b.getChildContainer('itemGroup'),\n          f = pluckNumber(b.config.padding, 4),\n          g = Math.max(b.config.height - f, 0),\n          h = COMMA + b.config.width + COMMA + g;\n      return a = c.setAnimation({\n        el: e || 'group',\n        attr: {\n          name: 'item',\n          transform: ['T', 0, b.config.scrollY || 0]\n        },\n        container: d,\n        component: b\n      }), e || b.addChildContainer('itemGroup', a), b.config.scroll.enabled ? a.attr({\n        \"clip-rect\": '0,' + .5 * f + h\n      }) : a.attr({\n        \"clip-rect\": null\n      }), a;\n    }\n  }, {\n    key: \"createScrollGroup\",\n    value: function createScrollGroup() {\n      var a = this,\n          b = a.getFromEnv('animationManager'),\n          c = a.getChildContainer('scrollGroup'),\n          d = a.getContainer('legendGroup');\n      a.config.scroll.enabled && !a.getGraphicalElement('scrollerContainer') && a.addGraphicalElement('scrollerContainer', b.setAnimation({\n        el: c || 'group',\n        attr: {\n          name: 'scrollGroup'\n        },\n        container: d,\n        component: a,\n        label: 'scroller'\n      }));\n    }\n  }, {\n    key: \"createScrollBar\",\n    value: function createScrollBar() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g = Math.max,\n          i = this,\n          j = i.config,\n          k = i.getFromEnv('chart-attrib'),\n          l = i.getChildren('legendScrollBar') && i.getChildren('legendScrollBar')[0],\n          m = j.borderWidth || 0,\n          n = pluckNumber(j.padding, 4),\n          o = j.width,\n          p = j.height;\n      a = {\n        conf: {\n          isHorizontal: !1\n        },\n        handler: {\n          scroll: function scroll(a) {\n            j.lastScrollPos = a, j.scrollY = (c - j.totalHeight) * a, i.addJob('scrollDraw', i.drawScroll, priorityList && priorityList.draw);\n          },\n          mousedown: function mousedown(a) {\n            a.preventDefault(), a.stopPropagation();\n          }\n        }\n      }, k.legendscrollbgcolor && (a.conf.color = convertColor(k.legendscrollbgcolor)), l || (l = i.attachChild(new Scroller(), 'legendScrollBar'), this.config.hasScroll = !0), l.configure(a.conf), l.attachEventHandlers(a.handler), b = l.config, c = g(p - n, 0), d = o - 10 + .5 * n - m, e = .5 * m, f = g(p - m, 0), b.scrollRatio = (c + n) / j.totalHeight, b.startPercent = 0, b.scrollPosition = j.lastScrollPos, b.parentLayer = i.getChildContainer('scrollGroup'), l.setDimension({\n        x: d,\n        y: e,\n        height: f\n      });\n    }\n  }, {\n    key: \"drawCaption\",\n    value: function drawCaption() {\n      var a,\n          b,\n          c,\n          d,\n          e = this,\n          f = e.getChildContainer('itemGroup'),\n          g = e.getGraphicalElement('caption'),\n          h = this.getFromEnv('animationManager'),\n          i = this.config,\n          j = pluckNumber(i.padding, 4),\n          k = i.scroll.enabled,\n          l = i.width;\n\n      if (i.title && i.title.text !== BLANKSTRING && i.validLegendItem) {\n        switch (i.title.align) {\n          case POSITION_START:\n            c = j;\n            break;\n\n          case POSITION_END:\n            c = l - j - (k ? 10 : 0);\n            break;\n\n          default:\n            c = .5 * l;\n        }\n\n        b = i.title.style, a = {\n          text: i.title.text,\n          title: i.title.originalText || BLANKSTRING,\n          x: c,\n          y: j,\n          fill: i.title.style.color,\n          direction: i.textDirection,\n          \"line-height\": b.lineHeight,\n          \"vertical-align\": POSITION_TOP,\n          \"text-anchor\": i.title.align,\n          opacity: 1\n        }, d = {\n          \"font-weight\": b.fontWeight,\n          \"font-style\": b.fontStyle,\n          \"font-family\": b.fontFamily,\n          \"font-size\": b.fontSize\n        }, g && g.show(), g ? h.setAnimation({\n          el: g,\n          attr: a,\n          component: e\n        }) : (g = h.setAnimation({\n          el: 'text',\n          attr: a,\n          component: e,\n          container: f\n        }), g = this.addGraphicalElement('caption', g), g.css(d)), e.getFromEnv('toolTipController').enableToolTip(g, i.title.originalText);\n      } else g && h.setAnimation({\n        el: g,\n        component: e,\n        doNotRemove: !0,\n        callback: function callback() {\n          g.hide();\n        }\n      });\n    }\n  }, {\n    key: \"drawLegendBox\",\n    value: function drawLegendBox() {\n      var a,\n          b = this,\n          c = this.getFromEnv('animationManager'),\n          d = b.config,\n          e = b.getContainer('legendGroup'),\n          f = d.width,\n          g = b.getGraphicalElement('box'),\n          h = d.height,\n          i = d.borderRadius,\n          j = d.backgroundColor,\n          k = d.borderColor,\n          l = d.borderAlpha,\n          m = d.backgroundAlpha,\n          n = d.borderWidth || 0;\n      return a = c.setAnimation({\n        el: g || 'rect',\n        attr: {\n          x: 0,\n          y: 0,\n          width: f,\n          height: h,\n          r: i,\n          stroke: k,\n          \"stroke-width\": n,\n          fill: j || NONE,\n          \"stroke-opacity\": l / 100,\n          \"fill-opacity\": m / 100,\n          cursor: d.legendAllowDrag ? 'move' : 'default'\n        },\n        container: e,\n        component: b,\n        label: 'legendGroup'\n      }), g || (b.addGraphicalElement('box', a), a.shadow(d.shadow)), a;\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g = this,\n          h = g.getFromEnv('chart'),\n          i = h.config,\n          j = g.config,\n          k = i.height - i.canvasBottom,\n          l = i.canvasLeft,\n          m = i.canvasWidth,\n          n = j.chartMarginLeft || 0,\n          o = j.chartMarginRight || 0,\n          p = j.chartMarginBottom || 0,\n          q = i.actionBarHeight || 0,\n          r = j.actualCanvasMarginLeft || 0,\n          s = i.actualCanvasMarginBottom || 0,\n          t = i.actualCanvasMarginRight || 0,\n          u = j.alignLegendWithCanvas,\n          v = i.height,\n          w = i.canvasTop,\n          x = j.width || 0,\n          y = j.height || 0,\n          z = i.borderWidth,\n          A = i.oriCanvasLeft,\n          B = i.oriTopSpace,\n          C = i.oriBottomSpace,\n          D = 0,\n          E = 0,\n          F = j.borderWidth || 0,\n          G = j.legendPos;\n      return G === POSITION_RIGHT && (j.align = POSITION_RIGHT, j.verticalAlign = POSITION_MIDDLE, f = j.layout = 'vertical'), f ? (a = i.width - o - t - x - z, D = pluckNumber(B, w), E = pluckNumber(C, k), b = D + .5 * (v - E - D - y) + (j.y || 0)) : (d = i.width - (n + r + (o + t)), e = u ? m - x : d - x, c = u ? pluckNumber(A, l) : n + r, a = c + e / 2, b = v - y - s - p - q), crispBound(a, b, x, y, F);\n    }\n  }, {\n    key: \"setTranslation\",\n    value: function setTranslation(a, b) {\n      var c = this,\n          d = c.config;\n      d._translateX = a, d._translateY = b, d.translate = 't' + a + ',' + b;\n    }\n  }, {\n    key: \"allocatePosition\",\n    value: function allocatePosition() {\n      var a,\n          b = this,\n          c = b.config;\n      a = c.translate ? crispBound(c._translateX, c._translateY, c.width, c.height, c.borderWidth) : b.getPosition(), c.xPos = a.x, c.yPos = a.y, c.width = a.width, c.height = a.height;\n    }\n  }, {\n    key: \"_manageLegendPosition\",\n    value: function _manageLegendPosition(a) {\n      var b,\n          c = this,\n          d = c.config,\n          e = d.legendPos;\n      return d.padding = 4, d.textPadding = 4, b = e === POSITION_RIGHT ? c._placeLegendBlockRight(a) : c._placeLegendBlockBottom(a), b;\n    }\n  }, {\n    key: \"setDimension\",\n    value: function setDimension(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q,\n          r,\n          s,\n          t,\n          u,\n          v,\n          w,\n          x,\n          y,\n          z,\n          A,\n          B = this,\n          C = this.config,\n          D = B.getSortedLegendItems(),\n          E = D.length,\n          F = a.width,\n          G = a.height,\n          H = 2 * G,\n          I = 0,\n          J = 0,\n          K = 0,\n          L = 0,\n          M = 0,\n          N = 0,\n          O = 0,\n          P = 0,\n          Q = [],\n          R = !1,\n          S = C.padding,\n          T = C.textPadding,\n          U = B.getFromEnv('smartLabel'),\n          V = B.getStateCosmetics('default'),\n          W = parseInt(V.text['font-size'], 10) || 10,\n          X = 0,\n          Y = 0,\n          Z = C.title,\n          $ = Z.padding,\n          _ = C.minimiseWrappingInLegend,\n          aa = C.legendPadding,\n          ba = C.legendScale,\n          ca = C.alignLegendWithCanvas,\n          da = C.numColumns,\n          ea = C.oriSymbolPadding,\n          fa = F;\n\n      for (q = {\n        width: 2 * S,\n        height: 2 * S\n      }, p = W + 1, 0 >= p && (p = 1), F -= 2 * S, p *= ba, ea *= ba, p = mathMin(p, F), 0 >= p && (ea = p = 0), C.symbolWidth = p, C.textPadding = 4, C.legendHeight = o = p + 2 * ea, C.rowHeight = g = mathMax(parseInt(V.text['line-height'], 10) || 12, o), f = T + ea + S, U.setStyle(extend2({}, V.text)), r = U.getOriSize(TESTSTR).height, h = aa + C.borderWidth / 2 + 1, h = mathMin(h, G - r - 8), aa = .05 * g, C.initialItemY = 0, C.initialItemX = 0, s = 0; s < E; s += 1) {\n        if (e = D[s], b = e.config || (e.config = {}), c = b, d = b.name = parseUnsafeString(c.label), d === BLANKSTRING || 0 === c.enabled || !1 === c.enabled || e.getState('removed')) {\n          b.enabled = 0;\n          continue;\n        } else b.enabled = 1;\n\n        K += 1, x = !0, y = U.getOriSize(d), I = mathMax(I, y.width), N = mathMax(N, mathMin(y.height, H)), J += y.width;\n      }\n\n      if (C.validLegendItem = x, L = J / K, A = o + aa + T + ea + 2 * S, J += A * K, C.x = !ca && J > fa ? 0 : C.x, x) {\n        for (L += A, I += A, 0 < da && K < da && (da = K), J <= F && (0 >= da || da === K) ? (da = K, M = L = J / K, R = !0, N > g && (P = (N - g) / 2, g = N)) : 0 < da && (M = F / da) > L ? M > I && (M = I) : F > I && (_ || 1.5 * L > I) ? (da = mathFloor(F / I), K < da && (da = K), M = I) : F >= 2 * L ? (da = mathFloor(F / L), K < da && (da = K), M = mathFloor(F / da), M > I && (M = I)) : (da = 1, M = F), C.itemWidth = M, k = mathCeil(M - A), 0 > k && (ea = k = T = 0), C.symbolPadding = ea, C.textPadding = T, C.width = M * da - aa, Z.oriText !== BLANKSTRING && (U.setStyle(Z.style), y = U.getSmartText(Z.oriText, F, H), Z.text = y.text, y.tooltext && (Z.originalText = y.tooltext), n = y.width + 2 * S, C.width < n && (C.initialItemX = (n - C.width) / 2, C.width = n), C.initialItemY = O = y.height + $), U.setStyle(extend2({}, V.text)), s = 0; s < E; s += 1) {\n          if (e = D[s], b = e.config, 0 !== b.enabled) {\n            if (0 === k && (Q[Y] = !0, b.name = BLANKSTRING, t = 1, v = parseInt(Y / da, 10), u = Y % da, b._legendX = u * M, b._legendY = v * g + 2 * S, b._legendH = t * g, b._totalWidth = p + ea), R) y = U.getOriSize(b.name), y.height < g && (b._legendTestY = (g - y.height) / 2), b._markerYGutter = P, b._legendX = X, b._legendY = 2 * S, b._legendH = g, b._totalWidth = p + f + y.width, X += y.width + A;else {\n              for (y = U.getSmartText(b.name, k, H), b.name = y.text, y.tooltext && (b.originalText = y.tooltext); !0 === Q[Y];) {\n                Y += 1;\n              }\n\n              for (l = y.height / g, m = Y, t = 0; t < l; t += 1, m += da) {\n                Q[m] = !0;\n              }\n\n              y.height < g && (b._legendTestY = (g - y.height) / 2), v = parseInt(Y / da, 10), u = Y % da, b._legendX = u * M, b._legendY = v * g + 2 * S, b._legendH = t * g, b._totalWidth = p + f + y.width;\n            }\n            Y++;\n          }\n        }\n\n        w = R ? 1 : mathCeil(Q.length / da), q.height += w * g + O, C.height = C.totalHeight = q.height, C.rowHeight = g, C.legendNumColumns = da, C.height - 2 * ea > G ? (C.height = G, z = C.scroll || (C.scroll = {}), z.enabled = !0, z.flatScrollBars = C.flatScrollBars, z.scrollBar3DLighting = C.scrollBar3DLighting, C.width = C.width + 12 > F ? C.width : C.width + 12) : C.scroll.enabled = !1, h += C.height, C.isActive = !0, C.enabled = !0;\n      } else C.enabled = !1, C.width = 0, h = 0;\n\n      return {\n        width: F,\n        height: h\n      };\n    }\n  }, {\n    key: \"_placeLegendBlockBottom\",\n    value: function _placeLegendBlockBottom(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g = this,\n          h = g.getFromEnv('chart'),\n          i = h.config,\n          j = h.getFromEnv('chartWidth'),\n          k = h.getFromEnv('chartHeight'),\n          l = i.canvasLeft,\n          m = i.width - (i.canvasRight || 0),\n          n = h.getFromEnv('smartLabel'),\n          o = g.config,\n          p = o.chartMarginLeft,\n          q = o.chartMarginRight,\n          r = o.chartMarginTop,\n          s = o.alignLegendWithCanvas,\n          t = g.getSortedLegendItems(),\n          u = t.length,\n          v = o.legendPadding,\n          w = i.canvasMarginRight,\n          x = i.canvasMarginLeft,\n          y = h.getChildren('yAxis'),\n          z = y && y[0].config.isVertical ? y : h.getChildren('xAxis'),\n          A = z && z[0],\n          B = z && z[1],\n          C = A && A.config || {},\n          D = B && B.config || {},\n          E = C.nameMaxW,\n          F = D.nameMaxW,\n          G = C.name && C.name.style || {},\n          H = D.name && D.name.style || {},\n          I = C.axisName || BLANKSTRING,\n          J = D.axisName || BLANKSTRING,\n          K = i.canvasWidth - i.canvasMarginLeft - i.canvasMarginRight;\n      return o.paddingBottom = i.height - i.canvasBottom, n.useEllipsesOnOverflow(i.useEllipsesWhenOverflow), n.setStyle(G), e = n.getOriSize(I), n.setStyle(H), f = n.getOriSize(J), K < v && (o.padding = v = K = 0), (e || f) && (c = pluckNumber(e.height, 0) > pluckNumber(f.height, 0) ? (d = E) && e.width : (d = F) && f.width), K = s ? K : j - (c + r > k - a ? 2 * d + q + p + w + x : q + p + x + w), o.showLegend && 0 !== u ? (o.x = (l - p - m + q) / 2, b = g.setDimension({\n        width: K,\n        height: a\n      }).height) : (b = 0, o.height = 0, o.width = 0), {\n        bottom: b,\n        right: 0\n      };\n    }\n  }, {\n    key: \"_placeLegendBlockRight\",\n    value: function _placeLegendBlockRight(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l,\n          m = this,\n          n = m.config,\n          o = m.getFromEnv('chart'),\n          p = o.config,\n          q = o.getFromEnv('smartLabel'),\n          r = o.getChildren('canvas')[0].config.canvasBorderThickness || 0,\n          s = n.textPadding,\n          t = n.title.padding,\n          u = n.oriSymbolPadding,\n          v = n.legendPadding,\n          w = n.legendScale,\n          x = m.getStateCosmetics('default'),\n          y = parseInt(x.text['font-size'], 10),\n          z = p.canvasHeight,\n          A = 2 * z,\n          B = 0,\n          C = n.padding,\n          D = 2 * C,\n          E = {\n        width: D,\n        height: D\n      },\n          F = {},\n          G = !1,\n          H = m.getSortedLegendItems(),\n          I = H.length,\n          J = 0;\n      if (n.initialItemY = 0, n.initialItemX = 0, a -= D + v, a < v && (n.padding = v = a = 0), e = y + 1, 0 >= e && (e = 1), e *= w, u *= w, e = mathMin(e, a), 0 >= e && (u = e = 0), n.symbolPadding = u, n.symbolWidth = e, n.legendHeight = f = e + 2 * u, n.rowHeight = mathMax(parseInt(x.text['line-height'], 10) || 12, f), b = v + n.borderWidth / 2 + r, d = a - f - v - s, 0 > d && (d = 0), q.useEllipsesOnOverflow(p.useEllipsesWhenOverflow), q.setStyle(extend2({}, x.text)), !n.showLegend || 0 === I) F.right = 0, n.height = 0, n.width = 0;else {\n        for (J = 0; J < I; J += 1) {\n          if (l = H[J], g = l.config || (l.config = {}), k = g, h = g.name = parseUnsafeString(k.label), g._legendX = 0, g._legendY = E.height, 0 === k.enabled || !1 === k.enabled || h === BLANKSTRING) {\n            g.enabled = 0;\n            continue;\n          } else g.enabled = 1;\n\n          G = !0, 0 === d ? (E.height += g._legendH = f, g.name = BLANKSTRING, g._totalWidth = e + u) : (c = q.getSmartText(h, d, A), g.name = c.text, c.tooltext && (g.originalText = c.tooltext), c.height < f && (g._legendTestY = (f - c.height) / 2), g._totalWidth = e + u + s + c.width + v, E.height += g._legendH = mathMax(c.height, f), B = mathMax(c.width, B));\n        }\n\n        n.validLegendItem = G, G ? (n.itemWidth = B + f + v + s, n.width = n.itemWidth + D, n.title.oriText !== BLANKSTRING && (q.setStyle(n.title.style), c = q.getSmartText(n.title.oriText, a, A), n.title.text = c.text, c.tooltext && (n.title.originalText = c.tooltext), j = c.width + D, n.width < j && (n.initialItemX = (j - n.width) / 2, n.width = j), n.initialItemY = c.height + t, E.height += n.initialItemY), n.height = n.totalHeight = E.height, b = mathMin(n.width + b, a), F.right = b + v, n.isActive = !0, n.enabled = !0) : (n.enabled = !1, n.width = 0, F.right = 0);\n      }\n      return F;\n    }\n  }, {\n    key: \"postSpaceManager\",\n    value: function postSpaceManager() {\n      var a = this,\n          b = a.config,\n          c = b.legendPos,\n          d = a.getFromEnv('chart'),\n          e = d.config.canvasHeight;\n      c === POSITION_RIGHT && (b.height > e ? (b.height = e, b.scroll.enabled = !0, b.scroll.flatScrollBars = b.flatScrollBars, b.scroll.scrollBar3DLighting = b.scrollBar3DLighting, b.width += (b.scroll.scrollBarWidth = 10) + (b.scroll.scrollBarPadding = 2)) : b.scroll.enabled = !1);\n    }\n  }, {\n    key: \"configureAttributes\",\n    value: function configureAttributes() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _get(_getPrototypeOf(Legend.prototype), \"configureAttributes\", this).call(this, a);\n\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g = this,\n          h = g.config,\n          i = g.getFromEnv('chart'),\n          j = i.config,\n          k = g.getFromEnv('style'),\n          l = i.getFromEnv('chart-attrib'),\n          m = i.config.is3D,\n          n = g.getFromEnv('color-manager'),\n          o = m ? chartPaletteStr.chart3D : chartPaletteStr.chart2D,\n          p = h.interactiveLegend = !1 !== i.hasInteractiveLegend && !!pluckNumber(l.interactivelegend, 1),\n          q = pluckNumber(l.useroundedges, 0),\n          r = k.outCancolor,\n          s = a.style && a.style.text,\n          t = pluck(l.legenditemfont, s && s['font-family'], k.outCanfontFamily),\n          u = pluckNumber(l.legendiconscale, 1),\n          v = pluckFontSize(l.legenditemfontsize, s && s['font-size'], k.fontSize) + 'px',\n          w = pluck(l.legenditemfontcolor, s && s.color, r).replace(/^#?([a-f0-9]+)/ig, '#$1'),\n          x = getFirstColor(pluck(l.legenditemhoverfontcolor, w));\n      h.isActive = !1, h.chartMarginTop = j.origMarginTop, h.chartMarginRight = j.origMarginRight, h.chartMarginBottom = j.origMarginBottom, h.chartMarginLeft = j.origMarginLeft, h.reverselegend = pluckNumber(l.reverselegend, 0), h.showLegend = pluckNumber(l.showlegend, !i.dontShowLegendByDefault, 1), b = setLineHeight({\n        fontSize: v\n      }), h.legendPos = pluck(l.legendposition, i.legendposition, a.legendPosition, POSITION_BOTTOM).toLowerCase(), h.numColumns = pluckNumber(l.legendnumcolumns, 0), h.xL = h.yL = 0, (0 >= u || 5 < u) && (u = 1), h.drawCustomLegendIcon = pluckNumber(l.drawcustomlegendicon, a.drawcustomlegendicon, 0), h.legendScale = u, h.legendPadding = pluckNumber(l.legendpadding, 7), h.alignLegendWithCanvas = pluckNumber(a.alignlegendwithcanvas, j.alignLegendWithCanvas), h.title.style = {\n        fontFamily: pluck(l.legendcaptionfont, t),\n        fontSize: pluckFontSize(l.legendcaptionfontsize, k.fontSize) + 'px',\n        color: pluck(l.legendcaptionfontcolor, r).replace(/^#?([a-f0-9]+)/ig, '#$1'),\n        fontWeight: styleValueMap.fontWeight[pluckNumber(l.legendcaptionfontbold, 1)] || BLANKSTRING\n      }, f = l.legendcaptionalignment ? l.legendcaptionalignment.toLowerCase() : TEXT_ANCHOR_MAP.center, h.title.align = TEXT_ANCHOR_MAP[f] || TEXT_ANCHOR_MAP.center, h.title.style['text-anchor'] = h.title.align, h.padding = 4, c = pluck(l.legendbordercolor, n.getColor(o.legendBorderColor)), d = h.borderAlpha = pluckNumber(l.legendborderalpha, 100), h.borderColor = convertColor(c, d), h.borderWidth = pluckNumber(l.legendborderthickness, a.legendborderthickness, !q || l.legendbordercolor ? 1 : 0), h.borderRadius = pluckNumber(q, 0), h.backgroundAlpha = e = pluckNumber(l.legendbgalpha, a.legendbgalpha, 100), h.backgroundColor = convertColor(pluck(l.legendbgcolor, n.getColor(o.legendBgColor)), e), h.symbol3DLighting = !!pluckNumber(l.use3dlighting, l.useplotgradientcolor, 1), h.shadow = !!pluckNumber(l.legendshadow, 1), h.shadow && (h.shadow = {\n        enabled: h.shadow,\n        opacity: mathMax(d, e) / 100\n      }), h.prevReversed = !!pluckNumber(h.reversed, 0), h.reversed = !!pluckNumber(l.reverselegend, 0), h.lineWidth = pluckNumber(l.linethickness, 2), h.borderRadius = pluckNumber(l.legendborderradius, q ? 3 : 0), h.legendAllowDrag = !!pluckNumber(l.legendallowdrag, 0), h.title.oriText = parseUnsafeString(getFirstValue(l.legendcaption, BLANKSTRING)), h.legendScrollBgColor = getFirstColor(pluck(l.legendscrollbgcolor, l.scrollcolor, n.getColor('altHGridColor'))), h.legendScrollBarColor = pluck(l.legendscrollbarcolor, c), h.legendScrollBtnColor = pluck(l.legendscrollbtncolor, c), h.minimiseWrappingInLegend = pluckNumber(l.minimisewrappinginlegend, 0), h.flatScrollBars = pluckNumber(l.flatscrollbars, 0), h.scrollBar3DLighting = pluckNumber(l.scrollbar3dlighting, 1), h.orderReversed = !1, g.setStateCosmetics('hidden', {\n        symbol: {\n          fill: convertColor(pluck(l.legenditemhiddencolor, 'cccccc').replace(/^#?([a-f0-9]+)/ig, '#$1')),\n          stroke: convertColor(pluck(l.legenditemhiddencolor, 'cccccc').replace(/^#?([a-f0-9]+)/ig, '#$1'))\n        },\n        text: {\n          fill: convertColor(pluck(l.legenditemhiddencolor, 'cccccc').replace(/^#?([a-f0-9]+)/ig, '#$1'))\n        }\n      }), g.setStateCosmetics('default', {\n        text: {\n          fill: convertColor(w),\n          \"font-family\": t,\n          cursor: p ? preDefStr.POINTER : 'default',\n          \"font-size\": v,\n          \"line-height\": b,\n          \"vertical-align\": POSITION_TOP,\n          \"text-anchor\": POSITION_START,\n          direction: 'rtl' === j.textDirection ? 'rtl' : 'initial',\n          \"font-weight\": styleValueMap.fontWeight[pluckNumber(l.legenditemfontbold, 0)] || BLANKSTRING\n        },\n        symbol: {\n          bgColor: pluck(l.legendiconbgcolor),\n          cursor: p ? preDefStr.POINTER : 'default',\n          borderColor: pluck(l.legendiconbordercolor),\n          bgAlpha: pluck(l.legendiconbgalpha, l.legendiconalpha, 100),\n          borderAlpha: pluck(l.legendiconborderalpha, l.legendiconalpha, 100),\n          borderThickness: pluckNumber(l.legendiconborderthickness),\n          startAngle: pluckNumber(l.legendiconstartangle, 45),\n          sides: pluckNumber(l.legendiconsides, a.legendiconsides, 4)\n        }\n      }), g.setStateCosmetics('hover', function (a, b) {\n        return b.hasState('hidden') || (!a.text && (a.text = {}), a.text.fill = convertColor(x.replace(/^#?([a-f0-9]+)/ig, '#$1')), a.text.cursor = 'inherit'), a;\n      }), h.legendAllowDrag && !h._dragEvtListenerBinded ? (g.addEventListener('fc-dragstart', h.handlers.dragstart), g.addEventListener('fc-dragmove', h.handlers.dragmove), h._dragEvtListenerBinded = !0) : (g.removeEventListener('fc-dragstart', h.handlers.dragstart), g.removeEventListener('fc-dragmove', h.handlers.dragmove), h._dragEvtListenerBinded = !1);\n    }\n  }, {\n    key: \"getLegendState\",\n    value: function getLegendState() {\n      return this._legendState;\n    }\n  }, {\n    key: \"hasState\",\n    value: function hasState(a) {\n      var b,\n          c,\n          d = this.getLegendState();\n\n      for (b = 0, c = d.length; b < c; b++) {\n        if (d[b] === a) return !0;\n      }\n\n      return !1;\n    }\n  }, {\n    key: \"setLegendState\",\n    value: function setLegendState(a, b) {\n      this.hasState(a) || (b ? this._legendState.push(a) : this._legendState.unshift(a)), this.asyncDraw();\n    }\n  }, {\n    key: \"removeLegendState\",\n    value: function removeLegendState(a) {\n      var b,\n          c,\n          d = 1;\n      if (a) for (b = 0, c = this._legendState.length; b < c && d; b++) {\n        a === this._legendState[b] && (this._legendState.splice(b, 1), d = 0);\n      } else this._legendState.length = 0;\n      this.asyncDraw();\n    }\n  }, {\n    key: \"setStateCosmetics\",\n    value: function setStateCosmetics(a, b) {\n      this._stateCosmetics[a] = b;\n    }\n  }, {\n    key: \"removeStateCosmetics\",\n    value: function removeStateCosmetics(a) {\n      delete this._stateCosmetics[a];\n    }\n  }, {\n    key: \"getStateCosmetics\",\n    value: function getStateCosmetics(a) {\n      return this._stateCosmetics[a];\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var a = this,\n          b = a.getFromEnv('chart'),\n          c = b.getChildContainer('legendGroup');\n      c && c.hide();\n    }\n  }]);\n\n  return Legend;\n}(ComponentInterface);\n\nexport default Legend;","map":null,"metadata":{},"sourceType":"module"}