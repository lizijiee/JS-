{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport Cartesian, { minimumEnquiry } from './cartesian';\nimport { UNDEF, stubFN, extend2, toPrecision, pluckNumber, setLineHeight, pluck } from '../lib';\nimport { getTrendLineLimits, _drawLabel, _parseLabel, getLabel, setAxisPadding } from './common-api';\nvar ROTATED_LABEL_PADDING = 3,\n    ROTATED_LABEL_MIN_GAP = 10;\n\nvar CartesainLabelManager =\n/*#__PURE__*/\nfunction (_Cartesian) {\n  _inherits(CartesainLabelManager, _Cartesian);\n\n  function CartesainLabelManager() {\n    _classCallCheck(this, CartesainLabelManager);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CartesainLabelManager).apply(this, arguments));\n  }\n\n  _createClass(CartesainLabelManager, [{\n    key: \"_getHMaxLabelDimention\",\n    value: function _getHMaxLabelDimention(a) {\n      function b(a, b) {\n        switch (b.toLowerCase()) {\n          case 'left':\n            return R(T._getCustomPixel(a));\n\n          case 'right':\n            return R(W.width - T._getCustomPixel(a));\n        }\n      }\n\n      var c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q,\n          r,\n          s,\n          t,\n          u,\n          v,\n          w,\n          x,\n          y,\n          z,\n          A,\n          B,\n          C,\n          D,\n          E,\n          F,\n          G,\n          H,\n          I,\n          J,\n          K,\n          L,\n          M,\n          N = Math.ceil,\n          O = Math.max,\n          P = Math.floor,\n          Q = Math.min,\n          R = Math.abs,\n          S = Number.POSITIVE_INFINITY,\n          T = this,\n          U = T.config,\n          V = T.getFromEnv('chart'),\n          W = V.config,\n          X = V.getFromEnv('smartLabel'),\n          Y = U.axisRange,\n          Z = U.labels,\n          $ = U.labelDisplay,\n          _ = U.slantLabel,\n          aa = Z.style,\n          ba = U.maxLabelHeight,\n          ca = T.getInterval(),\n          da = U.staggerLines,\n          ea = U.labelStep,\n          fa = W.canvasLeft,\n          ga = W.canvasRight,\n          ha = da - 2,\n          ia = Y.max,\n          ja = Y.min,\n          ka = 0,\n          la = U.tickValues && U.tickValues.tickValue,\n          ma = la && la.length,\n          na = V.distributedColumns,\n          oa = 0,\n          pa = {\n        text: UNDEF,\n        width: 0,\n        style: UNDEF\n      },\n          qa = 0,\n          ra = 4,\n          sa = stubFN,\n          ta = stubFN,\n          ua = stubFN,\n          va = {},\n          wa = 0,\n          xa = !1,\n          ya = 0,\n          za = !1,\n          Aa = S,\n          Ba = U.ticks,\n          Ca = S;\n      if (na) for (t = 0; t < ma; t++) {\n        la[t + 1] ? la[t].x && (la[t].plotWidth = T.getPixel(la[t + 1].x - la[t].x) - T.getPixel(0)) : la[t].plotWidth = T.getPixel(W.canvasRight - la[t].x) - T.getPixel(0);\n      }\n      if (U.tickValues && (!la || 0 === la.length)) return {\n        width: 0,\n        height: 0\n      };\n\n      if ('rotate' === $ && (U.rotateLabels = 1), U.tickValues || (U.irregularCatAxis = !1), U.sWidthAdjstFactor = d = 0 == ha ? 1 : 1 == ha ? 1.5 : ha, X.useEllipsesOnOverflow(W.useEllipsesWhenOverflow), X.setStyle({\n        fontSize: aa.fontSize,\n        fontFamily: aa.fontFamily,\n        lineHeight: aa.lineHeight,\n        fontWeight: aa.fontWeight\n      }), U.irregularCatAxis) {\n        for (la.sort(function (a, b) {\n          return a.x - b.x;\n        }), t = 0, oa = la.length; t < oa; t++) {\n          if (g = la[t], 'undefined' != typeof z) {\n            if (Ca = R(g.x - z), D = R(T._getCustomPixel(ja) - T._getCustomPixel(ja + Ca)), X.setStyle(Object.assign({}, g.style)), B = X.getOriSize('W'), C = B.width, D < 1.2 * C) {\n              g.label = '', Ca = Aa;\n              continue;\n            }\n\n            E._individualIWR = D, g._individualIWL = D, Aa = Ca;\n          }\n\n          E = g, z = g.x;\n        }\n\n        for (Ca === S && (Ca = P(Q(g.x, ia - g.x)), Ca = O(Ca, 4)), t = 0, oa = la.length; t < oa; t++) {\n          g = la[t], t || (g._individualIWL = 1 / 0), t === oa - 1 && (g._individualIWR = 1 / 0), g.individualIW = Q(g._individualIWL, g._individualIWR);\n        }\n\n        j = R(T._getCustomPixel(ja) - T._getCustomPixel(ja + Ca)), j = Q(2 * b(la[0].x, 'left'), 2 * b(la[oa - 1].x, 'right'), j);\n      } else j = R(T._getCustomPixel(ja) - T._getCustomPixel(ja + ca));\n\n      if (a = ba || a, va.__root__ = {\n        getHeight: function getHeight(a) {\n          var b = la[a],\n              c = b._ovrStyle.lineHeight,\n              d = parseInt(c.replace(/(\\d+)px/, '$1'), 10);\n          return d;\n        },\n        getWidth: function getWidth() {\n          return a;\n        },\n        getCalculatedLabelStep: function getCalculatedLabelStep(a) {\n          var b,\n              c,\n              d,\n              e,\n              f,\n              g,\n              i,\n              l,\n              m,\n              n,\n              o = 0,\n              p = a.length,\n              q = Number.NEGATIVE_INFINITY,\n              r = {},\n              s = 0;\n\n          for (o = 0; o < p; o++) {\n            e = a[o], e.style = e.style || {};\n          }\n\n          if (U.irregularCatAxis) return U.labelStep;\n\n          for (o = 0; o < p; o++) {\n            (e = a[o], !!e) && (e.label || (e.label = ''), f = e.oriLabel || e.label, h = {\n              fontSize: aa.fontSize,\n              fontFamily: aa.fontFamily,\n              lineHeight: aa.lineHeight,\n              fontWeight: aa.fontWeight\n            }, s++, e.style = e.style || {}, extend2(h, e.style), b = h.fontSize + h.fontFamily + h.lineHeight + h.fontWeight, r[b] ? f.length > r[b].label.length && (r[b].label = f) : r[b] = {\n              label: f,\n              style: h\n            });\n          }\n\n          for (g in r) {\n            r.hasOwnProperty(g) && (c = r[g].style, d = r[g].label, c.lineHeight = setLineHeight(c), X.setStyle(c), U.rotateLabels && (m = parseInt(c.lineHeight.replace(/(\\d+)px/, '$1'), 10)), k = X.getSmartText(d, UNDEF, m), l = 0 === U.rotateLabels ? 60 < k.width ? 60 : k.width : k.height, q = O(l, q));\n          }\n\n          return i = P(R(T._getCustomPixel(ia) - T._getCustomPixel(ja)) / q), n = O(N(s / i), U.labelStep), j = R(T._getCustomPixel(ja) - T._getCustomPixel(ja + n)), s <= i ? U.labelStep : n;\n        }\n      }, va._inProp = {}, va.getCopyById = function (a) {\n        var b,\n            c = this,\n            d = c._inProp,\n            e = c.__root__,\n            f = d.copyStore;\n        return (f = f || {}, b = f[a], b) ? b : (extend2(b = f[a] = {}, e), b);\n      }, U.tickValues) {\n        for ('rotate' === $ ? (Z.rotation = _ ? 300 : 270, n = va.getCopyById('rotate')) : 'stagger' === $ ? (n = va.getCopyById('stagger'), n.getHeight = function (a) {\n          var b, c, d, e;\n          return b = U.tickValues.tickValue, c = b[a], d = c && c.style || (c.style = {}), h = {\n            fontSize: aa.fontSize,\n            fontFamily: aa.fontFamily,\n            lineHeight: aa.lineHeight,\n            fontWeight: aa.fontWeight\n          }, extend2(h, d), X.setStyle(h), e = X.getOriSize(c.label), e.height;\n        }, n.getWidth = function (a) {\n          return ra = 1, a.individualIW ? a.individualIW : 2 * j * d - ra;\n        }, ua = function ua(b) {\n          var c,\n              d,\n              e,\n              f,\n              g,\n              h,\n              i,\n              j,\n              k = b.length,\n              l = 0;\n          if (X.setStyle(aa), j = X.getOriSize('WWW'), e = j.height, d = b[k - 1], P(d._cumulativeSum) <= N(k * (e + 2))) h = P(a / e), da = 0 > h - da ? h : da;else {\n            h = P(a / (e + 4));\n\n            do {\n              for (l = 0, i = h, (f = i - 1, k = b.length); f < k;) {\n                if (k - f < h && (f = k - 1), c = b[f], g = c._cumulativeSum - l, ~~g > -~a) {\n                  xa = !0;\n                  break;\n                } else xa = !1;\n\n                l = c._cumulativeSum, f += i;\n              }\n            } while (h-- && xa);\n\n            h++, da = Q(da, h);\n          }\n          U.drawnStaggerLines = da;\n        }, sa = function sa(a) {\n          var b,\n              c,\n              d,\n              f,\n              g,\n              h = 0;\n\n          for (g = 0, d = a.length; g < d; g++) {\n            (b = a[g], !b.stepSkipped) && (c = b && b.style || {}, (f = c.lineHeight) || (f = aa.lineHeight), e = h++ % da, b.labelPadding = e ? f.replace(/px/i, '') * e : 0);\n          }\n        }) : 'none' === $ ? (n = va.getCopyById('none'), n.getHeight = stubFN, n.getWidth = stubFN, ta = stubFN, U.rotateLabels && (Z.rotation = _ ? 300 : 270, A = a), n.getCalculatedLabelStep = function () {\n          return U.labelStep;\n        }) : (n = va.getCopyById('auto'), n.getHeight = function () {\n          return a;\n        }, n.getWidth = function (a) {\n          return a.individualIW ? a.individualIW : j - 2 * ra;\n        }, ta = function ta(a, b) {\n          var c,\n              d,\n              e,\n              f,\n              g,\n              h,\n              p = V.getFromEnv('chart-attrib'),\n              q = pluckNumber(p && p.rotatelabels);\n\n          if (!U.irregularCatAxis && (X.setStyle(a), d = X.getOriSize('WWW'), c = d.width, c >= j && 0 !== q)) {\n            for (Z.rotation = _ ? 300 : 270, Z.forceRotate = !0, n = va.getCopyById('rotate'), l = n.getWidth, m = n.getHeight, pa.width = 0, (e = 0, f = b.length); e < f; e++) {\n              (g = b[e], g && (g.label || g.oriLabel) && 0 !== pluckNumber(g.showlabel, U.showLabels, 1) && !0 !== g.stepSkipped) && (h = g._ovrStyle, X.setStyle({\n                fontSize: h.fontSize,\n                fontFamily: h.fontFamily,\n                lineHeight: h.lineHeight,\n                fontWeight: h.fontWeight\n              }), k = X.getSmartText(g.oriLabel, l(g), m(e)), g.label = k.text, g.labelTooltext = k.tooltext, g._sLabel = k, pa.width < k.width && (pa.text = k.text, pa.width = k.width, pa.height = k.height, pa.style = h));\n            }\n\n            o = pa.text;\n          }\n        }), l = n.getWidth, m = n.getHeight, ea = U.labels.step = U.labelStep = U._oriLabelStep, ea = U.labels.step = U.labelStep = n.getCalculatedLabelStep(la), q = minimumEnquiry(la), t = q, p = 0, u = 0, oa = la.length; t < oa; t++, p++) {\n          if (g = la[t], g && (g.label || g.oriLabel) && 0 !== pluckNumber(g.showlabel, U.showLabels, 1)) {\n            if (za = !0, h = {\n              fontSize: aa.fontSize,\n              fontFamily: aa.fontFamily,\n              lineHeight: aa.lineHeight,\n              fontWeight: aa.fontWeight\n            }, extend2(h, g.style), h.lineHeight = setLineHeight(h), K = h.fontSize + h.fontFamily + h.lineHeight + h.fontWeight, K != J && (X.setStyle(h), J = K), p % ea) {\n              g.stepSkipped = !0, g.appliedSmartLabel = !1, ya++;\n              continue;\n            } else g.appliedSmartLabel = !0, g.stepSkipped = !1;\n\n            g._ovrStyle = h, la[t].plotWidth ? c = O('rotate' === $ ? la[t].plotWidth - 6 : 0, m(t)) : ('rotate' === $ ? t < oa - 1 && (f = T.getPixel(t + 1) - T.getPixel(t) - ROTATED_LABEL_MIN_GAP) : f = 0, 'rotate' === $ && isNaN(+f) && (f = W.canvasWidth / T.getVisibleLength() - ROTATED_LABEL_PADDING), c = O(f, m(t))), k = X.getSmartText(g.oriLabel || g.label, l(g), c), wa += k.height + 2, T.components.labels[u++] = {\n              config: {\n                width: k.width,\n                height: k.height,\n                props: {\n                  label: {}\n                }\n              }\n            }, g._cumulativeSum = wa, g.oriLabel = g.oriLabel || g.label, g.label = k.text, g.labelTooltext = k.tooltext, g._sLabel = k, pa.width < k.oriTextWidth && (extend2(pa, k), pa.style = h), qa < k.height && (qa = k.height);\n          }\n        }\n\n        if (!za) return {\n          height: 0,\n          width: 0\n        };\n        if (ua(la, ya), sa(la, ya), ta(pa.style, la), o = pa.text || '', 'mixed' === U.xAxisLabelMode) for (x = U.isPercent ? V.getFromEnv('number-formatter').percentValue : V.getFromEnv('number-formatter').xAxis, ka = o.length, (t = 0, L = Ba && Ba.length); t < L; ++t) {\n          w = Ba[t], v = '' + x.call(V.getFromEnv('number-formatter'), w, U.axisIndex), v.length > ka && (o = v, ka = v.length);\n        }\n\n        for (pa.height = O(qa, pa.height || 0), H = la.length, (t = 0, oa = la.length); t < oa && (F = la[t], !F._sLabel); t++) {\n          ;\n        }\n\n        for (oa = la.length, t = oa - 1; 0 <= t && (G = la[t], !G._sLabel); t--) {\n          ;\n        }\n\n        I = 1 !== T.getZoom(), Z.rotation || I || !F._sLabel ? (U.axisEndLabelDisplaySpace.left = 0, U.axisEndLabelDisplaySpace.right = 0) : (U.axisEndLabelDisplaySpace.left = O(fa - (T._getCustomPixel(F.x || 0) - F._sLabel.width / 2), 0), U.axisEndLabelDisplaySpace.right = O(T._getCustomPixel(G.x || H - 1) + G._sLabel.width / 2 - ga, 0)), y = pa;\n      } else {\n        for (x = U.numberFormatterFn ? V.getFromEnv('number-formatter')[U.numberFormatterFn] : U.isPercent ? V.getFromEnv('number-formatter').percentValue : V.getFromEnv('number-formatter').xAxis, t = 0, L = Ba && Ba.length; t < L; ++t) {\n          M = Ba[t], w = toPrecision(M, 10), v = '' + x.call(V.getFromEnv('number-formatter'), w, U.axisIndex), M === ja && (r = v), M === ia && (s = v), y = X.getOriSize(v), T.components.labels[t] = {\n            config: {\n              width: y.width,\n              height: y.height,\n              props: {\n                label: {}\n              }\n            }\n          }, v.length > ka && (o = v, ka = v.length);\n        }\n\n        X.setStyle({\n          fontSize: aa.fontSize,\n          fontFamily: aa.fontFamily,\n          lineHeight: aa.lineHeight,\n          fontWeight: aa.fontWeight\n        }), y = X.getOriSize(o || ''), 'rotate' === $ && (Z.rotation = 270), U.rotateLabels && (_ ? Z.rotation = 300 : Z.rotation = 270), Z.rotation || (r = X.getOriSize(r || ''), s = X.getOriSize(s || ''), U.axisEndLabelDisplaySpace.left = r.width / 2 + 2, U.axisEndLabelDisplaySpace.right = s.width / 2 + 2);\n      }\n\n      return U.tickValues && 'stagger' === $ && (y.height = da * pa.height), y.width = A ? Q(A, y.width) : y.width, y.width = pluckNumber(y.width), y.maxWidth = pluckNumber(y.maxWidth), y;\n    }\n  }, {\n    key: \"_getVMaxLabelDimention\",\n    value: function _getVMaxLabelDimention(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q = this,\n          r = q.config,\n          s = q.getFromEnv('chart'),\n          t = s.config,\n          u = s.getFromEnv('smartLabel'),\n          v = r.labels.style,\n          w = r.useEllipsesWhenOverflow,\n          x = r.maxLabelWidthPercent,\n          y = r.minLabelWidthPercent,\n          z = 0,\n          A = s.getFromEnv('dataSource').categories,\n          B = {\n        height: 0,\n        width: 0\n      },\n          C = r.ticks,\n          D = {};\n\n      if (u.useEllipsesOnOverflow(t.useEllipsesWhenOverflow), u.setStyle({\n        fontSize: v.fontSize,\n        fontFamily: v.fontFamily,\n        lineHeight: v.lineHeight,\n        fontWeight: v.fontWeight\n      }), r.tickValues) {\n        for (A && (D = {\n          fontFamily: A[0].font,\n          fontSize: A[0].fontsize,\n          color: A[0].fontcolor\n        }), x && (c = x / 100 * t.width, c < a && (a = c)), y && (d = y / 100 * t.width, d > a && (a = d)), j = r.tickValues.tickValue, (e = 0, k = j.length); e < k; e++) {\n          (l = j[e], 0 !== pluckNumber(l.showlabel, r.showLabels)) && (o = {\n            fontFamily: pluck(l.font, l.labelfont, D.fontFamily, v.fontFamily),\n            fontSize: pluck(l.fontsize, l.labelfontsize, D.fontSize, v.fontSize).replace(/px/i, '') + 'px',\n            fontWeight: 'normal' == v.fontWeight ? pluckNumber(l.fontbold, l.labelfontbold, 0) ? 'bold' : 'normal' : v.fontWeight,\n            fontStyle: 'normal' == v.fontStyle ? pluckNumber(l.fontitalic, l.labelfontitalic, 0) ? 'italic' : 'normal' : v.fontStyle\n          }, p = {\n            fontFamily: pluck(o.fontFamily, D.fontFamily, v.fontFamily),\n            fontSize: pluck(o.fontSize, D.fontSize, v.fontSize),\n            fontWeight: pluck(o.fontWeight, v.fontWeight),\n            fontStyle: pluck(o.fontStyle, v.fontStyle)\n          }, p.lineHeight = setLineHeight(p), u.setStyle(p), m = u.getSmartText(l.oriLabel || l.label, a, v.lineHeight, w), q.components.labels[e] = {\n            config: {\n              width: m.width,\n              height: m.height,\n              props: {\n                label: {}\n              }\n            }\n          }, l.oriLabel = l.oriLabel || l.label, l.label = h = m.text, l.labelTooltext = m.tooltext, m.width > z && (B = m, z = m.width));\n        }\n\n        return B;\n      }\n\n      for (n = r.numberFormatterFn ? s.getFromEnv('number-formatter')[r.numberFormatterFn] : r.isPercent ? s.getFromEnv('number-formatter').percentValue : s.getFromEnv('number-formatter').yAxis, e = 0, f = C && C.length; e < f; ++e) {\n        g = toPrecision(C[e], 10), h = '' + n.call(s.getFromEnv('number-formatter'), g, r.axisIndex), m = u.getSmartText(h), q.components.labels[e] = {\n          config: {\n            width: m.width,\n            height: m.height,\n            props: {\n              label: {}\n            }\n          }\n        }, h.length > z && (b = h, z = h.length);\n      }\n\n      return u.getOriSize(b);\n    }\n  }, {\n    key: \"getCleanValue\",\n    value: function getCleanValue(a, b) {\n      var c = this,\n          d = c.getFromEnv('number-formatter');\n      return d.getCleanValue(a, b);\n    }\n  }, {\n    key: \"generateMinorTicks\",\n    value: function generateMinorTicks() {\n      if (this) return [];\n    }\n  }, {\n    key: \"setCanvas\",\n    value: function setCanvas(a) {\n      var b = this,\n          c = b.config;\n      c.canvas = a;\n    }\n  }, {\n    key: \"_adjustNumberFormatter\",\n    value: function _adjustNumberFormatter(a) {\n      var b,\n          c,\n          d = this,\n          e = d.config,\n          f = e.axisIndex,\n          g = e.isVertical,\n          h = d.getFromEnv('chart'),\n          i = h.getFromEnv('number-formatter'),\n          j = e._defaultDecimalPrecision,\n          k = e._defaultForceDecimal,\n          l = 0;\n      c = g || 'yAxis' === e.numberFormatterFn ? (i.Y[f] || i.Y[0]).yAxisLabelConf : i.paramX, j === UNDEF ? e._defaultDecimalPrecision = c.decimalprecision : c.decimalprecision = j, k === UNDEF ? e._defaultForceDecimal = c.forcedecimals : c.forcedecimals = k;\n      0 < parseInt(a, 10) || (b = a.toString().split('.')[1], b && (l = b.match(/^[0]*/)[0].length + 1, l > c.decimalprecision && (c.forcedecimals = 1), c.decimalprecision = Math.max(l, c.decimalprecision)));\n    }\n  }, {\n    key: \"setLabelConfig\",\n    value: function setLabelConfig(a) {\n      var b,\n          c = this,\n          d = c.config,\n          e = d.labels;\n\n      for (b in a) {\n        a.hasOwnProperty(b) && (e[b] = a[b]);\n      }\n    }\n  }]);\n\n  return CartesainLabelManager;\n}(Cartesian);\n\nCartesainLabelManager.prototype._parseLabel = _parseLabel, CartesainLabelManager.prototype._drawLabel = _drawLabel, CartesainLabelManager.prototype.getTrendLineLimits = getTrendLineLimits, CartesainLabelManager.prototype.setAxisPadding = setAxisPadding, CartesainLabelManager.prototype.getLabel = getLabel;\nexport default CartesainLabelManager;","map":null,"metadata":{},"sourceType":"module"}