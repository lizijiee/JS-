{"ast":null,"code":"import _slicedToArray from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { UNDEF, pluckNumber, extent, POSITION_START, parseUnsafeString, POSITION_BOTTOM, POSITION_TOP, POSITION_END, extend2, toPrecision, parseTooltext, getSuggestiveRotation } from '../lib';\nimport difference from 'ramda/src/difference';\n\nvar queryOptions = {\n  wrtVisible: !0\n},\n    LABEL_ID = '_label',\n    NORMALSTRING = 'normal',\n    extractStyleInfo = function extractStyleInfo(a, b) {\n  var c,\n      d,\n      e,\n      f,\n      g,\n      h,\n      i,\n      j = {\n    labelfont: ['fontFamily'],\n    labelfontcolor: ['fontColor'],\n    labelfontsize: ['fontSize', function (a) {\n      return a ? pluckNumber(a) + 'px' : UNDEF;\n    }],\n    labelfontbold: ['fontWeight', function (a) {\n      return a ? 'bold' : NORMALSTRING;\n    }],\n    labelfontitalic: ['fontStyle', function (a) {\n      return a ? 'italic' : NORMALSTRING;\n    }],\n    labelfontalpha: ['fontAlpha']\n  },\n      k = b.getFromEnv('dataSource').categories,\n      l = k && k[0] || {},\n      m = function m(a) {\n    return a;\n  },\n      n = !1,\n      o = {};\n\n  for (c in l) {\n    'category' === c || c in a || (d = l[c], a[c] = d);\n  }\n\n  for (c in j) {\n    f = j[c], g = f[0], h = f[1] || m, d = a[c], e = a[g.toLowerCase()], (d !== UNDEF || e !== UNDEF) && ((i = h(d)) !== UNDEF || (i = h(e)) !== UNDEF) && (o[g] = i, n = !0), n && (a.style = o);\n  }\n},\n    setAxisDimention = function setAxisDimention(a) {\n  var b = this,\n      c = b.getScale(),\n      d = b.config,\n      e = b.getFromEnv('chart'),\n      f = e.config,\n      g = d.axisDimention || (d.axisDimention = {}),\n      h = d.isReverse;\n  g.opposite = pluckNumber(a.opposite, g.opposite), g.x = pluckNumber(a.x, g.x, f.canvasLeft), g.y = pluckNumber(a.y, g.y, f.canvasTop), g.axisLength = pluckNumber(a.axisLength, g.axisLength), d.isVertical ? h ? c.setRange([g.y + g.axisLength, g.y]) : c.setRange([g.y, g.y + g.axisLength]) : h ? c.setRange([g.x + g.axisLength, g.x]) : c.setRange([g.x, g.x + g.axisLength]), d.translation = b._computeTranslation();\n},\n    setDataLimit = function setDataLimit(a, b) {\n  var _extent, _extent2, _g$getTrendLineLimits, _g$getTrendLineLimits2, _extent3, _extent4;\n\n  var c,\n      d,\n      e,\n      f,\n      g = this,\n      h = g.config,\n      i = g.getFromEnv('dataSource').categories,\n      j = i && i[0] && i[0].category,\n      k = h.startPad || 0,\n      l = h.endPad || 0,\n      m = h.xAxisLabelMode;\n  ('categories' === m || 'mixed' === m) && (_extent = extent(j, function (a) {\n    return +a.x;\n  }), _extent2 = _slicedToArray(_extent, 2), c = _extent2[0], d = _extent2[1], _extent), (_g$getTrendLineLimits = g.getTrendLineLimits(), _g$getTrendLineLimits2 = _slicedToArray(_g$getTrendLineLimits, 2), e = _g$getTrendLineLimits2[0], f = _g$getTrendLineLimits2[1], _g$getTrendLineLimits), (_extent3 = extent([e, f, c, d, b, a], function (b) {\n    return +b;\n  }), _extent4 = _slicedToArray(_extent3, 2), b = _extent4[0], a = _extent4[1], _extent3), h.originalMax = a, h.originalMin = b, a = h.isPercent ? 100 : a + l, b = h.isPercent ? 0 : b - k, g._setAxisRange({\n    min: b,\n    max: a\n  }), h.axisRange.tickInterval !== UNDEF && g._adjustNumberFormatter(h.axisRange.tickInterval);\n},\n    getTrendLineLimits = function getTrendLineLimits() {\n  var _extent5, _extent6, _extent7, _extent8;\n\n  var a,\n      b,\n      c,\n      d,\n      e = this.config,\n      f = e.trendLines || e.vTrendLines || e.trendPoints,\n      g = f && f[0] && f[0].line || f && f.point;\n  return e.trendLimits ? e.trendLimits : ((_extent5 = extent(g, function (a) {\n    return '' === a.startvalue ? UNDEF : +a.startvalue;\n  }), _extent6 = _slicedToArray(_extent5, 2), a = _extent6[0], b = _extent6[1], _extent5), (_extent7 = extent(g, function (a) {\n    return '' === a.endvalue ? UNDEF : +a.endvalue;\n  }), _extent8 = _slicedToArray(_extent7, 2), c = _extent8[0], d = _extent8[1], _extent7), e.trendLimits = extent([a, b, c, d], function (b) {\n    return +b;\n  }), e.trendLimits);\n},\n    getPixel = function getPixel(a) {\n  return this.getScale().getRangeValue(a);\n},\n    _drawLabel = function _drawLabel() {\n  var a,\n      b,\n      c,\n      d,\n      e,\n      f,\n      g,\n      h,\n      k,\n      l,\n      m,\n      n = this,\n      o = n.config,\n      p = n.getFromEnv('animationManager'),\n      q = this.getFromEnv('toolTipController'),\n      r = o.axisRange,\n      s = o.labels,\n      t = s.style,\n      u = n.components,\n      v = r.max,\n      w = r.min,\n      x = o.axisContainer,\n      y = o.extremeLabels,\n      z = o.ticks,\n      A = [],\n      B = {\n    fontFamily: t.fontFamily,\n    fontSize: t.fontSize,\n    fontWeight: t.fontWeight,\n    fontStyle: t.fontStyle,\n    lineHeight: t.lineHeight\n  };\n  if (o.labels.isDraw) for (m = u.labels, l = u.labelIndexArr, x.css(B), (b = 0, c = l && l.length); b < c; b += 1) {\n    a = l[b], h = z[a], e = \"\".concat(h).concat(LABEL_ID), d = n.getGraphicalElement(e), g = m[a].config.props.label.attr, d = n.addGraphicalElement(e, p.setAnimation({\n      el: d || 'text',\n      attr: g,\n      container: x,\n      data: {\n        value: h\n      },\n      component: n,\n      label: 'text'\n    })), g.tooltext ? q.enableToolTip(d, g.tooltext) : q.disableToolTip(d), h === v ? y.lastLabel.graphic = d : h === w && (y.firstLabel.graphic = d), A.push(e);\n  }\n\n  for (k = difference(o.prevIntervalArr, A), a = 0, c = k.length; a < c; a++) {\n    f = n.getGraphicalElement(k[a]), f && n.removeGraphicalElement(f);\n  }\n\n  o.prevIntervalArr = A;\n},\n    _parseLabel = function _parseLabel() {\n  var a,\n      b,\n      c,\n      d,\n      e,\n      f,\n      g,\n      h,\n      j,\n      k,\n      l,\n      m,\n      n,\n      o,\n      p,\n      q,\n      r = Math.ceil,\n      s = this,\n      t = s.config,\n      u = s.getLinkedItem('canvas').getEffectiveDimensions(),\n      v = t.axisDimention,\n      w = s.getFromEnv('chart'),\n      x = w.config,\n      y = t.axisRange,\n      z = t.isOpposit,\n      A = t.labels,\n      B = s.components,\n      C = B.labels,\n      D = A.style,\n      E = w.getFromEnv('smartLabel'),\n      F = t.isVertical,\n      G = y.max,\n      H = y.min,\n      I = s.getFromEnv('number-formatter'),\n      J = u.top,\n      K = u.left,\n      L = J + u.height,\n      M = K + u.width,\n      N = t.labelPadding,\n      O = t.extremeLabels,\n      P = F ? v.x : v.y,\n      Q = v.opposite,\n      R = t.labelMaxH,\n      S = t.labelMaxW,\n      T = y.tickInterval,\n      U = Math.abs(s.getPixel(H, queryOptions) - s.getPixel(H + T, queryOptions)),\n      V = [],\n      W = t.ticks,\n      X = 0,\n      Y = t.isReverse,\n      Z = pluckNumber(s.getFromEnv('chart-attrib').showzeroplanevalue),\n      $ = !0,\n      _ = s.getLimit();\n\n  if (E.useEllipsesOnOverflow(x.useEllipsesWhenOverflow), E.setStyle({\n    fontSize: D.fontSize,\n    fontFamily: D.fontFamily,\n    lineHeight: D.lineHeight,\n    fontWeight: D.fontWeight\n  }), d = D.lineHeight, d && -1 !== d.indexOf('px') && (d = parseFloat(d.replace('px', ''))), 0 === Z && ($ = !1), t.labels.isDraw) {\n    if (t.drawLabelsOpposit && (z = !z, P = Q), j = {\n      fill: D.color,\n      \"line-height\": d,\n      \"font-size\": D.fontSize,\n      opacity: 1\n    }, c = t.labels.rotation, F ? (t.labelMaxH > U && !t.tickValues && (g = r(t.labelMaxH / U)), j['text-anchor'] = z ? POSITION_START : POSITION_END) : (t.labelMaxW > U && !t.tickValues && (g = r(t.labelMaxW / U)), c ? (j['text-anchor'] = z ? POSITION_START : POSITION_END, j['vertical-align'] = 'middle') : j['vertical-align'] = z ? POSITION_BOTTOM : POSITION_TOP, l = K, m = x.width - M), g > t.labels.step && (t.labels.step = g), h = t.numberFormatterFn ? I[t.numberFormatterFn] : t.isPercent ? I.percentValue : F ? I.yAxis : I.xAxis, O.firstLabel = {}, O.lastLabel = {}, q = W.filter(function (a, b, c) {\n      return 0 !== a || t.showZeroPlaneValue ? (F || b === c.length - 1 || !(s.getPixel(a, queryOptions) + t.labelMaxW > M)) && (0 == b % t.labels.step ? (V[X++] = b, !0) : !!(t.labels.drawLimitVal && (0 === b || b === c.length - 1)) && (V[X++] = b, !0)) : $ && (!$ || _.max === a || _.min === a) && (V[X++] = b, !0);\n    }), t.isZeroTickForced && -1 !== q.indexOf(0)) {\n      var _a;\n\n      X = 0, V = [], p = s.getPixel(0), q = q.filter(function (b, c, d) {\n        return _a = s.getPixel(b), 0 === d[c + 1] || 0 === d[c - 1] ? F ? !(_a + R >= p && p >= _a - R) && (V[X++] = c, !0) : !(_a + S >= p && p >= _a - S) && (V[X++] = c, !0) : (V[X++] = c, !0);\n      });\n    }\n\n    for (e = (F ? S : U / 2) * t.labels.step, f = F ? U / 2 : R, B.labelIndexArr = V.slice(), (a = 0, b = q.length); a < b; a += 1) {\n      n = q[a], C[V[a]] = C[V[a]] || {\n        config: {\n          props: {\n            label: {}\n          }\n        }\n      }, k = Object.assign({}, j), o = UNDEF, t.labels.drawNormalVal || n === H || n === G ? t.labels.drawLimitVal || n !== H && n !== G ? n === H && t.lowerLimitDisplay && t.labels.drawLimitVal ? (o = E.getSmartText(t.lowerLimitDisplay, e, f + d / 2), k.text = o.text, k.tooltext = o.tooltext) : n === G && t.upperLimitDisplay && t.labels.drawLimitVal ? (o = E.getSmartText(t.upperLimitDisplay, e, f + d / 2), k.text = o.text, k.tooltext = o.tooltext) : (k.text = '' + h.call(I, n, t.axisIndex), o = E.getOriSize(k.text)) : k.text = '' : k.text = '', F ? (k.x = z ? (P || M) + N : (P || K) - N, k.y = s.getPixel(n, queryOptions), (Y && n === H && t.lowerLimitDisplay || !Y && n === G && t.upperLimitDisplay) && o && o.height > d && (k['vertical-align'] = POSITION_BOTTOM), (Y && n === G && t.upperLimitDisplay || !Y && n === H && t.lowerLimitDisplay) && o && o.height > d && (k['vertical-align'] = POSITION_TOP), t.placeValuesInside && (k['text-anchor'] = z ? POSITION_END : POSITION_START)) : (k.x = s.getPixel(n, queryOptions), k.y = z ? (P || J) - N : (P || L) + N, (!Y && n === H || Y && n === G) && o && o.width > 2 * l && (k['text-anchor'] = POSITION_START), (!Y && n === G || Y && n === H) && o && o.width > 2 * m && (k['text-anchor'] = POSITION_END), k['vertical-align'] = t.placeValuesInside ? z ? POSITION_TOP : POSITION_BOTTOM : z ? POSITION_BOTTOM : POSITION_TOP), A.shiftX && (k.x += A.shiftX), A.shiftY && (k.y += A.shiftY), k.transform = getSuggestiveRotation(c, k.x, k.y), C[V[a]].config.props.label.attr = k;\n    }\n  }\n},\n    setTickValues = function setTickValues(a) {\n  var b,\n      c,\n      d = a && a.length,\n      e = this.config,\n      f = e.startPad || 0,\n      g = this.getFromEnv('chart'),\n      h = 0,\n      i = e.tickValues = {},\n      j = i.tickValue = [],\n      k = i.vline = [],\n      l = i.tickIdMap = {},\n      m = e.endPad || 0;\n\n  for (e.hasCategory = 1, b = 0; b < d; b += 1) {\n    c = extend2({}, a[b]), c.vline ? (c.startIndex = j.length - 1, k.push(c)) : (c.id && (l[c.id.toLowerCase()] = {\n      tickObj: c,\n      index: h\n    }), (e.mapTickValuesById && c.id || !e.mapTickValuesById) && (extractStyleInfo(c, g), j.push(c), j[h].label = parseUnsafeString(j[h].label), h += 1));\n  }\n\n  e.oriCatLen = h, this._setAxisRange({\n    max: +toPrecision(h - 1 + m, 10),\n    min: +toPrecision(0 - f, 10),\n    tickInterval: +toPrecision(1, 10)\n  });\n},\n    shiftLabels = function shiftLabels(a, b) {\n  var c = this,\n      d = c.config,\n      e = d.labels;\n  e.shiftX = a, e.shiftY = b;\n},\n    _createContainer = function _createContainer() {\n  var a,\n      b,\n      c,\n      d,\n      e,\n      f = this,\n      g = f.config,\n      h = g.isVertical,\n      i = f.getLinkedParent(),\n      j = i.getChildContainer(),\n      k = j.axisBottomGroup,\n      l = j.axisTopGroup,\n      m = -f.getTranslation(),\n      n = h ? \"T0,\".concat(m) : \"T\".concat(m, \",0\");\n  b = f.createContainer('axisNameGroup', {\n    name: 'dataset-Name-group'\n  }, k), a = f.createContainer('axisLineGroup', {\n    name: 'axis-Line-group'\n  }, l), c = f.createContainer('axisTrendGroupTop', {\n    name: 'dataset-Trend-group-top'\n  }, l), d = f.createContainer('axisLabelGroup', {\n    name: 'dataset-Label-group'\n  }, k), e = f.createContainer('axisLabelGroupTop', {\n    name: 'dataset-Label-group'\n  }, l), f.getGraphicalElement('scrollerContainer') || f.addGraphicalElement('scrollerContainer', f.createGroup('scrollerContainer', {\n    name: 'scroller-container'\n  }, a, 'scroller')), g.axisContainer = f.createGroup('axisContainer', {\n    name: 'dataset-axis',\n    transform: n\n  }, d), g.axisLabelContainerTop = f.createGroup('axisLabelContainerTop', {\n    name: 'dataset-top-label',\n    transform: n\n  }, e), g.axisAxisLineContainer = f.createGroup('axisAxisLineContainer', {\n    name: 'axis-line-tick'\n  }, a), g.axisTrendLabelContainer = f.createGroup('axisTrendLabelContainer', {\n    name: 'dataset-axis-trend-label'\n  }, c), g.axisNameContainer = f.createGroup('axisNameContainer', {\n    name: 'dataset-axis-name'\n  }, b), g.axisAxisLineContainerBottom = f.createGroup('axisAxisLineContainerBottom', {\n    name: 'axis-line-tick-bottom'\n  }, k);\n},\n    setAxisPadding = function setAxisPadding() {\n  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  var c,\n      d = Math.max,\n      e = this,\n      f = e.config,\n      g = e.getScale(),\n      _g$getDomain = g.getDomain(),\n      _g$getDomain2 = _slicedToArray(_g$getDomain, 2),\n      h = _g$getDomain2[0],\n      i = _g$getDomain2[1];\n\n  1 === f.oriCatLen && (0 === a && (a = .5), 0 === b && (b = .5)), c = a - f.startPad, f.startPad = d(f.startPad, a), f.endPad = d(f.endPad, b), 0 < c && (f.setPadding = !0, e._setAxisRange({\n    min: h - c,\n    max: i + c\n  })), !f.tickValues && f.originalMax && f.originalMin && e.setDataLimit(f.originalMax, f.originalMin);\n},\n    getLabel = function getLabel(a) {\n  var b = this,\n      c = b.config,\n      d = c.tickValues && c.tickValues.tickValue[a],\n      e = {};\n  return d && d.tooltext && (e.label = d.label, d.tooltext = parseTooltext(d.tooltext, [3], e)), {\n    label: d && (d.oriLabel || d.label),\n    tooltext: d && d.tooltext\n  };\n};\n\nexport { setAxisDimention, setDataLimit, getTrendLineLimits, getPixel, _drawLabel, setTickValues, shiftLabels, _createContainer, setAxisPadding, getLabel, extractStyleInfo, _parseLabel };","map":null,"metadata":{},"sourceType":"module"}