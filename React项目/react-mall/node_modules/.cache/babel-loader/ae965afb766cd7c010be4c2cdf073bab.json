{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport CartesianLabelManager from './cartesian-label-manager';\nimport range from './utils/array/range';\nimport ScaleCategory from './scales/category';\nimport { toPrecision, UNDEF, parseUnsafeString, pluckNumber, pluck, BLANKSTRING, getDashStyle, preDefStr, extend2, convertColor } from '../lib';\nimport { setTickValues } from './common-api';\nvar DASH_DEF = 'none',\n    TRUE_STRING = 'true',\n    ONE_STRING = '1',\n    POSITION_START = preDefStr.POSITION_START,\n    POSITION_MIDDLE = preDefStr.POSITION_MIDDLE,\n    POSITION_TOP = preDefStr.POSITION_TOP,\n    POSITION_BOTTOM = preDefStr.POSITION_BOTTOM,\n    POSITION_END = preDefStr.POSITION_END,\n    queryOptions = {\n  wrtVisible: !0\n};\n\nvar CategoryAxis =\n/*#__PURE__*/\nfunction (_CartesianLabelManage) {\n  _inherits(CategoryAxis, _CartesianLabelManage);\n\n  function CategoryAxis() {\n    var _this;\n\n    _classCallCheck(this, CategoryAxis);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CategoryAxis).call(this)), _this.config.scale = new ScaleCategory();\n    return _this;\n  }\n\n  _createClass(CategoryAxis, [{\n    key: \"getName\",\n    value: function getName() {\n      return 'category';\n    }\n  }, {\n    key: \"getCategoryFromId\",\n    value: function getCategoryFromId(a) {\n      var b = this.config,\n          c = b.tickValues,\n          d = c && c.tickIdMap;\n      return d[a] || {};\n    }\n  }, {\n    key: \"generateTicks\",\n    value: function generateTicks() {\n      var a = this.getScale(),\n          b = this.config,\n          c = a.getDomain(),\n          d = b.categoryNumDivLines + 1,\n          e = (c[1] - c[0]) / d,\n          f = b.axisRange,\n          g = f.min,\n          h = f.max,\n          i = (h - g) / d;\n      return b._allTicks = range(g, h, i).concat(h), f.tickInterval = i, range(c[0], c[1], e).concat(c[1]);\n    }\n  }, {\n    key: \"_parseCategoryVline\",\n    value: function _parseCategoryVline() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q,\n          r,\n          s,\n          t,\n          u,\n          v,\n          w,\n          x,\n          y,\n          z,\n          A,\n          B,\n          C,\n          D,\n          E,\n          F,\n          G,\n          H = this,\n          I = H.config,\n          J = I.axisRange,\n          K = J.min,\n          L = J.max,\n          M = H.getFromEnv('chart'),\n          N = M.config,\n          O = N.style || {},\n          P = I.isVertical,\n          Q = {\n        fontFamily: N.style.inCanfontFamily,\n        fontSize: N.style.inCanfontSize,\n        color: N.style.inCancolor,\n        lineHeight: N.style.inCanLineHeight\n      };\n\n      for (b = I.tickValues.vline, c = b.length, C = 1 !== H.getZoom(), D = H.getVisibleConfig(), f = 0; f < c; f++) {\n        (d = b[f], e = parseUnsafeString(d.label), g = !!pluckNumber(d.showlabelborder, I.showVLineLabelBorder, 1), a = !!pluckNumber(d.showlabelbackground, 1), h = pluck(d.labelhalign, P ? POSITION_START : POSITION_MIDDLE), 'center' === h ? h = POSITION_MIDDLE : 'left' === h ? h = POSITION_START : 'right' === h && (h = POSITION_END), j = pluck(d.labelvalign, P ? POSITION_MIDDLE : POSITION_BOTTOM).toLowerCase(), j === POSITION_MIDDLE ? j = POSITION_MIDDLE : j === POSITION_TOP ? j = POSITION_BOTTOM : j === POSITION_BOTTOM && (j = POSITION_TOP), k = pluckNumber(d.labelposition, 0), l = pluckNumber(d.lineposition, .5), m = pluckNumber(d.showvlines, I.showVLines, 1), n = pluckNumber(d.alpha, I.vLineAlpha, 80), o = pluck(d.color, I.vLineColor).replace(/^#?/, '#'), p = a ? pluck(d.labelbgcolor, I.vLineLabelBgColor, '333333').replace(/^#?/, '#') : BLANKSTRING, y = pluck(d.labelcolor, I.vLineLabelColor, d.color, O.inCancolor, I.vLineColor).replace(/^#?/, '#'), q = pluckNumber(d.thickness, I.vLineThickness, 1), A = 2, r = !!+pluck(d.dashed, 0), s = pluckNumber(d.dashlen, 5), u = pluckNumber(d.dashgap, 2), t = Q.fontSize, t = parseInt(t.replace(/px/i, ''), 10), z = pluckNumber(d.rotatelabel, I.rotateVLineLabels) ? 270 : 0, l = 0 > l || 1 < l ? .5 : l, k = 0 > k || 1 < k ? 0 : k, o = convertColor(o, m ? n : '0'), G = d.animate && !P ? d.startIndex + 1 : d.startIndex, B = H._getVlinePos(G, l) - (d.animate ? d.leftShift : 0), !(C && (B < D.minValue || B > D.maxValue))) && (B < K || B > L || (v = {\n          opacity: 1,\n          stroke: o,\n          \"stroke-width\": q,\n          \"stroke-dasharray\": r ? getDashStyle(s, u) : DASH_DEF\n        }, x = {\n          opacity: 1,\n          text: e,\n          \"text-anchor\": h,\n          \"vertical-align\": j,\n          \"text-bound\": []\n        }, w = {\n          fontSize: Q.fontSize,\n          fontFamily: Q.fontFamily,\n          lineHeight: Q.lineHeight\n        }, F = pluckNumber(d.showontop, I.showVLinesOnTop, 0), E = {\n          from: B,\n          layer: F ? 3 : 2,\n          attr: v,\n          type: 'line',\n          startIndex: d.startIndex,\n          linePosition: l\n        }, e && (x['text-bound'] = [p, m && g ? o : BLANKSTRING, m && g ? 1 : 0, A, UNDEF, m && g ? 'solid' : BLANKSTRING], x.fill = m ? y : o, E.text = {\n          label: e,\n          attr: x,\n          layer: 4,\n          labelRotation: z,\n          labelPosition: k,\n          css: w\n        }), H.setReferenceInfo(E), H.config.parsedVlineInfo.push(E)));\n      }\n    }\n  }, {\n    key: \"_parseReferenceVisuals\",\n    value: function _parseReferenceVisuals() {\n      _get(_getPrototypeOf(CategoryAxis.prototype), \"_parseReferenceVisuals\", this).call(this), this.config.drawPlotlines && this._parseCategoryVline();\n    }\n  }, {\n    key: \"categoryInsert\",\n    value: function categoryInsert(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h,\n          j = this,\n          k = j.config,\n          l = k.axisRange.min,\n          m = b.length,\n          n = k.endPad || 0;\n\n      for (d = k.tickValues.tickValue, f = k.tickValues.tickIdMap, e = k.tickValues.vline, g = 0; g < m; g += 1) {\n        h = extend2({}, b[g]), h.vline === TRUE_STRING || !0 === h.vline || 1 === h.vline || h.vline === ONE_STRING ? (h.startIndex = a - 2, e.push(h)) : (h.id && (f[h.id] = {\n          tickObj: h,\n          i: a\n        }), d.splice(a, 0, h), a += 1);\n      }\n\n      c && j._setAxisRange({\n        min: l,\n        max: +toPrecision(d.length - 1 + n, 10)\n      });\n    }\n  }, {\n    key: \"categoryDelete\",\n    value: function categoryDelete(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h = this,\n          j = h.config,\n          k = j.axisRange,\n          l = k.min;\n\n      for (d = j.tickValues.vline, e = 0, f = d.length; e < f; e++) {\n        d[e].animate = !0, d[e].leftShift = b;\n      }\n\n      g = j.tickValues.tickValue, g.splice(a, b), h._shiftVline(a, b, 'left'), c && h._setAxisRange({\n        min: l,\n        max: k.max - b\n      });\n    }\n  }, {\n    key: \"_shiftVline\",\n    value: function _shiftVline(a, b, c) {\n      var d,\n          e,\n          f = this,\n          g = f.config,\n          h = g.tickValues.vline,\n          j = g.tickValues.tickValue.length,\n          k = h.length;\n\n      for (d = 0; d < k; d += 1) {\n        e = h[d], e.startIndex >= a && ('right' === c ? e.startIndex += b : e.startIndex -= b, (0 > e.startIndex || e.startIndex >= j) && (h.splice(d, 1), k -= 1, d -= 1));\n      }\n    }\n  }, {\n    key: \"categoryTranslate\",\n    value: function categoryTranslate(a) {\n      var b,\n          c = this,\n          d = c.config,\n          e = c.getPixel(1, queryOptions) - c.getPixel(0, queryOptions);\n      a = (a || 0) * e, d.isReverse && (a = -a), b = ['T', a, ',', '0'].join(''), c.realTimeTranslatableGroups = [{\n        group: d.axisContainer,\n        translationStr: b\n      }, {\n        group: d.axisTrendLabelContainer,\n        translationStr: b\n      }];\n    }\n  }, {\n    key: \"updateTicksValues\",\n    value: function updateTicksValues(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k = this,\n          l = k.config,\n          m = l.parsedVlineInfo;\n      if (c = l.tickValues.tickValue, c[a]) for (j in b) {\n        b.hasOwnProperty(j) && ('x' === j && (d = !0), c[a][j] = b[j]);\n      }\n      if (d) for (f = 0, g = m.length; f < g; ++f) {\n        if (e = m[f], h = e.startIndex, h === a) e.from = k._getVlinePos(h, e.linePosition);else if (h + 1 === a) {\n          e.from = k._getVlinePos(h, e.linePosition);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"_getVlinePos\",\n    value: function _getVlinePos(a, b) {\n      var c,\n          d,\n          e,\n          f = this.getTickValues(),\n          g = this.config,\n          _this$getLimit = this.getLimit(),\n          h = _this$getLimit.min,\n          i = _this$getLimit.max,\n          j = f[a],\n          k = f[a + 1];\n\n      return j ? !k && (c = f[0] && f[0].x ? i : g.oriCatLen - 1, e = !0) : (c = f[0] && f[0].x ? h : -1, e = !0), e ? d = b : (c = pluckNumber(j.x, j.y, a), d = (c - pluckNumber(k.x, k.y, a + 1)) * b), c + Math.abs(d);\n    }\n  }, {\n    key: \"getInterval\",\n    value: function getInterval() {\n      if (this) return 1;\n    }\n  }, {\n    key: \"_setAxisRange\",\n    value: function _setAxisRange(a) {\n      var b,\n          c,\n          d = a.min,\n          e = a.max,\n          f = this.config,\n          g = f.axisRange,\n          h = f.periodLength,\n          i = f.dataLimit,\n          j = i.max,\n          k = i.min;\n      d > e || ((j !== e || k !== d) && (b = !0), f.visibleMin === UNDEF || f.setPadding || b ? (i.max = e, i.min = d, h && (f.categoryNumDivLines = (e - d) / h - 1), c = (e - d) / (f.categoryNumDivLines + 1), this.getScale().setDomain([d, e]), f.ticks = range(d, e, c).concat(e), f._allTicks = f.ticks.slice(), g.min = d, g.max = e, g.tickInterval = c, this.setVisibleConfig(g.min, g.max)) : f.setPadding = !1);\n    }\n  }]);\n\n  return CategoryAxis;\n}(CartesianLabelManager);\n\nCategoryAxis.prototype.setTickValues = setTickValues;\nexport default CategoryAxis;","map":null,"metadata":{},"sourceType":"module"}