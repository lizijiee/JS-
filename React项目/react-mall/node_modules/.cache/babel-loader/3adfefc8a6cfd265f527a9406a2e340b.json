{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport Entities from '../entities';\nimport KdTree from '../../../../fc-charts/src/dataset/_internal/kdtree';\nimport Annotation from '../../../../fc-features/src/annotation/ext-annotation';\nimport { addDep } from '../../../../fc-core/src/dependency-manager';\nimport mapsAnimation from '../_internal/map-entities.animation';\nimport { pluck, extend2, parseTooltext, pluckNumber, parseUnsafeString } from '../../../../fc-core/src/lib';\nimport { raiseEventGroup } from '../../../../fc-core/src/event-api';\nimport { priorityList } from '../../../../fc-core/src/schedular';\n\nvar UNDEF,\n    BLANK = '',\n    POSITION_TOP = 'top',\n    POSITION_BOTTOM = 'bottom',\n    POSITION_RIGHT = 'right',\n    POSITION_LEFT = 'left',\n    POSITION_MIDDLE = 'middle',\n    POSITION_CENTER = 'center',\n    INNERRADIUSFACTOR = .6,\n    math = window.Math,\n    mathMin = math.min,\n    mathMax = math.max,\n    MARKER_ITEM_KEY = 'items',\n    hoverFn = function hoverFn() {\n  var a,\n      b = this,\n      c = b.dataset.getFromEnv('chart'),\n      d = b.dataset.getChildren('mapAnnotations')[0],\n      e = b.markerShape,\n      f = e.groupConfig,\n      g = e.data('unfilteredConfig'),\n      h = g._markerEventArgs,\n      i = b.config;\n  g.hovereffect && ('circle' === e.config.type && (a = extend2({\n    fillcolor: g.hoverfillcolor,\n    fillalpha: g.hoverfillalpha,\n    fillangle: g.hoverfillangle,\n    fillratio: g.hoverfillratio,\n    gradientUnits: 'objectBoundingBox',\n    radialGradient: 1\n  }, g._hoverattrs)), a = extend2({}, g._hoverattrs), d.update(e.getId(), a)), h || (h = g._markerEventArgs = {\n    x: +g.x,\n    y: +g.y,\n    scaledX: g.x * f.scaleX,\n    scaledY: g.y * f.scaleY,\n    chartX: g.x * f.scaleX + f.grpXShift,\n    chartY: g.y * f.scaleY + f.grpYShift,\n    id: g.id,\n    label: g.label\n  }), raiseEventGroup(i.options.id, 'markerRollOver', h, c.getFromEnv('chartInstance'), i, UNDEF, UNDEF, UNDEF);\n},\n    hoverOutFn = function hoverOutFn() {\n  var a,\n      b = this,\n      c = b.dataset.getFromEnv('chart'),\n      d = b.dataset.getChildren('mapAnnotations')[0],\n      e = b.markerShape,\n      f = e.getElement(),\n      g = b.config,\n      h = e.data('unfilteredConfig');\n  f && h.hovereffect && ('circle' === e.config.type && (a = extend2({\n    fillcolor: e.config.rawColor,\n    fillalpha: e.config.rawAlpha,\n    fillangle: e.config.rawAngle,\n    fillratio: e.config.rawRatio,\n    gradientUnits: 'objectBoundingBox',\n    radialGradient: 'radial' === e.config.rawFillPattern\n  }, h._defaultattrs)), a = extend2({}, h._defaultattrs), d.update(e.getId(), a)), raiseEventGroup(g.id, 'markerRollOut', h._markerEventArgs, c.getFromEnv('chartInstance'), UNDEF, UNDEF, UNDEF);\n},\n    clickFn = function clickFn(a) {\n  var b = this,\n      c = b.config.options,\n      d = b.dataset,\n      e = d.getFromEnv('chart'),\n      f = b.markerShape,\n      g = f.config,\n      h = f.groupConfig,\n      i = d.getFromEnv('linkClickFN'),\n      j = f.config.link,\n      k = g._markerEventArgs;\n  j && i && i.call({\n    link: j\n  }, !0), k || (k = g._markerEventArgs = {\n    x: +g.x,\n    y: +g.y,\n    scaledX: g.x * h.scaleX,\n    scaledY: g.y * h.scaleY,\n    chartX: g.x * h.scaleX + h.grpXShift,\n    chartY: g.y * h.scaleY + h.grpYShift,\n    id: c.id,\n    label: c.label\n  }), e.fireChartInstanceEvent('markerClick', k, a);\n},\n    convertToObj = function convertToObj(a, b) {\n  var c,\n      d = a && a.length || !1,\n      e = b || 'id',\n      f = {};\n  if (!a) return a;\n\n  for (; d--;) {\n    c = a[d], c[e] !== UNDEF && (f[c[e].toLowerCase()] = c);\n  }\n\n  return f;\n};\n\naddDep({\n  name: 'mapsAnimation',\n  type: 'animationRule',\n  extension: mapsAnimation\n});\n\nvar Markers =\n/*#__PURE__*/\nfunction (_Entities) {\n  _inherits(Markers, _Entities);\n\n  function Markers() {\n    var _this;\n\n    _classCallCheck(this, Markers);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Markers).call(this)), _this.components = {}, _this.getLabelAlignment = {\n      top: function top(a, b, c) {\n        return {\n          x: a.toString(),\n          y: (b - c).toString(),\n          align: POSITION_CENTER,\n          valign: POSITION_TOP\n        };\n      },\n      left: function left(a, b, c) {\n        return {\n          x: (a - c).toString(),\n          y: b.toString(),\n          align: POSITION_RIGHT,\n          valign: POSITION_MIDDLE\n        };\n      },\n      right: function right(a, b, c) {\n        return {\n          x: (a + c).toString(),\n          y: b.toString(),\n          align: POSITION_LEFT,\n          valign: POSITION_MIDDLE\n        };\n      },\n      bottom: function bottom(a, b, c) {\n        return {\n          x: a.toString(),\n          y: (b + c).toString(),\n          align: POSITION_CENTER,\n          valign: POSITION_BOTTOM\n        };\n      },\n      center: function center(a, b) {\n        return {\n          x: a.toString(),\n          y: b.toString(),\n          align: POSITION_CENTER,\n          valign: POSITION_MIDDLE\n        };\n      }\n    }, _this.getWrapWidth = {\n      right: function right() {\n        return arguments[1];\n      },\n      left: function left(a, b) {\n        return a - b;\n      },\n      center: function center(a, b) {\n        return 2 * mathMin(b, a - b);\n      }\n    }, _this.getWrapHeight = {\n      top: function top() {\n        return arguments[1];\n      },\n      middle: function middle(a, b) {\n        return 2 * mathMin(b, a - b);\n      },\n      bottom: function bottom(a, b) {\n        return a - b;\n      }\n    }, _this.hoverFn = hoverFn, _this.hoverOutFn = hoverOutFn, _this.clickFn = clickFn;\n    return _this;\n  }\n\n  _createClass(Markers, [{\n    key: \"getName\",\n    value: function getName() {\n      return 'markers';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'dataset';\n    }\n  }, {\n    key: \"configureAttributes\",\n    value: function configureAttributes(a) {\n      if (!a) return;\n      this.JSONData = a;\n      var b,\n          c = this,\n          d = c.getChildren('mapAnnotations') && c.getChildren('mapAnnotations')[0],\n          e = c.getFromEnv('chart'),\n          f = e.config.markerOpts;\n      d || (b = new Annotation(), c.attachChild(b, 'mapAnnotations'), d = c.getChildren('mapAnnotations')[0]), d.destroy(), c.calculateDataLimits(), f.dataEnabled ? this._parseMarkers() : this.defineMarkersNShapes(), this.configureConnectors();\n    }\n  }, {\n    key: \"calculateMarkerRadiusLimits\",\n    value: function calculateMarkerRadiusLimits() {\n      if (this.JSONData) {\n        var a = this,\n            b = a.JSONData,\n            c = a.config,\n            d = a.getFromEnv('chart'),\n            e = d.config.width,\n            f = d.config.height,\n            g = b.markermaxradius,\n            h = b.markerminradius,\n            i = Markers.getMarkerRadiusLimits(e, f, g, h);\n        c.minRadius = i.min, c.maxRadius = i.max;\n      }\n    }\n  }, {\n    key: \"calculateDataLimits\",\n    value: function calculateDataLimits() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f = this,\n          g = f.getFromEnv('chart'),\n          h = f.config,\n          j = g.jsonData,\n          k = j.markers || {},\n          l = k[MARKER_ITEM_KEY] || [],\n          m = this.getFromEnv('number-formatter'),\n          n = +Infinity,\n          o = -Infinity;\n\n      for (e = 0, c = l.length; e < c; e++) {\n        a = l[e], d = a.value, b = m.getCleanValue(d), null !== b && (n = mathMin(b, n), o = mathMax(b, o));\n      }\n\n      h.min = n, h.max = o;\n    }\n  }, {\n    key: \"_parseMarkers\",\n    value: function _parseMarkers() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j = this,\n          k = j.getFromEnv('chart'),\n          l = k.jsonData,\n          m = l.markers,\n          n = m[MARKER_ITEM_KEY],\n          o = m.shapes,\n          p = k.config.markerOpts,\n          q = this.getFromEnv('number-formatter'),\n          r = j.components.shapeObjs = {},\n          s = j.components.markerObjs = {};\n\n      if (n && n.length) {\n        if (o && o.length) for (b = o.length; b; b -= 1) {\n          d = o[b - 1], (h = d.id.toLowerCase()) && (r[h] = d);\n        }\n\n        for (b = n.length; b--;) {\n          d = n[b], (h = d.id && d.id.toLowerCase()) && (a = d.value, a !== UNDEF && '' !== a && (a = parseFloat(a)), c = Markers._initializeMarkerItem(h, d, null, k), e = c.config.options.shapeid, e && 'string' == typeof e && (e = e.toLowerCase()), f = c.config, g = f.options, f.cleanValue = q.getCleanValue(a), f.formattedValue = null === f.cleanValue ? UNDEF : q.dataLabels(a), f.fillColor = pluck(g.fillcolor, g.color, p.fillColor), f.fillAlpha = pluck(g.fillalpha, g.alpha, p.fillAlpha), f.fillRatio = pluck(g.fillratio, p.fillRatio), f.fillAngle = pluck(g.fillangle, p.fillAngle), f.borderThickness = pluckNumber(g.borderthickness, p.borderThickness), f.borderColor = pluck(g.bordercolor, p.borderColor), f.borderAlpha = pluck(g.borderalpha, p.borderAlpha), f.labelPadding = g.labelpadding || p.labelPadding, c.dataset = j, d.__hideMarker && (c._isHidden = !0), e && (c.shapeObj = r[e]), s[h] = c);\n        }\n      }\n    }\n  }, {\n    key: \"defineMarkersNShapes\",\n    value: function defineMarkersNShapes() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j = this,\n          k = j.getFromEnv('chart'),\n          l = k.jsonData,\n          m = l.markers,\n          n = m.definition,\n          o = this.getFromEnv('number-formatter'),\n          p = k.config.markerOpts,\n          q = convertToObj(n) || {},\n          r = convertToObj(m.application) || {},\n          s = m.shapes,\n          t = j.components.shapeObjs = j.components.shapeObjs || (j.components.shapeObjs = {}),\n          u = j.components.markerObjs = j.components.markerObjs || (j.components.markerObjs = {}),\n          v = {},\n          w = {};\n\n      if (n && n.length) {\n        for (d in t) {\n          v[d] = !1;\n        }\n\n        for (d in u) {\n          w[d] = !1;\n        }\n\n        if (s && s.length) for (d = s.length; d; d -= 1) {\n          f = s[d - 1], (h = f.id.toLowerCase()) && (t[h] = f, v[h] = !0);\n        }\n\n        for (h in q) {\n          f = q[h], e = u[h] = Markers._initializeMarkerItem(h, f, r[h], k), w[h] = !0, e.dataset = j, g = e.config.options.shapeid, b = e.config, c = f.value, b.cleanValue = o.getCleanValue(c), a = b.options, b.formattedValue = null === b.cleanValue ? UNDEF : o.dataLabels(c), b.fillColor = pluck(a.fillcolor, a.color, p.fillColor), b.fillAlpha = pluck(a.fillalpha, a.alpha, p.fillAlpha), b.fillRatio = pluck(a.fillratio, p.fillRatio), b.fillAngle = pluck(a.fillangle, p.fillAngle), b.borderThickness = pluckNumber(a.borderthickness, p.borderThickness), b.borderColor = pluck(a.bordercolor, p.borderColor), b.borderAlpha = pluck(a.borderalpha, p.borderAlpha), b.labelPadding = a.labelpadding || p.labelPadding, b.options.tooltext = pluck(a.tooltext, p.tooltext), b.link = a.link, g && (e.shapeObj = t[g.toLowerCase()]);\n        }\n\n        for (d in v) {\n          v[d] || delete t[d];\n        }\n\n        for (d in u) {\n          w[d] || delete u[d];\n        }\n      }\n    }\n  }, {\n    key: \"getDataLimits\",\n    value: function getDataLimits() {\n      var a = this,\n          b = a.config;\n      return {\n        min: b.min,\n        max: b.max\n      };\n    }\n  }, {\n    key: \"configureConnectors\",\n    value: function configureConnectors() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q = this,\n          r = q.getFromEnv('chart'),\n          s = q.getChildren('mapAnnotations')[0],\n          t = r.jsonData,\n          u = q.components,\n          v = t.markers || {},\n          w = v.connector || v.connectors || [],\n          x = u.markerObjs,\n          y = w.length,\n          z = q.components.connectors,\n          A = function A(a) {\n        return function (b) {\n          var c = this,\n              d = c.data('unfilteredConfig');\n          d.hoverEffect && s.update(c.getId(), d._hoverAttrs), r.fireChartInstanceEvent('connectorrollover', a, b);\n        };\n      },\n          B = function B(a) {\n        return function (b) {\n          var c = this,\n              d = c.data('unfilteredConfig');\n          d.hoverEffect && s.update(c.getId(), d._defaultAttrs), r.fireChartInstanceEvent('connectorrollout', a, b);\n        };\n      },\n          C = function C(a) {\n        return function (b) {\n          r.fireChartInstanceEvent('connectorClick', a, b);\n        };\n      },\n          D = r.config.connectorOpts,\n          E = {};\n\n      for (z = q.components.connectors = [], p = 0; p < y; p++) {\n        (o = w[p], o.from || o.to) && (c = x[o.from.toLowerCase()], d = x[o.to.toLowerCase()], c && d) && (e = w[p].label, E = z[p], E || (E = z[p] = {}), E.config || (a = E.config = {}), E.graphics || (E.graphics = {}), a = E.config = extend2({}, o), a.fromMarker = c, a.toMarker = d, a.link = o.link, a.showTooltip = pluckNumber(o.showtooltip, D.showTooltip), f = a.tooltext = a.showTooltip ? pluck(o.tooltext, D.tooltext) : BLANK, g = a.thickness = pluck(o.thickness, D.thickness), h = a.color = pluck(o.color, D.color), j = a.alpha = pluck(o.alpha, D.alpha), a.hoverEffect = pluckNumber(o.showhovereffect, D.showHoverEffect), k = pluck(o.hovercolor, D.hoverColor, h), l = pluck(o.hoveralpha, D.hoverAlpha, j), m = pluck(o.hoverthickness, D.hoverThickness, g), a.dashed = pluck(o.dashed, D.dashed), a.dashLen = pluckNumber(o.dashlen, D.dashlen), a.dashGap = pluckNumber(o.dashgap, D.dashgap), f && (a.tooltext = f = parseUnsafeString(parseTooltext(f, [3, 40, 41, 42, 43], {\n          label: e,\n          fromId: c.config.definition.id,\n          toId: d.config.definition.id,\n          fromLabel: c.config.definition.label,\n          toLabel: d.config.definition.label\n        }, b))), a.eventArgs = {\n          fromMarkerId: c.config.id,\n          toMarkerId: d.config.id,\n          label: e\n        }, a._hoverAttrs = {\n          color: k,\n          alpha: l,\n          thickness: m\n        }, a._defaultAttrs = {\n          color: h,\n          alpha: j,\n          thickness: g\n        }, a.type = 'line', a.onclick = C(a.eventArgs), a.onmouseover = A(a.eventArgs), a.onmouseout = B(a.eventArgs), e && (n = E.labelConfig, !n && (n = E.labelConfig = {}), n.type = 'text', n.text = e, n.align = POSITION_CENTER, n.valign = POSITION_MIDDLE, n.font = D.font, n.fillcolor = D.fontColor, n.bgcolor = D.labelBgColor, n.bordercolor = D.labelBorderColor, n.tooltext = a.tooltext));\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h = this,\n          i = h.getFromEnv('chart'),\n          j = h.config,\n          k = h.getChildren('mapAnnotations')[0],\n          l = h.components.markerObjs,\n          m = i.config,\n          n = m.markerOpts,\n          o = m.scalingParams,\n          p = i.config.annotationConfig,\n          q = [],\n          r = [],\n          s = {};\n\n      for (e in h.createContainer(), h._drawConnectors(), h.imageLoadCount = 0, h.imageCount = 0, g = k.addGroup(Object.assign(p, {\n        id: 'markers',\n        fillalpha: '100',\n        items: q,\n        scaleimages: 1\n      }), h), f = k.addGroup(Object.assign(p, {\n        id: 'markerLabels',\n        items: r,\n        scaleimages: 1\n      }), h), h.components.markerGroup = g, h.components.markerLabelGroup = f, j.autoScale = n.autoScale ? o.sFactor : 1, l) {\n        (a = null, b = l[e], d = b.config, d.conIsHidden || (a = this._drawMarkerItem.call(b)), !!a) && (d._annotationIndex = q.length, s[e] = b, a.markerShape && (c = Object.assign({\n          align: 'center',\n          valign: 'middle',\n          animationLabel: 'markerItem',\n          autoscale: 'image' === a.markerShape.type ? 0 : 1\n        }, a.markerShape), b.markerShape = k.addItem(g.getId(), c, h)), b.markerShape.data('unfilteredConfig', c), q.push(b.markerShape), a.markerLabel && (c = Object.assign({\n          animationLabel: 'markerItem'\n        }, a.markerLabel), b.markerLabel = k.addItem(f.getId(), c, h), b.markerLabel.data('unfilteredConfig', c)), r.push(b.markerLabel));\n      }\n\n      h.addJob('buildKdtree', h._buildKdTree.bind(h), priorityList.kdTree);\n    }\n  }, {\n    key: \"_buildKdTree\",\n    value: function _buildKdTree() {\n      var a,\n          b,\n          c = this,\n          d = c.components.kdArrayMap,\n          e = c.components.markerGroup,\n          f = [],\n          g = e && e.items,\n          h = g && g.length || 0;\n\n      for (b = 0; b < h; b++) {\n        a = g[b].config.id, d[a] && f.push(d[a]);\n      }\n\n      c.components.kDTree || (c.components.kDTree = new KdTree(!0)), c.components.kDTree._setSearchLimit(1 / 0, 1 / 0), c.components.kDTree.buildKdTree(f);\n    }\n  }, {\n    key: \"_drawMarkerItem\",\n    value: function _drawMarkerItem() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q,\n          r,\n          s = this,\n          t = s.dataset,\n          u = t.getFromEnv('chart'),\n          v = u.config,\n          w = t.config,\n          x = v.scalingParams,\n          y = s.config,\n          z = y.options,\n          A = y.definition,\n          B = v.markerOpts,\n          C = B.dataLabels.style,\n          D = z.shapeid,\n          E = z.scale || 1,\n          F = z.label || BLANK,\n          G = u.config.scalingParams.scaleFactor * u.config.baseScaleFactor,\n          H = (z.labelpos || POSITION_TOP).toLowerCase(),\n          I = y.formattedValue === UNDEF ? UNDEF : y.formattedValue,\n          J = z.tooltext || B.tooltext,\n          K = pluckNumber(A.radius, y.radius, B.radius) * E * w.autoScale || 1e-4,\n          L = y.fillColor,\n          M = y.fillAlpha,\n          N = y.fillRatio,\n          O = y.fillAngle,\n          P = y.borderThickness,\n          Q = y.borderColor,\n          R = y.borderAlpha,\n          S = t.getChildren('mapAnnotations')[0],\n          T = t.components.kdArrayMap || (t.components.kdArrayMap = {}),\n          U = s.config.id;\n      if (y.autoScale = B.autoScale ? G : 1, !!D) return (J = J ? parseUnsafeString(parseTooltext(J, [1, 2, 3], {\n        formattedValue: I,\n        label: F\n      }, z)) : I ? F + B.tooltipSepChar + I : F, I !== UNDEF && null !== I ? F = F + B.labelSepChar + I : isNaN(E) ? E = 1 : 0 > E ? E = 0 : 5 < E && (E = 5), extend2(z, {\n        x: z.x && z.x.toString(),\n        y: z.y && z.y.toString(),\n        fillcolor: L,\n        fillalpha: M,\n        fillratio: N,\n        fillangle: O,\n        borderthickness: P,\n        bordercolor: Q,\n        borderalpha: R,\n        hovereffect: pluck(B.showHoverEffect),\n        radius: K && K.toString(),\n        link: z.link,\n        showshadow: pluckNumber(z.showshadow, y.shadow),\n        _markerLabel: F,\n        _markerId: z.id,\n        id: (z.id + BLANK).toLowerCase()\n      }), delete z.tooltext, y.tooltext = !!B.showTooltip && J, m = +z.x * x.sFactor + x.translateX, n = +z.y * x.sFactor + x.translateY, K = z.radius, 'triangle' === D ? (extend2(z, {\n        type: 'polygon',\n        sides: 3,\n        startangle: B.startAngle\n      }), r = 'polygon', q = 3) : 'diamond' === D ? (extend2(z, {\n        type: 'polygon',\n        sides: 4,\n        startangle: B.startAngle\n      }), r = 'polygon', q = 4) : 'arc' === D ? (p = K * INNERRADIUSFACTOR, extend2(z, {\n        type: 'arc',\n        startangle: 0,\n        endangle: 360,\n        innerradius: p\n      }), r = 'arc') : 'circle' === D ? (z.type = 'circle', r = 'circle') : (k = t.getShapeArgs.call(s), B.dataEnabled && B.valueToRadius && z.radius !== UNDEF ? delete k.radius : (!k.radius && (k.radius = B.radius), k.radius *= E * y.autoScale), extend2(z, k), z.id = z._markerId && z._markerId.toLowerCase(), p = k.innerradius, k.radius && (K = k.radius), r = k.type && k.type.toLowerCase(), q = k.sides, K = +K, K && p && K < p && (l = K, z.radius = K = p, z.innerradius = p = l)), z.type = z.type && z.type.toLowerCase(), extend2(z, {\n        hoverfillcolor: pluck(z.fillhovercolor, B.hoverFillColor, z.fillcolor),\n        hoverfillalpha: pluck(z.fillhoveralpha, B.hoverFillAlpha, z.fillalpha),\n        hoverfillratio: pluck(z.fillhoverratio, B.hoverFillRatio, z.fillratio),\n        hoverfillangle: pluck(z.fillhoverangle, B.hoverFillAngle, z.fillangle),\n        hoverborderthickness: pluckNumber(z.borderhoverthickness, B.hoverBorderThickness, z.borderthickness),\n        hoverbordercolor: pluck(z.borderhovercolor, B.hoverBorderColor, z.bordercolor),\n        hoverborderalpha: pluck(z.borderhoveralpha, B.hoverBorderAlpha, z.borderalpha)\n      }), z._hoverattrs = {\n        fillalpha: z.hoverfillalpha,\n        fillcolor: z.hoverfillcolor,\n        fillangle: z.hoverfillangle,\n        fillratio: z.hoverfillratio,\n        borderThickness: '0' === z.showborder ? 0 : z.hoverborderthickness,\n        borderColor: z.hoverbordercolor,\n        borderAlpha: z.hoverborderalpha\n      }, z._defaultattrs = {\n        fillalpha: z.fillalpha,\n        fillcolor: z.fillcolor,\n        fillangle: z.fillangle,\n        fillratio: z.fillratio,\n        borderThickness: '0' === z.showborder ? 0 : z.borderthickness,\n        borderColor: z.bordercolor,\n        borderAlpha: z.borderalpha\n      }, 'image' === z.type ? (z.borderthickness = z.borderthickness || 0, z.onload = function (a) {\n        var b = this,\n            c = a.width,\n            d = a.height;\n        o = {}, z = b.config, m = (+z.derivedX - c / (2 * x.sFactor)) * x.sFactor, n = (+z.derivedY - d / (2 * x.sFactor)) * x.sFactor, o = T[U] || (T[U] = {}), o.x = m + x.translateX, o.y = n + x.translateY, o.element = s, o.shapeInfo = {\n          type: 'rect',\n          width: c,\n          height: d\n        }, c && d && S.update(b.getId(), {\n          x: m,\n          y: n,\n          width: c,\n          height: d,\n          autoscale: 0\n        }), t.imageLoadCount++, t.imageLoadCount === t.imageCount && t._buildKdTree();\n      }, z.onerror = function () {\n        t.imageLoadCount++, t.imageLoadCount === t.imageCount && t._buildKdTree();\n      }, t.imageCount++) : (o = T[U] || (T[U] = {}), o.x = m, o.y = n, o.element = s, o.shapeInfo = {\n        type: r,\n        sides: q,\n        radius: +K + z.borderthickness / 2,\n        innerradius: p\n      }), y.drawOptions.shape = z, !B.showLabels) ? {\n        markerShape: z\n      } : (j = z.labelpadding || B.labelPadding, a = t._getLabelOptions(H, j, z), b = a.align, c = a.valign, d = y._labelBaseWidth, e = y._labelBaseHeight, f = y._labelXOffset, g = y._labelYOffset, h = B.labelWrapWidth ? B.labelWrapWidth : t.getWrapWidth[b](d, +a.x + f), i = B.labelWrapHeight ? B.labelWrapHeight : t.getWrapHeight[c](e, +a.y + g), h > j && (h -= j), i > j && (i -= j), y.drawOptions.label = 'center' === b && 'middle' === c ? extend2({\n        type: 'text'\n      }, {\n        text: F,\n        tooltext: z.tooltext,\n        x: a.x,\n        y: a.y,\n        align: b,\n        valign: a.valign,\n        wrap: 1,\n        wrapwidth: h,\n        wrapheight: i,\n        fontsize: C.fontSize / x.sFactor,\n        font: C.fontFamily,\n        fillcolor: C.fontColor\n      }) : extend2({\n        type: 'text'\n      }, {\n        text: F,\n        tooltext: z.tooltext,\n        x: a.x,\n        y: a.y,\n        align: b,\n        valign: a.valign,\n        wrap: 1,\n        wrapwidth: h,\n        wrapheight: i,\n        fontsize: C.fontSize / x.sFactor,\n        font: C.fontFamily,\n        fillcolor: C.fontColor\n      }), {\n        markerShape: z,\n        markerLabel: y.drawOptions.label\n      });\n    }\n  }, {\n    key: \"highlightPoint\",\n    value: function highlightPoint(a, b) {\n      var c = a.element,\n          d = this,\n          e = b.originalEvent,\n          f = d.getFromEnv('chart'),\n          g = d.getFromEnv('toolTipController'),\n          h = d.config.currentToolTip,\n          i = f.config.lastHoveredPoint;\n      i && i !== a && (i && d.hoverOutFn.call(i.element), f.config.lastHoveredPoint = null, g.hide(h));\n      !1 === a || ('click' === b.type || 'touchstart' === b.type ? (f.config.lastHoveredPoint !== a && d.hoverFn.call(c), d.clickFn.call(c, b)) : 'mousemove' === b.type && f.config.lastHoveredPoint !== a && d.hoverFn.call(c), c.config.tooltext && (h ? g.draw(e, c.config.tooltext, h) : h = d.config.currentToolTip = g.draw(e, c.config.tooltext)), f.config.lastHoveredPoint = a);\n    }\n  }, {\n    key: \"_drawConnectors\",\n    value: function _drawConnectors() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l = this,\n          m = l.getFromEnv('chart'),\n          n = m.config.annotationConfig,\n          o = l.components,\n          p = o.connectors || (l.components.connectors = []),\n          q = p.length,\n          r = m.config.scalingParams,\n          s = m.config.connectorOpts,\n          t = s.showLabels,\n          u = l.getChildren('mapAnnotations')[0],\n          v = [],\n          w = [],\n          z = [];\n\n      for (z.push({\n        id: 'connectorLabels',\n        fillalpha: '100',\n        items: w\n      }), z.push({\n        id: 'connectors',\n        fillalpha: '100',\n        items: v\n      }), u.addGroup(Object.assign(n, z[1]), l), u.addGroup(Object.assign(n, z[0]), l), c = 0; c < q; c++) {\n        p[c] && (h = p[c].config.fromMarker.config, j = p[c].config.toMarker.config, d = h.options.x, e = h.options.y, f = j.options.x, g = j.options.y, p[c].config.x = d, p[c].config.y = e, p[c].config.tox = f, p[c].config.toy = g, v.push(p[c].config), k = Object.assign({\n          animationLabel: 'markerItem'\n        }, p[c].config), a = u.addItem('connectors', k, l), a && a.data('unfilteredConfig', k), a.addEventListener('fc-mouseover', p[c].config.onmouseover), a.addEventListener('fc-mouseout', p[c].config.onmouseout), a.addEventListener('fc-click', p[c].config.onclick), p[c].labelConfig && t && (p[c].labelConfig.x = ((+d + +f) / 2).toString(), p[c].labelConfig.y = ((+e + +g) / 2).toString(), p[c].labelConfig.fontsize = s.fontSize / (r.scaleFactor * m.config.baseScaleFactor), w.push(p[c].labelConfig), k = Object.assign({\n          animationLabel: 'markerItem'\n        }, p[c].labelConfig), b = u.addItem('connectorLabels', k, l), b && b.data('unfilteredConfig')));\n      }\n    }\n  }, {\n    key: \"getShapeArgs\",\n    value: function getShapeArgs() {\n      var a,\n          b = this,\n          c = b.config,\n          d = extend2({}, b.shapeObj);\n      return c.autoScale = 1, d ? ('polygon' === d.type ? 3 > d.sides ? d.type = 'circle' : d.startangle = c.startAngle : 'arc' === d.type && (a = (d.radius || c.markerRadius) * c.autoScale, d.radius = a, d.innerradius = d.innerradius && d.innerradius * c.autoScale || a * INNERRADIUSFACTOR), d) : null;\n    }\n  }, {\n    key: \"_getLabelOptions\",\n    value: function _getLabelOptions(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i = this,\n          j = a && a.toLowerCase();\n      return i.getLabelAlignment[j] || (j = 'center'), g = +c.x, h = +c.y, f = d === UNDEF || e === UNDEF ? c.radius || 0 : /^(top|bottom)$/ig.test(j) && .5 * e || /^(left|right)$/ig.test(j) && .5 * d || 0, f = +f + +b, i.getLabelAlignment[j](g, h, f);\n    }\n  }, {\n    key: \"addMarkerItem\",\n    value: function addMarkerItem(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = this,\n          j = i.getFromEnv('chart'),\n          k = a,\n          l = i.components.markerObjs,\n          m = i.components.shapeObjs,\n          n = i.components.markerGroup,\n          o = i.components.markerLabelGroup,\n          p = i.getChildren('mapAnnotations')[0],\n          q = i.getFromEnv('number-formatter'),\n          r = j.config.markerOpts;\n\n      if (h = k.id.toLowerCase()) {\n        if (l[h]) return;\n        delete k.value, i.imageLoadCount = 0, b = Markers._initializeMarkerItem(h, k, null), b.dataset = i, g = b.config.options.shapeid, d = b.config, f = k.value, d.cleanValue = q.getCleanValue(f), a = d.options, d.formattedValue = null === d.cleanValue ? UNDEF : q.dataLabels(f), d.fillColor = pluck(a.fillcolor, a.color, r.fillColor), d.fillAlpha = pluck(a.fillalpha, a.alpha, r.fillAlpha), d.fillRatio = pluck(a.fillratio, r.fillRatio), d.fillAngle = pluck(a.fillangle, r.fillAngle), d.borderThickness = pluckNumber(a.borderthickness, r.borderThickness), d.borderColor = pluck(a.bordercolor, r.borderColor), d.borderAlpha = pluck(a.borderalpha, r.borderAlpha), d.labelPadding = a.labelpadding || r.labelPadding, d.options.tooltext = pluck(a.tooltext, r.tooltext), d.link = a.link, g && (b.shapeObj = m[g && g.toLowerCase()]), l[h] = b, c = i._drawMarkerItem.call(b), n && o && (c.markerShape && (e = Object.assign({\n          align: 'center',\n          valign: 'middle',\n          animationLabel: 'markerItem',\n          autoscale: 'image' === c.markerShape.type ? 0 : 1\n        }, c.markerShape), b.markerShape = p.addItem(n.getId(), e, i), b.markerShape.data('unfilteredConfig', e)), c.markerLabel && (e = Object.assign({\n          animationLabel: 'markerItem'\n        }, c.markerLabel), b.markerLabel = p.addItem(o.getId(), e, i), b.markerLabel.data('unfilteredConfig', e))), i._buildKdTree();\n      }\n    }\n  }, {\n    key: \"updateMarkerItem\",\n    value: function updateMarkerItem(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g = this,\n          h = g.getFromEnv('chart'),\n          i = g.getChildren('mapAnnotations')[0],\n          j = g.components.markerObjs,\n          k = h.config.markerOpts,\n          l = {},\n          m = j[a];\n\n      if (m) {\n        for (d in c = m.config.options, extend2(c, b), g.imageLoadCount = 0, e = m.config, b) {\n          l[d.toLowerCase()] = b[d] && b[d].toString();\n        }\n\n        e.fillColor = pluck(l.fillcolor, l.color, k.fillColor), e.fillAlpha = pluck(l.fillalpha, l.alpha, k.fillAlpha), e.fillRatio = pluck(l.fillratio, k.fillRatio), e.fillAngle = pluck(l.fillangle, k.fillAngle), e.borderThickness = pluckNumber(l.borderthickness, k.borderThickness), e.borderColor = pluck(l.bordercolor, k.borderColor), e.borderAlpha = pluck(l.borderalpha, k.borderAlpha), e.labelPadding = l.labelpadding || k.labelPadding, e.options.tooltext = pluck(l.tooltext, k.tooltext), e.link = l.link, f = g._drawMarkerItem.call(m).markerShape, g._buildKdTree(), i.update(a, f);\n      }\n    }\n  }, {\n    key: \"createContainer\",\n    value: function createContainer() {\n      var a = this,\n          b = a.getLinkedParent(),\n          c = a.getFromEnv('animationManager'),\n          d = b.getChildContainer('layer1');\n      a.getChildContainer('abovePlotGroup') || a.addChildContainer('abovePlotGroup', c.setAnimation({\n        el: 'group',\n        attr: {\n          name: 'abovePlotGroup',\n          opacity: 1\n        },\n        container: d,\n        component: a,\n        label: 'group'\n      })), a.getChildContainer('belowPlotGroup') || a.addChildContainer('belowPlotGroup', c.setAnimation({\n        el: 'group',\n        attr: {\n          name: 'belowPlotGroup',\n          opacity: 1\n        },\n        container: d,\n        component: a,\n        label: 'group'\n      }));\n    }\n  }, {\n    key: \"_removeMarkerItem\",\n    value: function _removeMarkerItem(a) {\n      var b,\n          c,\n          d = this,\n          e = d.components,\n          f = e.markerObjs,\n          g = f[a],\n          h = e.kdArrayMap;\n      g && (b = g.markerShape, c = g.markerLabel, b && b.dispose(), c && c.dispose(), delete h[a], d._buildKdTree()), delete f[a];\n    }\n  }, {\n    key: \"getElement\",\n    value: function getElement(a) {\n      var b = this;\n      if (b.components.kDTree) return b.components.kDTree.getNeighbour(a);\n    }\n  }], [{\n    key: \"getMarkerRadiusLimits\",\n    value: function getMarkerRadiusLimits(a, b, c, d) {\n      var e = mathMin(a, b),\n          f = .02;\n      return d = parseFloat(d), c = parseFloat(c), isNaN(d) || isNaN(c) ? isNaN(d) ? isNaN(c) ? {\n        min: f * e,\n        max: f * 3.5 * e\n      } : {\n        min: parseInt(c / 10, 10),\n        max: c\n      } : {\n        min: d,\n        max: 10 * d\n      } : d < c ? {\n        min: d,\n        max: c\n      } : {\n        min: c,\n        max: d\n      };\n    }\n  }, {\n    key: \"_initializeMarkerItem\",\n    value: function _initializeMarkerItem(a, b, c) {\n      var d,\n          e = {},\n          f = e.config;\n      return f || (f = e.config = {}), f.id = a, f.definition = b, f.application = c, f.hasValue = null, f.value = null, f.options = null, f.label = null, f.markerShape = null, f.markerLabel = null, f.drawOptions = {\n        shape: null,\n        label: null\n      }, f.drawComplete = !1, d = e.config.options = extend2({}, f.definition), f.dataEnabled ? !isNaN(d.value) && '' !== d.value && (e.value = parseFloat(d.value), e.hasValue = !0) : f.applyAll ? f.options = extend2(d, f.application) : c && (f.options = extend2(d, f.application)), e;\n    }\n  }]);\n\n  return Markers;\n}(Entities);\n\nexport default Markers;","map":null,"metadata":{},"sourceType":"module"}