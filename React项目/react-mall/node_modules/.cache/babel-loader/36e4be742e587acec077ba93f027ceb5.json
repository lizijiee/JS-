{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport AnnotationController from './annotation-controller';\nimport pickBy from 'ramda/src/pickBy';\nimport { computePlotBounds, computeSliceBounds, compute3DSliceBounds, arrangeItems, DEFAULT_MACRO_SEPARATOR, xyCalculator, axisMacroParser } from './utils';\nimport { pluck, UNDEF } from '../../../fc-core/src/lib';\nimport { addDep, getDep } from '../../../fc-core/src/dependency-manager';\nimport annotationAnimation from './annotation-animation';\nimport raphaelShapesRingpath from '../../../fc-core/src/_internal/redraphael/redraphael-shapes/redraphael-shapes.ringpath';\nimport raphaelShapesArcpath from '../../../fc-core/src/_internal/redraphael/redraphael-shapes/redraphael-shapes.arcpath';\n\nvar circular2D = ['pie2d', 'doughnut2d'],\n    circular3D = ['pie3d', 'doughnut3d'],\n    getSnapPoints = function getSnapPoints(a) {\n  var b,\n      c,\n      d,\n      e,\n      f = a.config,\n      g = a.getChildren(),\n      h = g.caption[0],\n      i = g.subCaption[0],\n      j = g.legend && g.legend[0] || {},\n      k = g.gLegend && g.gLegend[0] || {},\n      l = h.config,\n      m = i.config,\n      n = l.width || 0,\n      o = m.width || 0;\n  return 'end' === l.align ? (b = l.x - n, d = l.x - o) : 'start' === l.align ? b = d = l.x : (b = l.x - n / 2, d = l.x - o / 2), c = f.gLegendEnabled ? k.conf : j.config, e = {\n    canvasendx: f.canvasRight,\n    canvasendy: f.canvasBottom,\n    canvasheight: f.canvasHeight,\n    canvasstartx: f.canvasLeft,\n    canvasstarty: f.canvasTop,\n    canvaswidth: f.canvasWidth,\n    canvascenterx: f.canvasCenterX || f.canvasLeft + (f.canvasRight - f.canvasLeft) / 2,\n    canvascentery: f.canvasCenterY || f.canvasTop + (f.canvasBottom - f.canvasTop) / 2,\n    chartcenterx: f.width / 2,\n    chartcentery: f.height / 2,\n    chartstartx: 0,\n    chartstarty: 0,\n    chartendx: f.width,\n    chartendy: f.height,\n    chartheight: f.height,\n    chartwidth: f.width,\n    chartleftmargin: f.marginLeft,\n    chartrightmargin: f.marginRight,\n    chartbottommargin: f.marginBottom,\n    charttopmargin: f.marginTop,\n    captionendx: b + l.width,\n    captionendy: l.y + l.height,\n    captionheight: l.height,\n    captionstartx: b,\n    captionstarty: l.y,\n    captionwidth: n,\n    subcaptionendx: d + m.width,\n    subcaptionendy: m.y + m.height,\n    subcaptionheight: m.height,\n    subcaptionstartx: d,\n    subcaptionstarty: m.y,\n    subcaptionwidth: o,\n    legendendx: c && c.xPos + c.width,\n    legendendy: c && c.yPos + c.height,\n    legendheight: c && c.height,\n    legendstartx: c && c.xPos,\n    legendstarty: c && c.yPos,\n    legendwidth: c && c.width,\n    dataset: function dataset(b) {\n      var c,\n          d,\n          e,\n          f = b.split(DEFAULT_MACRO_SEPARATOR).slice(1),\n          g = [],\n          h = [];\n      return a.iterateComponents(function (a) {\n        'dataset' === a.getType() && h.push(a);\n      }), h.sort(function (c, a) {\n        return c.getJSONIndex() - a.getJSONIndex();\n      }), d = h[+f[0]], g = d.components.data, c = g[+f[2]], -1 < circular2D.indexOf(d.getName().toLowerCase()) ? computeSliceBounds(f[3], c.config) : -1 < circular3D.indexOf(d.getName().toLowerCase()) ? compute3DSliceBounds(f[3], c.config) : (e = computePlotBounds(c, d.getName()), xyCalculator(f[3], e));\n    },\n    xaxis: axisMacroParser(a, 'xAxis'),\n    yaxis: axisMacroParser(a, 'yAxis'),\n    gaugestartx: f.gaugeStartX,\n    gaugestarty: f.gaugeStartY,\n    gaugeendx: f.gaugeEndX,\n    gaugeendy: f.gaugeEndY,\n    gaugecenterx: f.gaugeCenterX,\n    gaugecentery: f.gaugeCenterY,\n    gaugestartangle: f.gaugeStartAngle,\n    gaugeendangle: f.gaugeEndAngle,\n    gaugeradius: f.gaugeRadius,\n    plotwidth: f.plotWidth,\n    plotsemiwidth: f.plotSemiWidth\n  }, e;\n},\n    getBoolean = function getBoolean(a) {\n  return 0 !== parseInt(a, 10);\n},\n    parseShapeConfiguration = function parseShapeConfiguration(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var d = {};\n\n  for (var e in d.annotationType = 'shape', d.id = a.id, d.type = a.type && a.type.toLowerCase(), d.toolText = pluck(a.tooltext, a.toolText), d.animationLabel = pluck(a.animationlabel, a.animationLabel), d.dashed = a.dashed, d.dashLen = pluck(a.dashlen, a.dashLen), d.dashGap = pluck(a.dashgap, a.dashGap), d.thickness = a.thickness, d.showBorder = pluck(a.showborder, a.showBorder), d.borderColor = pluck(a.bordercolor, a.borderColor), d.borderAlpha = pluck(a.borderalpha, a.borderAlpha), d.borderThickness = pluck(a.borderthickness, a.borderThickness), d.alpha = a.alpha, d.color = a.color, d.fillColor = pluck(a.fillcolor, a.fillColor), d.fontColor = pluck(a.fontcolor, a.fontColor), d.fillAlpha = pluck(a.fillalpha, a.fillAlpha), d.fillAngle = pluck(a.fillangle, a.fillAngle), d.fillRatio = pluck(a.fillratio, a.fillRatio), d.fillPattern = pluck(a.fillpattern, a.fillPattern), d.sides = a.sides, d.radius = a.radius, d.yRadius = pluck(a.yradius, a.yRadius), d.innerRadius = pluck(a.innerradius, a.innerRadius), d.endAngle = pluck(a.endangle, a.endAngle), d.startAngle = pluck(a.startangle, a.startAngle), d.isVisible = !0 === getBoolean(a.visible), d.x = a.x, d.y = a.y, d.xPos = pluck(a.xpos, a.xPos), d.yPos = pluck(a.ypos, a.yPos), d.toY = pluck(a.toy, a.toY), d.toX = pluck(a.tox, a.toX), d.autoScale = pluck(a.autoscale, a.autoScale), d.path = a.path, d.css = a.css, d.wrap = a.wrap, d.text = a.text !== UNDEF && null !== a.text && a.text.toString() || UNDEF, d.font = pluck(a.font, b.font, c.basefont), d.bold = pluck(a.bold, a.isbold, a.bold, a.isBold), d.label = a.label, d.align = a.align, d.italic = a.italic, d.vAlign = pluck(a.valign, a.vAlign), d.bgColor = pluck(a.bgcolor, a.bgColor), d.fontSize = pluck(a.fontsize, a.fontSize, b.fontSize, c.basefontsize), d.wrapWidth = pluck(a.wrapwidth, a.wrapWidth), d.leftMargin = pluck(a.leftmargin, a.leftMargin), d.rotateText = pluck(a.rotatetext, a.rotateText), d.wrapHeight = pluck(a.wrapheight, a.wrapHeight), d.showShadow = pluck(a.showshadow, a.showShadow), d.link = a.link, d.url = a.url, d.link = a.link, d.width = a.width, d.height = a.height, d.xScale = pluck(a.xscale, a.xScale), d.yScale = pluck(a.yscale, a.yScale), d.onload = a.onload, d.onerror = a.onerror, 'object' == typeof a.component && (d.component = a.component), d) {\n    if (d.hasOwnProperty(e)) {\n      var _a = d[e];\n      'undefined' == typeof _a && delete d[e];\n    }\n  }\n\n  return d;\n},\n    parseConfiguration = function parseConfiguration(a, b) {\n  var c = {},\n      d = a.items;\n\n  for (var e in d = a.items = arrangeItems(d), c.annotationType = 'group', c.id = a.id, c.showBelow = 'undefined' == typeof a.showbelow || null === a.showbelow ? 1 : +a.showbelow, c.x = a.x, c.y = a.y, c.animationLabel = pluck(a.animationlabel, a.animationLabel), c.xPos = pluck(a.xpos, a.xPos), c.yPos = pluck(a.ypos, a.yPos), c.grpXShift = pluck(a.grpxshift, a.grpXShift), c.grpYShift = pluck(a.grpyshift, a.grpYShift), c.xShift = pluck(a.xshift, a.xShift), c.yShift = pluck(a.yshift, a.yShift), c.color = a.color, c.alpha = a.alpha, c.isVisible = 1 === +(a.visible || 1), c.font = pluck(a.font, b.basefont), c.link = a.link, c.fontSize = pluck(a.fontsize, a.fontSize, b.basefontsize), c.textAlign = pluck(a.textalign, a.textAlign), c.textVAlign = pluck(a.textvalign, a.textVAlign), c.rotateText = pluck(a.rotatetext, a.rotateText), c.wrapText = pluck(a.wraptext, a.wrapText), c.toolText = pluck(a.tooltext, a.toolText), c.link = a.link, c.showShadow = pluck(a.showshadow, a.showShadow), c.items = a.items, c.css = a.css, c.autoScale = pluck(a.autoscale, a.autoScale), c.scaleText = pluck(a.scaletext, a.scaleText), c.xScale = pluck(a.xscale, a.xScale), c.yScale = pluck(a.yscale, a.yScale), c.scaleImages = pluck(a.scaleimages, a.scaleImages), c.constrainedScale = pluck(a.constrainedscale), c.origH = pluck(a.origh, a.origH, b.origh), c.origW = pluck(a.origw, a.origW, b.origw), c.onAnnotationClick = a.onAnnotationClick, c.onAnnotationRollover = a.onAnnotationRollover, c.onAnnotationRollout = a.onAnnotationRollout, 'object' == typeof a.component && (c.component = a.component), c) {\n    if (c.hasOwnProperty(e)) {\n      var _a2 = c[e];\n      'undefined' == typeof _a2 && delete c[e];\n    }\n  }\n\n  return Array.isArray(d) && (c.itemConfigs = d.map(function (a) {\n    return parseShapeConfiguration(a, c, b);\n  })), c;\n},\n    mergeConfig = function mergeConfig(a, b) {\n  b.css = b.css || a.css, b.autoscale = pluck(b.autoscale, a.autoscale), b.animationLabel = pluck(b.animationLabel, a.animationLabel), b.constrainedscale = pluck(b.constrainedscale, a.constrainedscale), b.scaletext = pluck(b.scaletext, a.scaletext), b.scaleimages = pluck(b.scaleimages, a.scaleimages), b.xshift = pluck(b.xshift, a.xshift), b.yshift = pluck(b.yshift, a.yshift), b.grpxshift = pluck(b.grpxshift, a.grpxshift), b.grpyshift = pluck(b.grpyshift, a.grpyshift), b.origw = pluck(b.origw, a.origw), b.origh = pluck(b.origh, a.origh), b.showbelow = pluck(b.showbelow, a.showbelow, 1), b.onAnnotationClick = a.onAnnotationClick, b.onAnnotationRollover = a.onAnnotationRollover, b.onAnnotationRollout = a.onAnnotationRollout;\n},\n    isRootGroupConfig = function isRootGroupConfig(a, b) {\n  return 'itemConfigs' !== b;\n},\n    getParsedConfig = function getParsedConfig() {\n  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    groups: []\n  };\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var c = a.groups || [];\n  return c.map(function (c) {\n    return mergeConfig(a, c), parseConfiguration(c, b);\n  });\n};\n\nvar AnnotationExtension =\n/*#__PURE__*/\nfunction (_AnnotationController) {\n  _inherits(AnnotationExtension, _AnnotationController);\n\n  function AnnotationExtension() {\n    var _this;\n\n    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, AnnotationExtension);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AnnotationExtension).call(this)), addDep({\n      name: 'annotationAnimation',\n      type: 'animationRule',\n      extension: annotationAnimation\n    }), raphaelShapesRingpath(getDep('redraphael', 'plugin')), raphaelShapesArcpath(getDep('redraphael', 'plugin')), _this.rawConfig = JSON.parse(JSON.stringify(a)), _this.groups = [], _this.config.dependencies = {};\n    return _this;\n  }\n\n  _createClass(AnnotationExtension, [{\n    key: \"getName\",\n    value: function getName() {\n      return 'annotation';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'extension';\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var a = this,\n          b = a.config;\n      a.rawConfig = {\n        group: []\n      }, b.parsedConfigs || (b.parsedConfigs = []);\n    }\n  }, {\n    key: \"configureAttributes\",\n    value: function configureAttributes() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        groups: []\n      };\n      var b = this,\n          c = b.config,\n          d = b.getFromEnv('chart');\n      b.setup(), c.parsedConfigs = a.groups ? getParsedConfig(a, d.config) : [], b.createAnnotationItems();\n    }\n  }, {\n    key: \"createAnnotationItems\",\n    value: function createAnnotationItems(a) {\n      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var c = this,\n          d = c.config;\n      (a || d.parsedConfigs).forEach(function (a) {\n        var d,\n            e = a.itemConfigs || {};\n        a = pickBy(isRootGroupConfig, a), d = c.createItem(a, UNDEF, b), e.forEach(function (a) {\n          c.createItem(a, d, b);\n        }), d.items = d.getChildren('item') || [];\n      }), c.groups = c.getChildren('group') || [];\n    }\n  }, {\n    key: \"__addItem\",\n    value: function __addItem(a) {\n      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var c,\n          d,\n          e,\n          f = this,\n          g = f._JSONData;\n\n      for (b = Object.assign({}, b), g || (f._JSONData = g = {\n        groups: []\n      }), (d = 0, e = g.groups.length); d < e && (c = g.groups[d], c.id !== a); d++) {\n        ;\n      }\n\n      return c ? c.items.push(b) : g.groups.push({\n        id: a,\n        items: [b]\n      }), f.setData(g), f.config.lastCreatedItem;\n    }\n  }, {\n    key: \"addItem\",\n    value: function addItem(a) {\n      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var c = arguments.length > 2 ? arguments[2] : undefined;\n      var d,\n          e,\n          f = this,\n          g = f.retrieveGroup(a),\n          h = parseShapeConfiguration(b);\n      if (h.isVisible = !0, g = g || f.addGroup({\n        id: a\n      }), 'object' == typeof c && (e = {\n        component: c\n      }), d = f.createItem(h, g, e), !!d) return g.items = g.getChildren('item') || [], f.asyncDraw(), d;\n    }\n  }, {\n    key: \"__addGroup\",\n    value: function __addGroup() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var b = this,\n          c = b._JSONData;\n      return a = Object.assign({}, a), c || (b._JSONData = c = {\n        groups: []\n      }), c.groups.push(a), b.setData(c), b.config.lastCreatedGroup;\n    }\n  }, {\n    key: \"addGroup\",\n    value: function addGroup() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var b = arguments.length > 1 ? arguments[1] : undefined;\n      var c,\n          d,\n          e = this,\n          f = e.config,\n          g = Object.assign({}, a);\n      return e.setup(), d = getParsedConfig({\n        groups: [g]\n      }), c = d[0], d.forEach(function (a) {\n        f.parsedConfigs.push(a);\n      }), e.createAnnotationItems(d, {\n        component: b\n      }), c = e.groups[e.groups.length - 1], e.asyncDraw(), c;\n    }\n  }, {\n    key: \"addCustomGroup\",\n    value: function addCustomGroup(a) {\n      a && (this.config.customGroup = a);\n    }\n  }, {\n    key: \"update\",\n    value: function update(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g = this,\n          h = {};\n\n      if (a) {\n        for (d in b) {\n          h[d.toLowerCase()] = b[d] && b[d].toString();\n        }\n\n        return (c = g.retrieveItem(a) || g.retrieveGroup(a), !c || !c.getElement()) ? void 0 : ('undefined' == typeof h.visible && (h.visible = c._getConfig('isVisible')), e = c.rawConfig, e = Object.assign(e, h), f = parseShapeConfiguration(e), f.isVisible = h.visible, c.setData(f), c);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h = this,\n          k = h._JSONData,\n          l = !1;\n\n      if (a) {\n        for (b = 0, d = k.groups.length; b < d; b++) {\n          for (f = k.groups[b], c = 0, e = (f.items || []).length; c < e; c++) {\n            if (g = f.items[c], g.id === a && !l) {\n              f.items.splice(c, 1), l = !0;\n              break;\n            }\n          }\n        }\n\n        if (!l) for (b = 0, d = k.groups.length; b < d; b++) {\n          f = k.groups[b], f.id === a && k.groups.splice(b, 1);\n        }\n      } else k = h._JSONData = {\n        groups: []\n      };\n\n      h.setData(k);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.destroy();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var a = this;\n      a.addToEnv('snapPoints', getSnapPoints(a.getFromEnv('chart'))), a.addGraphicalElement({\n        el: 'group',\n        attr: {\n          name: 'upperannotations'\n        },\n        component: a,\n        container: {\n          label: 'group',\n          id: 'abovePlotGroup',\n          isParent: !0\n        },\n        id: 'upperAnnotationGroup',\n        label: 'group'\n      }), a.addGraphicalElement({\n        el: 'group',\n        attr: {\n          name: 'lowerannotations'\n        },\n        component: a,\n        container: {\n          label: 'group',\n          id: 'belowPlotGroup',\n          isParent: !0\n        },\n        id: 'lowerAnnotationGroup',\n        label: 'group'\n      });\n    }\n  }]);\n\n  return AnnotationExtension;\n}(AnnotationController);\n\nexport default AnnotationExtension;","map":null,"metadata":{},"sourceType":"module"}