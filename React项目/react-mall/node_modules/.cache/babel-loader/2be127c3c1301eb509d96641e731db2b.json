{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _assertThisInitialized from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { pluckNumber, hasSVG } from '../lib';\nimport { priorityList } from '../schedular';\nimport { ComponentInterface } from '../component-interface';\nimport { getDep, getDepsByType } from '../dependency-manager';\nvar UNDEF;\n\nvar isIE8 = !hasSVG,\n    OBJECT = 'object',\n    CHART = 'chart',\n    GROUP = 'group',\n    HTML = 'html',\n    TEXT = 'text',\n    PAPER = 'paper',\n    DISAPPEARING = 'disappearing',\n    APPEARING = 'appearing',\n    STRING = 'string',\n    UPDATING = 'updating',\n    FUNCTION = 'function',\n    LINEAR = 'linear',\n    CHARTSPECIFIC = 'chartSpecific',\n    GLOBAL = 'global',\n    DEFAULT = 'default',\n    STARSTRING = '*',\n    durationList = {\n  initial: 1,\n  update: 0,\n  realTimeUpdate: 0,\n  resize: 0,\n  dispose: 0,\n  legendInteraction: 0,\n  scroll: 0,\n  mouseOut: 0,\n  mouseOver: 0,\n  default: 0,\n  slicing: .25,\n  timenavSqueeze: 0,\n  selectedRange: 0,\n  timenavScroll: 0\n},\n    rulePriorityList = ['default', 'global', 'chartSpecific'],\n    animMap = {\n  fadeIn: {\n    opacity: {\n      start: 0,\n      end: 1\n    }\n  },\n  fadeOut: {\n    opacity: {\n      start: 1,\n      end: 0\n    }\n  }\n},\n    callbackMap = {\n  fadeIn: function fadeIn() {\n    this && this.show();\n  },\n  fadeOut: function fadeOut() {\n    this && this.hide();\n  }\n},\n    isNull = function isNull(a) {\n  return null === a;\n},\n    getRegisteredThemes = function getRegisteredThemes(a) {\n  var b,\n      c = {};\n\n  for (var d in a) {\n    a.hasOwnProperty(d) && (b = a[d], c[b.name] = b);\n  }\n\n  return c;\n},\n    fetchRulesFromTheme = function fetchRulesFromTheme(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var c = b.split(','),\n      d = [];\n  return c.forEach(function (b) {\n    a[b] && a[b].animation && d.push(a[b].animation);\n  }), d;\n},\n    shiftAnimTime = function shiftAnimTime(a, b, c) {\n  var d,\n      e = Math.round,\n      f = Object.assign({}, a),\n      g = c / b,\n      h = .2;\n  return g > h && (g = h), d = f.end - f.start, f.start *= 1 - g, f.start += g, f.end = f.start + (1 - g) * d, f.start = e(100 * f.start) / 100, f.end = e(100 * f.end) / 100, f;\n},\n    _applyAnim = function _applyAnim(a, b, c) {\n  var d,\n      e = animMap[b],\n      f = '',\n      g = {};\n\n  if (e && a && a.el && a.el[0]) {\n    for (f in e) {\n      g[f] = a.el.attrs[f], g[f] === UNDEF && (g[f] = null), a.attrs[f] = e[f].end, a.el.attr(f, e[f].start);\n    }\n\n    d = a.callback, a.callback = function () {\n      c && callbackMap[b] && callbackMap[b].call(this), d && d.call && d.call(this), this.attr(g);\n    };\n  }\n},\n    applyType = function applyType(a, b) {\n  var c,\n      d = !0;\n\n  if (b) {\n    for (a.attrs = a.attrs || {}, b = b.split('-'), ~b.indexOf('nc') && (d = !1), c = b.length; c--;) {\n      _applyAnim(a, b[c], d);\n    }\n\n    return a;\n  }\n},\n    animateEl = function animateEl(a, b, c, d, e, f, g, h) {\n  a.animateWith(e, f, b, g, h, c, d);\n},\n    execPreAnimFns = function execPreAnimFns(a) {\n  var b = 0,\n      c = a.length;\n\n  for (b = 0; b < c; ++b) {\n    a[b].fn && a[b].fn.call(a[b].el);\n  }\n},\n    ruleReducer = function ruleReducer(a) {\n  var b = {};\n\n  for (var c in a) {\n    if (a.hasOwnProperty(c) && '__esModule' !== c) {\n      var d = a[c];\n      merge(b, d);\n    }\n  }\n\n  return b;\n},\n    merge = function merge(a, b) {\n  for (var c in b) {\n    b.hasOwnProperty(c) && (a[c] || (a[c] = []), a[c].push(b[c]));\n  }\n},\n    isFunction = function isFunction(a) {\n  return typeof a == FUNCTION;\n};\n\nfunction hasAnimation(a, b) {\n  var c,\n      d,\n      e,\n      f,\n      g,\n      h,\n      k = !1;\n  if (!a) return !1;\n\n  for (e = 0, f = a.length; e < f; e += 1) {\n    if (d = a[e], !Array.isArray(d)) c = !1, -1 === b.indexOf(d.name) ? d.child && (c = d.hasAnimation = hasAnimation(d.child, b)) : c = !0, k = k || c, d.hasAnimation = c;else for (g = 0, h = a[e].length; g < h; g += 1) {\n      d = a[e][g], c = !1, -1 === b.indexOf(d.name) ? d.child && (c = d.hasAnimation = hasAnimation(d.child, b)) : c = !0, k = k || c, d.hasAnimation = c;\n    }\n  }\n\n  return k;\n}\n\nfunction buildDynamicRules(a, b, c, d) {\n  var f,\n      g,\n      h,\n      j,\n      k,\n      l = a.length,\n      m = 0,\n      n = 0,\n      o = b;\n\n  for (g = 0, h = 0, k = 0; k < l; k += 1) {\n    f = a[k], f.hasAnimation || !1 === f.collapsible ? h += 1 : g += f.duration, n += f.duration;\n  }\n\n  for (g /= h, k = 0; k < l; k += 1) {\n    (f = a[k], !!f.hasAnimation) && (m = o, j = c - b, o = m + (f.duration / n + g) * j, d[f.name] = {\n      start: m,\n      end: o,\n      effect: f.effect,\n      transition: f.transition\n    }, f.child && buildWorkingRule(f.child, m, o, d));\n  }\n}\n\nfunction buildStaticRules(a, b, c, d) {\n  var f, g, h;\n  g = a.start, h = a.end, f = c - b, g = b + g * f, h = b + h * f, d[a.name] = {\n    start: g,\n    end: h,\n    effect: a.effect,\n    transition: a.transition\n  }, a.child && buildWorkingRule(a.child, g, h, d);\n}\n\nfunction buildWorkingRule(a, b, c, d) {\n  var e,\n      f,\n      g = a.length;\n\n  for (e = 0; e < g; e++) {\n    f = a[e], Array.isArray(f) ? buildDynamicRules(f, b, c, d) : buildStaticRules(f, b, c, d);\n  }\n}\n\nanimMap.fadein = animMap.fadeIn, animMap.fadeout = animMap.fadeOut;\n\nvar AnimationManager =\n/*#__PURE__*/\nfunction (_ComponentInterface) {\n  _inherits(AnimationManager, _ComponentInterface);\n\n  _createClass(AnimationManager, [{\n    key: \"getType\",\n    value: function getType() {\n      return 'animationManager';\n    }\n  }]);\n\n  function AnimationManager() {\n    var _this;\n\n    _classCallCheck(this, AnimationManager);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationManager).call(this));\n\n    var a = _assertThisInitialized(_this);\n\n    a._removedGraphics = [], a._animCallBack = function () {\n      if (!a.getState('removed') && !this.removed) {\n        var b = a.getAnimationState();\n        a._removeElems(), a.reset(), a.fireEvent('animationComplete', {\n          currAnimState: b\n        });\n      }\n    }, a.startAnimation = function () {\n      a.kickStart(), a.animate();\n    };\n    return _this;\n  }\n\n  _createClass(AnimationManager, [{\n    key: \"getName\",\n    value: function getName() {\n      return 'animationManager';\n    }\n  }, {\n    key: \"stopAnimation\",\n    value: function stopAnimation() {\n      if (this.getState('chartAnimating')) {\n        var a,\n            b = this,\n            c = b.config,\n            d = c.animationObj,\n            e = d && d.duration;\n        e ? (a = b.getGraphicalElement().dummyObj, a && a.stop(UNDEF, !0, !0)) : 0 === e && (b.removeJob('anim-callBack'), b._animCallBack());\n      }\n    }\n  }, {\n    key: \"kickStart\",\n    value: function kickStart() {\n      var a,\n          b,\n          c,\n          d = this,\n          e = d.config,\n          f = d.getGraphicalElement(),\n          g = d.getFromEnv(PAPER),\n          h = e.animationObj,\n          i = e.animationeffect;\n      b = h.duration, h.animObj = c = getDep('redraphael', 'plugin').animation({\n        x: 0\n      }, b, i, d._animCallBack, !0), h.animType = i, (a = f.dummyObj) ? a.attr({\n        x: 100\n      }) : (a = g.rect({\n        x: 100,\n        y: 0,\n        width: 10,\n        height: 30\n      }), d.addGraphicalElement('dummyObj', a), a.hide()), h.dummyObj = f.dummyObj, a.stop(UNDEF, !0, !0), d.fireEvent('animationStart', {\n        duration: b\n      }), d.setState('chartAnimating', !0), a.animate(c);\n    }\n  }, {\n    key: \"setAnimationState\",\n    value: function setAnimationState() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : UNDEF;\n      a && this.stopAnimation(), this.config.__state = a, this._setAnimDuration(a);\n    }\n  }, {\n    key: \"getAnimationState\",\n    value: function getAnimationState() {\n      return this.config && this.config.__state;\n    }\n  }, {\n    key: \"_setAnimDuration\",\n    value: function _setAnimDuration() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT;\n      var b = this,\n          c = b.config,\n          d = c.animationObj || (c.animationObj = {}),\n          e = c.animationDuration || (c.animationDuration = {}),\n          f = b.getFromEnv(CHART).getFromEnv('chart-attrib') || {},\n          g = a + 'AnimDuration',\n          h = c.killSwitch,\n          i = h ? 0 : 1e3 * (e[g] || f[g.toLowerCase()] || AnimationManager.getFallbackAnimDuration(a));\n      d && (d[g] = i, d.duration = +i);\n    }\n  }, {\n    key: \"configureAttributes\",\n    value: function configureAttributes() {\n      var a = this,\n          b = a.getFromEnv(CHART),\n          c = b.config,\n          d = a.config,\n          e = b.getFromEnv('chart-attrib') || {};\n      d.killSwitch = !pluckNumber(e.animation, c.animation, 1), d.animationeffect = c.animationeffect || 'linear', a.invokeAnimationRules(), d.workingRules || (d.workingRules = {}), d.animateArr || (d.animateArr = []), d.animationName || (d.animationName = []);\n    }\n  }, {\n    key: \"invokeAnimationRules\",\n    value: function invokeAnimationRules() {\n      var a,\n          b = this,\n          c = b.getFromEnv(CHART),\n          d = c.getFromEnv('chart-attrib') || {},\n          e = c.config || {},\n          f = b.config,\n          g = c.getFromEnv('chartInstance'),\n          h = g.args.animation,\n          i = c.getFromEnv('core-options').defaultTheme,\n          j = getRegisteredThemes(getDepsByType('theme')),\n          k = (c.getFromEnv('core-options')._globalAnimationRule || []).concat(fetchRulesFromTheme(j, i)),\n          l = (h && [h] || []).concat(fetchRulesFromTheme(j, e.theme));\n      f.animationRules = {\n        global: ruleReducer(k.map(function (a) {\n          return a && a.rule;\n        }).filter(function (a) {\n          return a;\n        })),\n        chartSpecific: ruleReducer(l.map(function (a) {\n          return a && a.rule;\n        }).filter(function (a) {\n          return a;\n        })),\n        default: ruleReducer(getDepsByType('animationRule'))\n      }, f.animationDuration = a = {}, k.map(function (b) {\n        return Object.assign(a, b.duration);\n      }), l.map(function (b) {\n        return Object.assign(a, b.duration);\n      }), a.initialAnimDuration = pluckNumber(a.initialAnimDuration, d.initialanimduration, d.animationduration), b.config.slots = AnimationManager.getFallbackAnimTimeSlots().concat([].concat.apply([], k.map(function (a) {\n        return a.slots;\n      })).filter(function (a) {\n        return a;\n      })).concat([].concat.apply([], l.map(function (a) {\n        return a.slots;\n      })).filter(function (a) {\n        return a;\n      }));\n    }\n  }, {\n    key: \"reInitialize\",\n    value: function reInitialize() {\n      var a = this,\n          b = a.config,\n          c = b.animationObj,\n          d = c.duration;\n      a.setState('initialized', !0), d ? a.addJob('start-animation', a.startAnimation, priorityList.animation) : (a.fireEvent('animationStart', {\n        duration: d\n      }), a.setState('chartAnimating', !0), a.addJob('anim-callBack', a._animCallBack, priorityList.animation));\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var a = this;\n      a.setState('initialized', !1), a.config && a.config.animateArr && (a.config.animateArr.length = 0), a.setState('chartAnimating', !1), a.setAnimationState();\n    }\n  }, {\n    key: \"registerAnimObj\",\n    value: function registerAnimObj(a) {\n      for (var b in a) {\n        this.registerAnimation(a[b], b);\n      }\n    }\n  }, {\n    key: \"getFinalSlots\",\n    value: function getFinalSlots() {\n      var a = this,\n          b = a.config,\n          c = b.slots,\n          d = b.workingRules = {},\n          e = b.animationName;\n      return hasAnimation(c, e), buildWorkingRule(c, 0, 1, d), d['default'] = {\n        start: 0,\n        end: 1\n      }, d;\n    }\n  }, {\n    key: \"registerOne\",\n    value: function registerOne(a, b) {\n      this.registerAnimation([{\n        data: [a]\n      }], b);\n    }\n  }, {\n    key: \"registerAnimation\",\n    value: function registerAnimation() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var b = arguments.length > 1 ? arguments[1] : undefined;\n      var c,\n          d,\n          e,\n          f = !1;\n\n      for (c = 0, e = a.length; c < e; c += 1) {\n        d = a[c], d.data && d.data.length && (this.config.animateArr.push((d.component = b, d)), f = !0);\n      }\n\n      f && this.config.animationName.push(b), this.getState('initialized') || this.reInitialize();\n    }\n  }, {\n    key: \"onAnimationComplete\",\n    value: function onAnimationComplete(a) {\n      var b = this;\n      b.addEventListener('animationComplete', function (b) {\n        a(), b.detachHandler();\n      });\n    }\n  }, {\n    key: \"setAnimation\",\n    value: function setAnimation() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q = this,\n          r = q.config,\n          s = r.animationObj,\n          t = a.el,\n          u = a.attr || {},\n          v = {},\n          w = {},\n          x = function x(b, c, d, e) {\n        return function () {\n          d.callback && d.callback.call(this), b && this.attr(b), c && a.callback && a.callback.call(this), e && this.appendTo(e);\n        };\n      },\n          y = function y(a, b, c) {\n        return function () {\n          b.hookFn && b.hookFn.call(this), a && this.attr(a), c && this.appendTo(c);\n        };\n      },\n          z = [],\n          A = s.duration,\n          B = q.getState('chartAnimating'),\n          C = typeof t == OBJECT && a.container && t.parent !== a.container;\n\n      if (q.getState('chartAnimating') && r.animationObj && r.animationObj.duration && q.setAnimationState('default'), !B && A && (k = q.getAnimAttributes(a))) {\n        for (j = k.length, p = !1, l = a.state === APPEARING || typeof t == STRING, m = !l && t.attrs, h = {}, g = 0; g < j; g++) {\n          for (e in n = g === j - 1, f = z[g] = {}, o = k[g], b = o.finalAttr, c = o.initialAttr, AnimationManager.removeOpacityFromGroup(a.el, c), AnimationManager.removeOpacityFromGroup(a.el, b), c) {\n            h[e] = c[e], w[e] === UNDEF && (w[e] = c[e]);\n          }\n\n          for (e in b) {\n            h[e] = b[e], l && w[e] === UNDEF && (w[e] = b[e]);\n          }\n\n          if (f.attrs = b, f.transition = o.transition, f.effect = o.effect, f.animConfig = [o.startEnd], o.callback && (f.callback = o.callback), (p = C && o.changeGroup) && (C = !1), n) {\n            if (l) for (e in u) {\n              w[e] === UNDEF && (w[e] = u[e]);\n            }\n\n            for (e in u) {\n              d = u[e], (h[e] || !l) && h[e] !== d && (b && b[e] === UNDEF ? b[e] = d : v[e] = d);\n            }\n\n            for (e in h) {\n              v[e] === UNDEF && (d = u[e] || m[e] || '', h[e] !== d && (b && b[e] === UNDEF && d !== UNDEF ? b[e] = d : v[e] = d));\n            }\n\n            b || (f.attrs = v), f.callback = x((b || c) && v, n, o, C && a.container), t = q.setAttributes(t, {\n              attr: w,\n              inputJSON: a\n            });\n          }\n\n          (c || o.hookFn || p) && (f.animConfig[0].hookFn = y((!l || g) && c, o, p && a.container));\n        }\n\n        for (g = 0; g < j; g++) {\n          z[g].el = t.el, q.registerAnimation([{\n            data: [z[g]]\n          }], k[g].slot);\n        }\n      } else B ? t = q.setAttributes(t, {\n        attr: u,\n        inputJSON: a,\n        groupChangeReq: C,\n        immediate: !0\n      }) : (q.registerAnimation(), t = q.setAttributes(t, {\n        attr: u,\n        inputJSON: a,\n        groupChangeReq: C,\n        immediate: !0\n      }));\n\n      return t.removed ? null : t.el;\n    }\n  }, {\n    key: \"_removeElems\",\n    value: function _removeElems() {\n      if (this.getFromEnv(PAPER) && !this.getFromEnv(PAPER).removed) {\n        var a = this;\n        a._removedGraphics.forEach(function (a) {\n          return a.remove && a.remove();\n        }), a._removedGraphics.length = 0;\n      }\n    }\n  }, {\n    key: \"removeElement\",\n    value: function removeElement(a, b) {\n      var c = this;\n      return b ? a.remove() : c._removedGraphics.push(a), null;\n    }\n  }, {\n    key: \"_getRulesByState\",\n    value: function _getRulesByState(a) {\n      var b,\n          c,\n          d,\n          e,\n          f = this,\n          g = a.component,\n          h = f.getAnimationState() || STARSTRING,\n          i = AnimationManager._ruleSelectorQueryBuilder(Object.assign(a, {\n        state: h\n      }));\n\n      return e = g.getState('animRules') || {}, (b = e[h]) ? b : (c = e[h] = {}, d = f.config.animationRules, rulePriorityList.forEach(function (a) {\n        var b = d[a];\n        b && i.forEach(function (a) {\n          b[a] && (Array.isArray(b[a]) ? b[a].forEach(function (a) {\n            c = e[h] = isNull(a) ? null : Object.assign(c || {}, isFunction(a) ? a.call(g) : a);\n          }) : c = e[h] = isNull(b[a]) ? null : Object.assign(c || {}, isFunction(b[a]) ? b[a].call(g) : b[a]));\n        });\n      }), g.setState('animRules', e), g.getState('ruleFlushAttached') || g.addExtEventListener('predraw', function () {\n        g.setState('animRules', UNDEF), g.setState('ruleFlushAttached', !0);\n      }, g.getFromEnv(CHART)), c);\n    }\n  }, {\n    key: \"getAnimAttributes\",\n    value: function getAnimAttributes(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g = this,\n          h = a.component || g.getFromEnv(CHART),\n          j = a.label || ('object' == typeof a.el ? a.el.type : a.el),\n          k = a.state,\n          l = g._getRulesByState({\n        label: j,\n        component: h\n      }),\n          m = [];\n\n      if (!isNull(l) && (k || (k = typeof a.el == STRING ? APPEARING : a.attr ? UPDATING : DISAPPEARING), b = AnimationManager._getRulesByElement(l, {\n        component: h,\n        state: k,\n        label: j\n      }), !isNull(b))) {\n        if (!b) return AnimationManager.getFallbackAnimRule(a);\n\n        for (isFunction(b) && (b = b.call(h, a)), f = b.length, e = 0; e < f; e++) {\n          c = b[e], d = {}, c.initialAttr && (d.initialAttr = isFunction(c.initialAttr) ? c.initialAttr.call(h, a) : Object.assign({}, c.initialAttr)), c.finalAttr && (d.finalAttr = isFunction(c.finalAttr) ? c.finalAttr.call(h, a) : Object.assign({}, c.finalAttr)), d.startEnd = isFunction(c.startEnd) ? c.startEnd.call(h, a) : c.startEnd ? Object.assign({}, c.startEnd) : {\n            start: 0,\n            end: 1\n          }, d.slot = c.slot || 'default', d.callback = c.callback, d.hookFn = c.hookFn, d.transition = c.transition, d.effect = c.effect || 'linear', c.groupChange && (d.groupChange = !0), m.push(d);\n        }\n\n        return m;\n      }\n    }\n  }, {\n    key: \"createElement\",\n    value: function createElement(a) {\n      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var c = arguments.length > 2 ? arguments[2] : undefined;\n      var d = this,\n          e = d.getFromEnv(PAPER);\n      if (e || (e = d.getFromEnv(CHART).getFromEnv(PAPER), d.addToEnv(PAPER, e)), a === GROUP) a = e.group(c.attr && c.attr.name || '', c.container), a.attr(b);else if (a === HTML) a = e.html(c.attr.type, b, c.css, c.container);else {\n        if (a === TEXT && c.css) return e[c.el](b, c.css, c.container);\n        a = e[c.el](b, c.container);\n      }\n      return a;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(a, b) {\n      var c,\n          d = this,\n          e = b.attr,\n          f = b.inputJSON || {};\n      return 'string' == typeof a ? a = d.createElement(a, e, f) : 0 === Object.keys(e).length ? (!f.attr || f.state === DISAPPEARING) && (c = !f.doNotRemove) : a.attr(e), c ? d.removeElement(a, b.immediate) : (f.css && a.css(f.css), b.groupChangeReq && a.appendTo(f.container), b.immediate && f.callback && f.callback.call(a)), {\n        el: a,\n        removed: c\n      };\n    }\n  }, {\n    key: \"prepareAnimateArr\",\n    value: function prepareAnimateArr(a) {\n      function b(a, b) {\n        var c,\n            e,\n            f,\n            g = {\n          start: 0,\n          end: 1\n        };\n\n        for (f in a) {\n          if (a.hasOwnProperty(f)) {\n            if (a[f].syncWith && !d[a[f].syncWith]) continue;\n            c = a[f].syncWith, g.start = a[f].start === UNDEF ? 0 : a[f].start, g.end = a[f].end === UNDEF ? 1 : a[f].end, g.hookFn = a[f].hookFn || a.hookFn, g.smartMorph = a[f].smartMorph || a.smartMorph;\n            break;\n          }\n        }\n\n        return c = c && d[c] ? c : b && d[b] ? b : 'default', e = d[c].end - d[c].start, g.start = d[c].start + g.start * e, g.end = d[c].start + g.end * e, g;\n      }\n\n      var c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          k,\n          l,\n          m,\n          n = this.config.preAnimArr = [];\n\n      for (d = this.getFinalSlots(), f = 0, g = a.length; f < g; f += 1) {\n        for (c = a[f], e = c.component, (h = 0, k = c.data.length); h < k; h += 1) {\n          m = c.data[h], l = m.transition || d[e] && d[e].transition, l && applyType(m, l), m.preAnimFn && n.push({\n            el: m.el,\n            fn: m.preAnimFn\n          }), m.animConfig && (m.animConfig = b(m.animConfig, e));\n        }\n\n        c.effect || d[e] && (c.effect = d[e].effect), c.animConfig || (c.animConfig = [{}]), c.animConfig = b(c.animConfig, e);\n      }\n    }\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          k = this,\n          l = k.config,\n          m = k.config.animateArr,\n          n = l.animationObj,\n          o = n.animObj,\n          p = n.dummyObj,\n          q = n.duration;\n\n      for (k.prepareAnimateArr(m), execPreAnimFns(k.config.preAnimArr), (e = 0, f = m.length); e < f; e += 1) {\n        for (b = m[e], g = 0, h = b.data.length - 1; g <= h; g += 1) {\n          c = b.data[g].animConfig || b.animConfig, c = shiftAnimTime(c, q, 180), a = b.data[g].effect || b.effect || LINEAR, d = e === f ? b.callback || b.data[g].callback : b.data[g].callback, b.data[g].preAttrs && b.data[g].el.attr(b.data[g].preAttrs), b.data[g].el && animateEl(b.data[g].el, b.data[g].attrs, d || null, c, p, o, q, a);\n        }\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(a) {\n      this.removeAllJobs(), a.instant && this.getGraphicalElement('dummyObj') && this.getGraphicalElement('dummyObj').remove(), _get(_getPrototypeOf(AnimationManager.prototype), \"remove\", this).call(this, a);\n    }\n  }], [{\n    key: \"removeOpacityFromGroup\",\n    value: function removeOpacityFromGroup(a, b) {\n      b && isIE8 && (a === GROUP || a.type === GROUP) && delete b.opacity;\n    }\n  }, {\n    key: \"_ruleSelectorQueryBuilder\",\n    value: function _ruleSelectorQueryBuilder(a) {\n      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n      var c = a.label,\n          d = a.state,\n          e = a.component,\n          f = e.getType(),\n          g = e.getName();\n\n      if (b) {\n        var _a = ['*', '*.*', '*.*.*'],\n            _b = [\"*.*.\".concat(g), \"*.\".concat(f, \".*\"), \"*.\".concat(f, \".\").concat(g)];\n        return '*' === d ? _a.concat(_b) : _a.concat(_b, [\"\".concat(d, \".*\"), \"\".concat(d, \".*.*\"), \"\".concat(d, \".*.\").concat(g), \"\".concat(d, \".\").concat(f, \".*\"), \"\".concat(d, \".\").concat(f, \".\").concat(g)]);\n      }\n\n      return [\"\".concat(c, \".\").concat(d), \"\".concat(c, \".*\"), \"*.\".concat(d), '*.*', '*'];\n    }\n  }, {\n    key: \"_getRulesByElement\",\n    value: function _getRulesByElement(a, b) {\n      var c,\n          d = AnimationManager._ruleSelectorQueryBuilder(b, !1);\n\n      return d.forEach(function (b) {\n        void 0 === c && (c = a[b]);\n      }), c;\n    }\n  }, {\n    key: \"getFallbackAnimRule\",\n    value: function getFallbackAnimRule(a) {\n      if (!(a.state === APPEARING || typeof a.el == STRING)) {\n        if (a.state === UPDATING || a.attr) return [{\n          startEnd: {\n            start: 0,\n            end: 1\n          }\n        }];\n        if (a.el.type !== GROUP) return [{\n          initialAttr: {\n            opacity: 1\n          },\n          finalAttr: {\n            opacity: 0\n          },\n          startEnd: {\n            start: 0,\n            end: 1\n          }\n        }];\n      } else if (a.el !== GROUP) return [{\n        initialAttr: {\n          opacity: 0\n        },\n        finalAttr: {\n          opacity: a.attr && a.attr.opacity || 1\n        },\n        startEnd: {\n          start: 0,\n          end: 1\n        }\n      }];\n    }\n  }, {\n    key: \"getFallbackAnimDuration\",\n    value: function getFallbackAnimDuration(a) {\n      return durationList[a] || 0;\n    }\n  }, {\n    key: \"getFallbackAnimTimeSlots\",\n    value: function getFallbackAnimTimeSlots() {\n      return [{\n        name: '_default',\n        start: 0,\n        end: 1,\n        child: [[{\n          name: 'initial',\n          duration: .125\n        }, {\n          name: 'middle',\n          duration: .75,\n          child: [[{\n            name: 'axis',\n            duration: .25\n          }, {\n            name: 'plot',\n            duration: .75\n          }]]\n        }, {\n          name: 'final',\n          duration: .125\n        }]]\n      }];\n    }\n  }]);\n\n  return AnimationManager;\n}(ComponentInterface);\n\nexport default AnimationManager;","map":null,"metadata":{},"sourceType":"module"}