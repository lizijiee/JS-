{"ast":null,"code":"var UNDEF,\n    attrTypeNum = 1,\n    attrTypeBool = 2;\nvar attribDefs,\n    blankObj = {},\n    mathMax = Math.max;\n\nfunction parseConfiguration(a, b, c, d, e, f) {\n  var g,\n      h,\n      i,\n      j,\n      k = 1;\n\n  for (g in attribDefs = attribDefs || blankObj, d = d || blankObj, f = f || blankObj, e = e || {}, a) {\n    d[g] || (h = a[g], (h || !1 === h || 0 === h) && (i = (j = f[g] || attribDefs[g]) && j.type, i === attrTypeNum ? (h = +h, isNaN(h) || (b[g] = h)) : i === attrTypeBool ? (h = +h, isNaN(h) || (b[g] = !!h)) : b[g] = h));\n  }\n\n  if (c) for (g in b) {\n    b[g] === UNDEF && (j = f[g] || attribDefs[g]) && j.pAttr && (b[g] = c[j.pAttr]);\n  }\n\n  for (; k;) {\n    for (g in k = 0, b) {\n      b[g] === UNDEF && (j = f[g] || attribDefs[g]) && (j.attr ? (h = b[j.attr]) !== UNDEF && (b[g] = h, k += 1) : j.parser && (h = j.parser(b, c, e)) !== UNDEF && (b[g] = h, k += 1));\n    }\n  }\n}\n\nfunction setAttribDefs(a, b) {\n  var c, d;\n\n  for (d in attribDefs = attribDefs || {}, 'string' == typeof a ? (c = {}, c[a] = b) : c = a, c) {\n    attribDefs[d] || (attribDefs[d] = c[d]);\n  }\n}\n\nfunction hasAttribDefs(a) {\n  return !!attribDefs[a];\n}\n\nattribDefs = {\n  setBorderWidth: {\n    type: 1,\n    pAttr: 'plotborderthickness'\n  },\n  plotborderthickness: {\n    type: 1,\n    pAttr: 'plotborderthickness'\n  },\n  showBorderEffect: {\n    parser: function parser() {\n      var a = arguments[1];\n      return 1 == +a.showplotborder && a.plotborderthickness === .1 ? 1 : 0;\n    }\n  },\n  alphaanimation: {\n    type: 1\n  },\n  showplotborder: {\n    type: 1,\n    pAttr: 'showplotborder'\n  },\n  zeroplanethickness: {\n    type: 1\n  },\n  showzeroplaneontop: {\n    type: 1\n  },\n  stickytracking: {\n    type: 1\n  },\n  usemessagelog: {\n    type: 1\n  },\n  showtooltip: {\n    type: 1,\n    pAttr: 'showtooltip'\n  },\n  seriesnameintooltip: {\n    type: 1\n  },\n  plothovereffect: {\n    type: 1,\n    attr: 'anchorhovereffect'\n  },\n  anchorhovereffect: {\n    type: 1,\n    attr: 'showhovereffect'\n  },\n  showhovereffect: {\n    type: 1\n  },\n  linethickness: {\n    type: 1,\n    pAttr: 'linethickness'\n  },\n  dashed: {\n    type: 1,\n    pAttr: 'linedashed'\n  },\n  linedashed: {\n    type: 1,\n    attr: 'plotborderdashed'\n  },\n  plotborderdashed: {\n    type: 1,\n    pAttr: 'plotborderdashed'\n  },\n  linedashlen: {\n    type: 1,\n    pAttr: 'linedashlen'\n  },\n  linedashgap: {\n    type: 1,\n    pAttr: 'linedashgap'\n  },\n  anchoralpha: {\n    pAttr: 'anchoralpha'\n  },\n  anchorsides: {\n    type: 1,\n    pAttr: 'anchorsides'\n  },\n  anchorradius: {\n    type: 1,\n    pAttr: 'anchorradius'\n  },\n  anchorbgalpha: {\n    pAttr: 'anchorbgalpha'\n  },\n  anchorbgcolor: {\n    pAttr: 'anchorbgcolor'\n  },\n  anchorbordercolor: {\n    pAttr: 'anchorbordercolor'\n  },\n  anchorstartangle: {\n    type: 1,\n    pAttr: 'anchorstartangle'\n  },\n  anchorimageurl: {\n    pAttr: 'anchorimageurl'\n  },\n  anchorimagescale: {\n    type: 1,\n    pAttr: 'anchorimagescale'\n  },\n  anchorimagealpha: {\n    pAttr: 'anchorimagealpha'\n  },\n  anchorimagepadding: {\n    type: 1,\n    pAttr: 'anchorimagepadding'\n  },\n  anchorborderthickness: {\n    type: 1,\n    pAttr: 'anchorborderthickness'\n  },\n  anchorshadow: {\n    type: 1,\n    pAttr: 'anchorshadow'\n  },\n  valuepadding: {\n    type: 1,\n    pAttr: 'valuepadding'\n  },\n  valueposition: {\n    pAttr: 'valueposition'\n  },\n  plotfillangle: {\n    type: 1,\n    pAttr: 'plotfillangle'\n  },\n  useplotgradientcolor: {\n    type: 1\n  },\n  rotatevalues: {\n    type: 1,\n    pAttr: 'rotatevalues'\n  },\n  includeinlegend: {\n    type: 1\n  },\n  connectnulldata: {\n    type: 1\n  },\n  plotfillalpha: {\n    pAttr: 'plotfillalpha'\n  },\n  alpha: {\n    pAttr: 'linealpha'\n  },\n  linealpha: {\n    pAttr: 'plotfillalpha'\n  },\n  showvalues: {\n    type: 1,\n    pAttr: 'showvalues'\n  },\n  showpercentvalues: {\n    type: 1,\n    parser: function parser(a) {\n      return a.isstacked && a.stack100percent ? 1 : 0;\n    }\n  },\n  showpercentintooltip: {\n    type: 1,\n    parser: function parser(a) {\n      return a.isstacked && a.stack100percent ? 1 : 0;\n    }\n  },\n  stack100percent: {\n    type: 1,\n    attr: 'usepercentdistribution'\n  },\n  drawfullareaborder: {\n    type: 1\n  },\n  use3dlineshift: {\n    type: 1\n  },\n  parentyaxis: {\n    type: 1\n  },\n  radarborderthickness: {\n    type: 1\n  },\n  radarborderradius: {\n    type: 1\n  },\n  gaugeoriginx: {\n    type: 1\n  },\n  hasgaugeoriginx: {\n    attr: 'gaugeoriginx'\n  },\n  gaugeoriginy: {\n    type: 1\n  },\n  hasgaugeoriginy: {\n    attr: 'gaugeoriginy'\n  },\n  gaugeradius: {\n    type: 1\n  },\n  hasgaugeradius: {\n    attr: 'gaugeradius'\n  },\n  showgaugeborder: {\n    type: 1\n  },\n  setAdaptiveMin: {\n    type: 1\n  },\n  adjustDiv: {\n    type: 1\n  },\n  axisNameWidth: {\n    type: 1\n  },\n  rotateAxisName: {\n    type: 1\n  },\n  useEllipsesWhenOverflow: {\n    type: 1\n  },\n  showZeroPlane: {\n    type: 1\n  },\n  zeroPlaneAlpha: {\n    type: 1\n  },\n  showZeroPlaneValue: {\n    type: 1\n  },\n  zeroPlaneOnTop: {\n    type: 1\n  },\n  trendlineThickness: {\n    type: 1\n  },\n  showTrendlinesOnTop: {\n    type: 1\n  },\n  trendlinesAreDashed: {\n    type: 1\n  },\n  trendlinesDashLen: {\n    type: 1\n  },\n  trendlinesDashGap: {\n    type: 1\n  },\n  showTrendlines: {\n    type: 1\n  },\n  showTrendlineLabels: {\n    type: 1\n  },\n  showLabels: {\n    type: 1\n  },\n  rotateLabels: {\n    type: 1\n  },\n  slantLabel: {\n    type: 1\n  },\n  showAxisValues: {\n    type: 1\n  },\n  showTooltip: {\n    type: 1\n  },\n  maxLabelHeight: {\n    type: 1\n  },\n  useroundedges: {\n    type: 1,\n    pAttr: 'useroundedges'\n  },\n  placevaluesinside: {\n    type: 1\n  },\n  plotpaddingpercent: {\n    type: 1\n  },\n  use3dlighting: {\n    type: 1,\n    pAttr: 'use3dlighting'\n  },\n  usedataplotcolorforlabels: {\n    type: 1\n  },\n  plotspacepercent: {\n    type: 1,\n    parser: function parser(a) {\n      return mathMax(a.plotspacepercent % 100, 0);\n    }\n  },\n  ratio: {\n    pAttr: 'plotfillratio'\n  },\n  base: {\n    type: 1\n  },\n  showMinorDivLineValues: {\n    type: 1\n  },\n  numMinorDivLines: {\n    type: 1\n  },\n  majorTMNumber: {\n    type: 1\n  },\n  majorTMHeight: {\n    type: 1\n  },\n  showTickMarks: {\n    type: 1\n  },\n  majorTMThickness: {\n    type: 1\n  },\n  adjustTM: {\n    type: 2\n  },\n  minorTMNumber: {\n    type: 1\n  },\n  minorTMThickness: {\n    type: 1\n  },\n  tickMarkDistance: {\n    type: 1\n  },\n  placeTicksInside: {\n    type: 1\n  },\n  placeValuesInside: {\n    type: 1\n  },\n  axisValuePadding: {\n    type: 1\n  },\n  gridLineWidth: {\n    type: 1\n  },\n  showRadarBorder: {\n    type: 1\n  },\n  radarBorderThickness: {\n    type: 1\n  },\n  maxcolwidth: {\n    type: 1,\n    parser: function parser(a) {\n      return Math.abs(a.maxcolwidth);\n    }\n  },\n  maxbarheight: {\n    type: 1,\n    parser: function parser(a) {\n      return Math.abs(a.maxbarheight);\n    }\n  },\n  plotborderalpha: {\n    parser: function parser(a, b) {\n      return b.plotborderalpha || a.plotfillalpha;\n    }\n  },\n  autoscale: {\n    type: 1\n  },\n  plotborderdashlen: {\n    type: 1,\n    pAttr: 'plotborderdashlen'\n  },\n  plotborderdashgap: {\n    type: 1,\n    pAttr: 'plotborderdashgap'\n  },\n  plotfillratio: {\n    pAttr: 'plotfillratio'\n  },\n  drawverticaljoins: {\n    type: 1,\n    pAttr: 'drawverticaljoins'\n  },\n  useforwardsteps: {\n    type: 1,\n    pAttr: 'useforwardsteps'\n  },\n  minimizetendency: {\n    type: 1\n  },\n  usepercentdistribution: {\n    type: 1\n  },\n  stepatmiddle: {\n    type: 1\n  }\n};\nexport { attribDefs, parseConfiguration, setAttribDefs, hasAttribDefs };","map":null,"metadata":{},"sourceType":"module"}