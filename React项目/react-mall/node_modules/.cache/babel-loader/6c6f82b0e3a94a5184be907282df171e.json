{"ast":null,"code":"var _SvgDeCanvo,\n    win = 'undefined' == typeof window ? null : window,\n    doc = win.document,\n    drawLib = {},\n    utilLib = {};\n\n_SvgDeCanvo = function SvgDeCanvo(a, b, c, d, e, f, g) {\n  var h = {\n    svg: '',\n    context: '',\n    callBack: '',\n    imageArr: [],\n    canvas: '',\n    dimention: {}\n  };\n  if (!(this instanceof _SvgDeCanvo)) throw new Error('This function should be used as class');\n  this._getStore = function (a) {\n    return 'undefined' != typeof h[a] && h[a];\n  }, this._setStore = function (a, b) {\n    'undefined' != typeof h[a] && (h[a] = b);\n  }, this._setStore('dimention', {\n    x: c,\n    y: d,\n    width: e,\n    height: f\n  }), a && this.setSVG(a), b && this.setContext(b), g && this.setCallback(g), this.drawOnCanvas();\n}, _SvgDeCanvo.prototype.setContext = function (a) {\n  var b;\n  if (a.getContext && a.getContext('2d')) b = a.getContext('2d'), this._setStore('canvas', a), this._setStore('context', b);else throw new Error('Please provide valid canvas');\n}, _SvgDeCanvo.prototype.getContext = function () {\n  return this._getStore('context');\n}, _SvgDeCanvo.prototype.setSVG = function (a) {\n  var b;\n  if ('undefined' != typeof a.documentElement) b = a, this._setStore('svg', b);else if ('<' === a.substr(0, 1)) b = utilLib.StrToDom(a), this._setStore('svg', b);else throw new Error('Please provide valid SVG');\n}, _SvgDeCanvo.prototype.getSVG = function () {\n  return this._getStore('svg');\n}, _SvgDeCanvo.prototype.setCallback = function (a) {\n  'function' == typeof a && this._setStore('callBack', a);\n}, _SvgDeCanvo.prototype.getCallback = function () {\n  return this._getStore('callBack');\n}, _SvgDeCanvo.prototype.drawOnCanvas = function (a, b, c, d, e, f, g) {\n  var h, i, j, k, l, m, n, o;\n  a && this.setSVG(a), b && this.setContext(b), g && this.setCallback(g), b = b || this._getStore('canvas'), n = this._getStore('dimention'), g = this.getCallback(), h = this.getContext(), i = this.getSVG();\n  i && h && (o = utilLib.getSvgDimention(i), j = o.width, k = o.height, c = c || n.x || 0, d = d || n.y || 0, e = e || n.width || j, f = f || n.height || k, l = o.width ? e / j : 1, m = o.height ? f / k : 1, utilLib.startTransform('translate(' + c + ',' + d + ') scale(' + l + ',' + m + ')', h), h.save(), h.fillStyle = '#ffffff', h.fillRect(0, 0, e, f), h.restore(), utilLib.storeImagesInArr(this), utilLib.drawNodes([i], [], this, h, function () {\n    'function' == typeof g && g(), utilLib.resetTransform(h);\n  }));\n}, drawLib.common = function (a, b, c, d, e) {\n  var f,\n      g,\n      h,\n      j,\n      k = a.childNodes,\n      l = function l() {\n    a.attributes && d.restore(), e && e();\n  };\n\n  for (g in b) {\n    b.hasOwnProperty(g) && 'class' !== b[g].name && 'id' !== b[g].name && 'transform' !== b[g].name && 'clip-path' !== b[g].name && 'object' == typeof b[g] && a.attributes && !a.attributes[b[g].name] && a.setAttribute([b[g].name], b[g].value);\n  }\n\n  if (a.attributes && a.attributes.style) for (g in h = a.attributes.style.value.replace(/;$/, '').split(';'), h) {\n    if (h.hasOwnProperty(g) && (j = h[g].split(':')[0].trim(), !a.attributes[j] || 'undefined' === a.attributes[j].value)) try {\n      a.setAttribute(j, h[g].split(':')[1].trim());\n    } catch (a) {}\n  }\n  a.attributes && (d.save(), a.attributes.transform && utilLib.startTransform(a.attributes.transform.value, d), a.attributes['clip-path'] && utilLib.applyClip(a.attributes['clip-path'].value, d, c)), 0 !== k.length && (1 !== k.length || k[0].tagName) ? utilLib.drawNodes(k, 'svg' === a.tagName ? [] : a.attributes, c, d, l) : 'undefined' == typeof a.tagName ? l() : (f = 'draw' + a.tagName, drawLib[f] ? a.attributes.display && 'none' === a.attributes.display.value ? l() : drawLib[f](a, d, c, 'draw', l) : l());\n}, drawLib.drawtext = function (a, b, c, d, e) {\n  this.drawtspan(a, b, c, d, e);\n}, drawLib.drawtspan = function (a, b, c, d, e) {\n  var f,\n      g,\n      h,\n      i,\n      j,\n      k = a.innerHTML || a.textContent,\n      l = a.attributes.x ? a.attributes.x.value : 0,\n      m = a.attributes.y ? a.attributes.y.value : 0,\n      n = a.attributes.dx ? a.attributes.dx.value : 0,\n      o = a.attributes.dy ? a.attributes.dy.value : 0,\n      p = 'serief',\n      q = 'normal',\n      r = '16px',\n      s = [];\n  doc.getElementsByTagName('body')[0] && (f = win.getComputedStyle(doc.getElementsByTagName('body')[0], null), f.getPropertyValue('font-family') && (p = f.getPropertyValue('font-family')), f.getPropertyValue('font-weight') && (q = f.getPropertyValue('font-weight')), f.getPropertyValue('font-size') && (r = f.getPropertyValue('font-size'))), g = a.attributes['font-family'] ? a.attributes['font-family'].value : p, h = a.attributes['font-weight'] ? a.attributes['font-weight'].value : q, i = a.attributes['text-anchor'] ? a.attributes['text-anchor'].value : 'start', j = a.attributes['font-size'] ? a.attributes['font-size'].value : r, l = +l + +n, m = +m + +o, k = k.trim(), i = 'middle' === i ? 'center' : i, b.save(), b.font = h + ' ' + j + ' ' + g, b.textAlign = i, 'draw' === d && ((!a.attributes.fill || a.attributes.fill && 'none' !== a.attributes.fill.value) && (utilLib.applyFillEffect(a, b, c, s), b.fillText(k, l, m), utilLib.endFillEffect(a, b)), (!a.attributes.stroke || a.attributes.stroke && 'none' !== a.attributes.stroke.value) && (utilLib.applyStrokeEffect(a, b, c, s), b.strokeText(k, l, m), utilLib.endStrokeEffect(a, b))), b.restore(), 'function' == typeof e && e();\n}, drawLib.drawcircle = function (a, b, c, d, e) {\n  var f = +a.attributes.cx.value,\n      g = +a.attributes.cy.value,\n      h = +a.attributes.r.value,\n      i = [];\n  b.beginPath(), b.arc(f, g, h, 0, 2 * Math.PI), utilLib.bBoxFromPoint([f, 1 * f + 1 * h, 1 * f - 1 * h], [g, 1 * g + 1 * h, 1 * g - 1 * h], i), 'draw' === d && ((!a.attributes.fill || a.attributes.fill && 'none' !== a.attributes.fill.value) && (utilLib.applyFillEffect(a, b, c, i), b.fill(), utilLib.endFillEffect(a, b)), (!a.attributes.stroke || a.attributes.stroke && 'none' !== a.attributes.stroke.value) && (utilLib.applyStrokeEffect(a, b, c, i), b.stroke(), utilLib.endStrokeEffect(a, b))), b.closePath(), 'function' == typeof e && e();\n}, drawLib.drawrect = function (a, b, c, d, e) {\n  var f = +a.attributes.x.value,\n      g = +a.attributes.y.value,\n      h = a.attributes.rx ? +a.attributes.rx.value : 0,\n      i = a.attributes.ry ? +a.attributes.ry.value : 0,\n      j = +a.attributes.height.value,\n      k = +a.attributes.width.value,\n      l = [],\n      m = b.lineCap;\n  b.lineCap = 'square', utilLib.bBoxFromPoint([f, f + k], [g, g + j], l), b.beginPath(), b.moveTo(f + h, g), b.lineTo(f + k - h, g), b.quadraticCurveTo(f + k, g, f + k, g + i), b.lineTo(f + k, g + j - i), b.quadraticCurveTo(f + k, g + j, f + k - h, g + j), b.lineTo(f + h, g + j), b.quadraticCurveTo(f, g + j, f, g + j - i), b.lineTo(f, g + i), b.quadraticCurveTo(f, g, f + h, g), 'draw' === d && ((!a.attributes.fill || a.attributes.fill && 'none' !== a.attributes.fill.value) && (utilLib.applyFillEffect(a, b, c, l), b.fill(), utilLib.endFillEffect(a, b)), (!a.attributes.stroke || a.attributes.stroke && 'none' !== a.attributes.stroke.value) && (utilLib.applyStrokeEffect(a, b, c, l), b.stroke(), utilLib.endStrokeEffect(a, b))), b.closePath(), b.lineCap = m, 'function' == typeof e && e();\n}, drawLib.drawellipse = function (a, b, c, d, e) {\n  var f = .5522848,\n      g = +a.attributes.cx.value,\n      h = +a.attributes.cy.value,\n      i = +a.attributes.rx.value,\n      j = +a.attributes.ry.value,\n      k = i * f,\n      l = j * f,\n      m = g + i,\n      n = h + j,\n      o = [];\n  b.beginPath(), b.moveTo(g - i, h), b.bezierCurveTo(g - i, h - l, g - k, h - j, g, h - j), b.bezierCurveTo(g + k, h - j, m, h - l, m, h), b.bezierCurveTo(m, h + l, g + k, n, g, n), b.bezierCurveTo(g - k, n, g - i, h + l, g - i, h), utilLib.bBoxFromPoint([g + i, g - i], [h + j, h - j], o), 'draw' === d && ((!a.attributes.fill || a.attributes.fill && 'none' !== a.attributes.fill.value) && (utilLib.applyFillEffect(a, b, c, o), b.fill(), utilLib.endFillEffect(a, b)), (!a.attributes.stroke || a.attributes.stroke && 'none' !== a.attributes.stroke.value) && (utilLib.applyStrokeEffect(a, b, c, o), b.stroke(), utilLib.endStrokeEffect(a, b))), b.closePath(), 'function' == typeof e && e();\n}, drawLib.drawimage = function (a, b, c, d, e) {\n  var f,\n      g = a.attributes.x ? +a.attributes.x.value : 0,\n      h = a.attributes.y ? +a.attributes.y.value : 0,\n      i = a.attributes.height ? +a.attributes.height.value : 0,\n      j = a.attributes.width ? +a.attributes.width.value : 0,\n      k = c._getStore('imageArr');\n\n  b.save(), a.attributes.opacity && (b.globalAlpha = a.attributes.opacity.value), a.attributes['xlink:href'] ? (f = a.attributes['xlink:href'].value, 'complete' === k[f].status ? (b.drawImage(k[f].obj, g, h, j, i), b.globalAlpha = 1, b.restore(), 'function' == typeof e && e()) : 'error' === k[f].status ? (b.globalAlpha = 1, b.restore(), 'function' == typeof e && e()) : 'progress' === k[f].status ? (k[f].callback = function () {\n    b.drawImage(k[f].obj, g, h, j, i), b.globalAlpha = 1, b.restore(), 'function' == typeof e && e();\n  }, k[f].errCallback = function () {\n    b.globalAlpha = 1, b.restore(), 'function' == typeof e && e();\n  }) : (b.globalAlpha = 1, b.restore(), 'function' == typeof e && e())) : (b.globalAlpha = 1, b.restore(), 'function' == typeof e && e());\n}, drawLib.drawpath = function (b, c, d, e, f) {\n  var g,\n      h,\n      j,\n      k,\n      l = Math.sqrt,\n      m = Math.pow,\n      n = Math.sin,\n      o = Math.cos,\n      p = Math.PI,\n      q = b.attributes.d.value.match(/[a-z][^a-z\"]*/gi),\n      r = [],\n      s = 0,\n      t = 0,\n      u = {};\n\n  for (g in c.beginPath(), q) {\n    if (q.hasOwnProperty(g)) switch (h = q[g].substring(0, 1), j = utilLib.getArgsAsArray(q[g].substring(1, q[g].length)), h) {\n      case 'M':\n        s = +j[0], t = +j[1], c.moveTo(s, t), u.cx = s, u.cy = t;\n        break;\n\n      case 'm':\n        s += +j[0], t += +j[1], c.moveTo(s, t), u.cx = s, u.cy = t;\n        break;\n\n      case 'L':\n        for (k = 0; j[k]; k += 2) {\n          utilLib.bBoxFromPoint([s, j[k]], [t, j[k + 1]], r), s = +j[k], t = +j[k + 1], c.lineTo(s, t);\n        }\n\n        break;\n\n      case 'l':\n        for (k = 0; j[k]; k += 2) {\n          utilLib.bBoxFromPoint([s, 1 * s + 1 * j[k]], [t, 1 * t + 1 * j[k + 1]], r), s += +j[k], t += +j[k + 1], c.lineTo(s, t);\n        }\n\n        break;\n\n      case 'V':\n        for (k = 0; j[k]; k += 1) {\n          utilLib.bBoxFromPoint([s], [t, j[k]], r), t = +j[k], c.lineTo(s, t);\n        }\n\n        break;\n\n      case 'v':\n        for (k = 0; j[k]; k += 1) {\n          utilLib.bBoxFromPoint([s], [t, 1 * t + 1 * j[k]], r), t += +j[k], c.lineTo(s, t);\n        }\n\n        break;\n\n      case 'H':\n        for (k = 0; j[k]; k += 1) {\n          utilLib.bBoxFromPoint([s, j[k]], [t], r), s = +j[k], c.lineTo(s, t);\n        }\n\n        break;\n\n      case 'h':\n        for (k = 0; j[k]; k += 1) {\n          utilLib.bBoxFromPoint([s, 1 * s + 1 * j[k]], [t], r), s += +j[k], c.lineTo(s, t);\n        }\n\n        break;\n\n      case 'Q':\n        for (k = 0; j[k]; k += 4) {\n          utilLib.qBezierBBox(s, t, j[k], j[k + 1], j[k + 2], j[k + 3], r), c.quadraticCurveTo(+j[k], +j[k + 1], +j[k + 2], +j[k + 3]), s = +j[k + 2], t = +j[k + 3];\n        }\n\n        break;\n\n      case 'q':\n        for (k = 0; j[k]; k += 4) {\n          utilLib.qBezierBBox(s, t, s + 1 * j[k], t + 1 * j[k + 1], 1 * s + 1 * j[k + 2], 1 * t + 1 * j[k + 3], r), c.quadraticCurveTo(s + 1 * j[k], t + 1 * j[k + 1], s += +j[k + 2], t += +j[k + 3]);\n        }\n\n        break;\n\n      case 'C':\n        for (k = 0; j[k]; k += 6) {\n          utilLib.cBezierBBox(s, t, j[k], j[k + 1], j[k + 2], j[k + 3], j[k + 4], j[k + 5], r), c.bezierCurveTo(j[k], j[k + 1], j[k + 2], j[k + 3], j[k + 4], j[k + 5]), s = +j[k + 4], t = +j[k + 5];\n        }\n\n        break;\n\n      case 'c':\n        for (k = 0; j[k]; k += 6) {\n          utilLib.cBezierBBox(s, t, s + 1 * j[k], 1 * t + 1 * j[k + 1], s + 1 * j[k + 2], 1 * t + 1 * j[k + 3], s + 1 * j[k + 4], 1 * t + 1 * j[k + 5], r), c.bezierCurveTo(s + +j[k], t + +j[k + 1], s + +j[k + 2], t + +j[k + 3], s += +j[k + 4], t += +j[k + 5]);\n        }\n\n        break;\n\n      case 'a':\n      case 'A':\n        for (k = 0; j[k]; k += 7) {\n          var v,\n              w,\n              x,\n              y,\n              z,\n              A,\n              B,\n              C,\n              D,\n              E,\n              F,\n              G,\n              H,\n              I,\n              J,\n              K,\n              L,\n              M,\n              N,\n              O = +j[k],\n              P = +j[k + 1];\n\n          if (v = +j[k + 2] * (p / 180), w = +j[k + 3], x = +j[k + 4], y = +j[k + 5], z = +j[k + 6], A = o(v) * (s - y) / 2 + n(v) * (t - z) / 2, B = -n(v) * (s - y) / 2 + o(v) * (t - z) / 2, O = 0 > O ? -O : O, P = 0 > P ? -P : P, K = m(A, 2) / m(O, 2) + m(B, 2) / m(P, 2), 1 < K && (O *= l(K), P *= l(K)), L = O > P ? O : P, M = O > P ? 1 : O / P, N = O > P ? P / O : 1, C = w == x ? -1 : 1, D = C * l((m(O, 2) * m(P, 2) - m(O, 2) * m(B, 2) - m(P, 2) * m(A, 2)) / (m(O, 2) * m(B, 2) + m(P, 2) * m(A, 2))), isNaN(D) && (D = 0), E = D * (O * B) / P, F = -D * (P * A) / O, G = E * o(v) - F * n(v) + (s + y) / 2, H = E * n(v) + F * o(v) + (t + z) / 2, I = utilLib.angleBetweenVectors(1, 0, (A - E) / O, (B - F) / P), J = utilLib.angleBetweenVectors((A - E) / O, (B - F) / P, (-A - E) / O, (-B - F) / P), 0 === x && 0 < J && (J -= 360 * (p / 180)), 1 === x && 0 > J && (J += 360 * (p / 180)), 0 === O && 0 === P) {\n            c.lineTo(y, z);\n            break;\n          }\n\n          c.save();\n          var Q = utilLib.combineTransformMatrix([[1, 0, G, 0, 1, H], [o(v), n(v), 0, n(v), o(v), 0], [M, 0, 0, 0, N, 0]]);\n          c.transform(Q[0], Q[3], Q[1], Q[4], Q[2], Q[5]), c.arc(0, 0, L, I, I + J, 1 - x), c.restore(), utilLib.arcBBox(0, 0, L, I, I + J, 1 - x, [Q[0], Q[3], Q[1], Q[4], Q[2], Q[5]], r), 'A' === h ? (s = +j[k + 5], t = +j[k + 6]) : (s += +j[k + 5], t += +j[k + 6]);\n        }\n\n        break;\n\n      case 'Z':\n      case 'z':\n        c.closePath(), s = u.cx, t = u.cy;\n        break;\n\n      default:\n    }\n  }\n\n  'draw' === e && ((!b.attributes.fill || b.attributes.fill && 'none' !== b.attributes.fill.value) && (utilLib.applyFillEffect(b, c, d, r), c.fill(), utilLib.endFillEffect(b, c)), (!b.attributes.stroke || b.attributes.stroke && 'none' !== b.attributes.stroke.value) && (utilLib.applyStrokeEffect(b, c, d, r), c.stroke(), utilLib.endStrokeEffect(b, c)), f());\n}, utilLib.drawNodes = function (a, b, c, d, e) {\n  var f = a.length,\n      g = -1,\n      h = 0,\n      j = 0,\n      k = function k() {\n    var i;\n    ++g, g < f ? (i = a[g], i.tagName && 'defs' === i.tagName && (++g, i = a[g]), i.attributes && (i.attributes.dy && (j = i.attributes.dy.value = 1 * i.attributes.dy.value + 1 * j), i.attributes.dx && (h = i.attributes.dx.value = 1 * i.attributes.dx.value + 1 * h)), drawLib.common(i, b, c, d, k)) : e && e();\n  };\n\n  k();\n}, utilLib.getSvgDimention = function (a) {\n  var b,\n      c = {\n    width: 0,\n    height: 0\n  };\n  return b = a.childNodes && a.childNodes[0] && a.childNodes[0].attributes, c.width = +(b.width && b.width.value || 0), c.height = +(b.height && b.height.value || 0), c;\n}, utilLib.storeImagesInArr = function (a) {\n  var b,\n      c,\n      d,\n      e,\n      f = a.getSVG();\n\n  for (e in d = a._getStore('imageArr'), b = f.getElementsByTagName('image'), b) {\n    b.hasOwnProperty(e) && b[e].attributes && b[e].attributes['xlink:href'] && (c = b[e].attributes['xlink:href'].value, !d[c] && (d[c] = [], d[c].status = 'progress', d[c].callback = null, d[c].obj = new Image(), d[c].obj.onload = function (a) {\n      return function () {\n        var b = d[a].callback;\n        b ? (d[a].status = 'complete', b()) : d[a].status = 'complete';\n      };\n    }(c), d[c].obj.onerror = function (a) {\n      return function () {\n        var b = d[a].errCallback;\n        b ? (d[a].status = 'error', b()) : d[a].status = 'error';\n      };\n    }(c), d[c].obj.src = c));\n  }\n}, utilLib.startTransform = function (a, b) {\n  var c,\n      d,\n      e = Math.tan,\n      f = Math.PI,\n      g = a.match(/[^\\s][a-z,0-9.\\-(\\s]+\\)/gi);\n\n  for (d in g) {\n    g.hasOwnProperty(d) && (-1 < g[d].indexOf('matrix') && (c = utilLib.stringToArgs(g[d]), b.transform(c[0], c[1], c[2], c[3], c[4], c[5])), -1 < g[d].indexOf('translate') && (c = utilLib.stringToArgs(g[d]), b.translate(c[0] || 0, c[1] || 0)), -1 < g[d].indexOf('rotate') && (c = utilLib.stringToArgs(g[d]), 3 === c.length ? (b.translate(c[1], c[2]), b.rotate(c[0] * (f / 180)), b.translate(-c[1], -c[2])) : b.rotate(c[0] * (f / 180))), -1 < g[d].indexOf('scale') && (c = utilLib.stringToArgs(g[d]), 1 === c.length ? b.scale(c[0] || 1, c[0] || 1) : b.scale(c[0] || 1, c[1] || 1)), -1 < g[d].indexOf('skewX') && (c = utilLib.stringToArgs(g[d]), b.transform(1, 0, e(c[0] * (f / 180)), 1, 0, 0)), -1 < g[d].indexOf('skewY') && (c = utilLib.stringToArgs(g[d]), b.transform(1, e(c[0] * (f / 180)), 0, 1, 0, 0)));\n  }\n}, utilLib.resetTransform = function (a) {\n  a.setTransform(1, 0, 0, 1, 0, 0);\n}, utilLib.stringToArgs = function (a) {\n  var b = /\\(([^)]+)/.exec(a)[1];\n  return utilLib.getArgsAsArray(b);\n}, utilLib.getArgsAsArray = function (a) {\n  var b;\n\n  for (a = a.trim().split(/[\\s,]+/), b = 0; b < a.length; b++) {\n    a[b].trim(), 0 === a[b].length && a.splice(b, 1);\n  }\n\n  return a;\n}, utilLib.applyFillEffect = function (a, b, c, d) {\n  var e;\n  b.globalAlpha = a.attributes['fill-opacity'] && 'none' !== a.attributes['fill-opacity'].value ? a.attributes['fill-opacity'].value : 1, a.attributes.fill && -1 < a.attributes.fill.value.indexOf('url(') ? (e = utilLib.getFillStyleById(/url\\(.*#([^)'\"]+)/.exec(a.attributes.fill.value)[1], b, c, d), b.fillStyle = e) : a.attributes.fill ? b.fillStyle = a.attributes.fill.value : b.fillStyle = '#000000';\n}, utilLib.endFillEffect = function (a, b) {\n  b.globalAlpha = 1;\n}, utilLib.applyStrokeEffect = function (a, b) {\n  a.attributes['stroke-opacity'] && 'none' !== a.attributes['stroke-opacity'].value && (b.globalAlpha = a.attributes['stroke-opacity'].value), a.attributes['stroke-width'] && (b.lineWidth = a.attributes['stroke-width'].value, '0' === a.attributes['stroke-width'].value && (b.globalAlpha = 0)), a.attributes['stroke-linecap'] && 'none' !== a.attributes['stroke-linecap'].value && (b.lineCap = a.attributes['stroke-linecap'].value), a.attributes['stroke-linejoin'] && 'none' !== a.attributes['stroke-linejoin'].value && (b.lineJoin = a.attributes['stroke-linejoin'].value), a.attributes['stroke-dasharray'] && 'none' !== a.attributes['stroke-dasharray'].value && b.setLineDash && b.setLineDash(utilLib.getArgsAsArray(a.attributes['stroke-dasharray'].value)), b.strokeStyle = a.attributes.stroke ? a.attributes.stroke.value : '#000000';\n}, utilLib.endStrokeEffect = function (a, b) {\n  a.attributes['stroke-opacity'] && 'none' !== a.attributes['stroke-opacity'].value && (b.globalAlpha = 1, b.setLineDash && b.setLineDash([]), b.lineWidth = 1), b.globalAlpha = 1;\n}, utilLib.applyClip = function (b, c, d) {\n  var e,\n      f,\n      g,\n      h,\n      i,\n      j = d.getSVG();\n\n  if (-1 !== b.indexOf('url(')) {\n    for (h in e = /url\\(.*#([^)'\"]+)/.exec(b)[1], f = j.getElementById(e), f.attributes && (c.save(), f.attributes.transform && utilLib.startTransform(f.attributes.transform.value, c)), g = f.childNodes, g) {\n      g.hasOwnProperty(h) && g[h].tagName && g[h].constructor !== Array && (i = 'draw' + g[h].tagName, g[h].attributes && (c.save(), g[h].attributes.transform && utilLib.startTransform(g[h].attributes.transform.value, c)), drawLib[i] && (drawLib[i](g[h], c, d, 'clip'), c.closePath()), g[h].attributes && c.restore());\n    }\n\n    f.attributes && c.restore(), c.clip();\n  }\n}, utilLib.getFillStyleById = function (a, b, c, d) {\n  var e = c.getSVG(),\n      f = e.getElementById(a);\n  return 'linearGradient' === f.tagName ? utilLib.getLinearGradient(f, b, d) : 'radialGradient' === f.tagName ? utilLib.getRadialGradient(f, b, d) : '#FFFFFF';\n}, utilLib.getLinearGradient = function (b, c, d) {\n  var e,\n      f,\n      g,\n      h,\n      i,\n      j = b.attributes.x1 ? utilLib.getPercentValue(b.attributes.x1.value, d.xMax - d.xMin, d.xMin) : 0,\n      k = b.attributes.y1 ? utilLib.getPercentValue(b.attributes.y1.value, d.yMax - d.yMin, d.yMin) : 0,\n      l = b.attributes.x2 ? utilLib.getPercentValue(b.attributes.x2.value, d.xMax - d.xMin, d.xMin) : 0,\n      m = b.attributes.y2 ? utilLib.getPercentValue(b.attributes.y2.value, d.yMax - d.yMin, d.yMin) : 0;\n\n  for (g in e = c.createLinearGradient(j, k, l, m), f = b.childNodes, f) {\n    f.hasOwnProperty(g) && f[g].attributes && f[g].attributes['stop-color'] && (h = utilLib.toRGB(f[g].attributes['stop-color'].value), i = f[g].attributes['stop-opacity'] ? f[g].attributes['stop-opacity'].value : 1, h.status ? e.addColorStop(utilLib.getPercentValue(f[g].attributes.offset.value, 1, 0), 'rgba(' + h.r + ',' + h.g + ',' + h.b + ',' + +i + ')') : e.addColorStop(utilLib.getPercentValue(f[g].attributes.offset.value, 1, 0), f[g].attributes['stop-color'].value));\n  }\n\n  return e;\n}, utilLib.getRadialGradient = function (b, c, d) {\n  var e,\n      f,\n      g,\n      h,\n      i,\n      j = b.attributes.cx ? utilLib.getPercentValue(b.attributes.cx.value, d.xMax - d.xMin, d.xMin) : d.xMin + .5 * (d.xMax - d.xMin),\n      k = b.attributes.cy ? utilLib.getPercentValue(b.attributes.cy.value, d.yMax - d.yMin, d.yMin) : d.yMin + .5 * (d.yMax - d.yMin),\n      l = b.attributes.fx ? utilLib.getPercentValue(b.attributes.fx.value, d.xMax - d.xMin, d.xMin) : d.xMin + .5 * (d.xMax - d.xMin),\n      m = b.attributes.fy ? utilLib.getPercentValue(b.attributes.fy.value, d.yMax - d.yMin, d.yMin) : d.yMin + .5 * (d.yMax - d.yMin),\n      n = b.attributes.r ? utilLib.getPercentValue(b.attributes.r.value, (d.yMax - d.yMin + d.xMax - d.xMin) / 2, 0) : utilLib.getPercentValue('50%', (d.yMax - d.yMin + d.xMax - d.xMin) / 2, 0);\n\n  for (g in e = c.createRadialGradient(l, m, 0, j, k, n), f = b.childNodes, f) {\n    f.hasOwnProperty(g) && f[g].attributes && f[g].attributes['stop-color'] && (h = utilLib.toRGB(f[g].attributes['stop-color'].value), i = f[g].attributes['stop-opacity'] ? f[g].attributes['stop-opacity'].value : 1, h.status ? e.addColorStop(utilLib.getPercentValue(f[g].attributes.offset.value, 1, 0), 'rgba(' + h.r + ',' + h.g + ',' + h.b + ',' + +i + ')') : e.addColorStop(utilLib.getPercentValue(f[g].attributes.offset.value, 1, 0), f[g].attributes['stop-color'].value));\n  }\n\n  return e;\n}, utilLib.getPercentValue = function (a, b, c) {\n  var d;\n  return -1 === a.indexOf('%') ? 1 < a ? a : a * b + 1 * c : (d = /(\\d.*)%/.exec(a)[1], 100 < d && (d = 100), d * b / 100 + 1 * c);\n}, utilLib.bBoxFromPoint = function (a, b, c) {\n  var d = Math.max,\n      e = Math.min;\n  'undefined' != typeof c.xMin && (a.push(c.xMin, c.xMax), b.push(c.yMin, c.yMax)), c.xMin = e.apply(this, a), c.xMax = d.apply(this, a), c.yMin = e.apply(this, b), c.yMax = d.apply(this, b);\n}, utilLib.arcBBox = function (a, b, c, d, e, f, g, h) {\n  var i,\n      j,\n      k,\n      l,\n      m,\n      n,\n      o,\n      p,\n      q,\n      r,\n      s,\n      t,\n      u,\n      v = Math.max,\n      w = Math.min,\n      x = Math.sin,\n      y = Math.cos,\n      z = Math.PI;\n  g instanceof Array && (a = a * g[0] + a * g[2] + g[4], b = b * g[1] + b * g[3] + g[5]), u = function u(a, b, c) {\n    return (a = (a + 2 * z) % (2 * z), b = (b + 2 * z) % (2 * z), a <= b) ? !!(a <= c && c <= b) : a >= b ? !(a >= c && c >= b) : void 0;\n  }, i = d % (2 * z), j = e % (2 * z), f && (i = e % (2 * z), j = d % (2 * z)), k = a + c * y(i), m = b + c * x(i), l = a + c * y(j), n = b + c * x(j), s = [k, l], t = [m, n], u(i, j, 0) && (s.push(1 * a + 1 * c), t.push(b)), u(i, j, .5 * z) && (s.push(a), t.push(1 * b + 1 * c)), u(i, j, Math.PI) && (s.push(a - 1 * c), t.push(b)), u(i, j, 1.5 * z) && (s.push(a), t.push(b - 1 * c)), q = v.apply(this, s), o = w.apply(this, s), r = v.apply(this, t), p = w.apply(this, t), 'undefined' == typeof h.xMin ? (h.xMin = o, h.xMax = q, h.yMin = p, h.yMax = r) : (h.xMin = w(o, h.xMin), h.xMax = v(q, h.xMax), h.yMin = w(p, h.yMin), h.yMax = v(r, h.yMax));\n}, utilLib.qBezierBBox = function (a, b, c, d, e, f, g) {\n  var h,\n      i,\n      j,\n      k,\n      l,\n      m,\n      n,\n      o,\n      p = Math.max,\n      q = Math.min,\n      r = Math.pow,\n      s = 1 * a - 2 * c + 1 * e,\n      t = 1 * b - 2 * d + 1 * f;\n  0 == s || 0 == t ? (l = p(a, e), j = q(a, e), m = p(b, f), k = q(b, f)) : (h = (a - c) / s, i = (b - d) / t, n = a * r(1 - h, 2) + 2 * c * (1 - h) * h + e * r(h, 2), o = b * r(1 - i, 2) + 2 * d * (1 - i) * i + f * r(i, 2), l = p(a, e, n), j = q(a, e, n), m = p(b, f, o), k = q(b, f, o)), 'undefined' == typeof g.xMin ? (g.xMin = j, g.xMax = l, g.yMin = k, g.yMax = m) : (g.xMin = q(j, g.xMin), g.xMax = p(l, g.xMax), g.yMin = q(k, g.yMin), g.yMax = p(m, g.yMax));\n}, utilLib.cBezierBBox = function (d, e, f, g, h, i, j, k, l) {\n  var m,\n      n,\n      o,\n      p,\n      q,\n      r,\n      s,\n      t,\n      u,\n      v,\n      w,\n      x,\n      y,\n      z = Math.max,\n      A = Math.min,\n      B = Math.sqrt,\n      C = Math.pow;\n  null === h && null === i && (f = d + 2 / 3 * (f - d), h = e + 2 / 3 * (g - e), g = f + 1 / 3 * (j - d), i = h + 1 / 3 * (k - e)), w = function w(e, a, b, c, d) {\n    return e * C(1 - d, 3) + 3 * a * d * C(1 - d, 2) + 3 * b * d * d * (1 - d) + c * d * d * d;\n  }, q = 3 * j - 9 * h + 9 * f - 3 * d, r = 6 * d - 12 * f + 6 * h, s = 3 * f - 3 * d, t = C(r, 2) - 4 * q * s, m = d, n = d, j < m && (m = j), j > n && (n = j), 0 <= t && (u = (-r + B(t)) / (2 * q), 0 < u && 1 > u && (x = w(d, f, h, j, u), x < m && (m = x), x > n && (n = x)), v = (-r - B(t)) / (2 * q), 0 < v && 1 > v && (x = w(d, f, h, j, v), x < m && (m = x), x > n && (n = x))), q = 3 * k - 9 * i + 9 * g - 3 * e, r = 6 * e - 12 * g + 6 * i, s = 3 * g - 3 * e, t = C(r, 2) - 4 * q * s, o = e, p = e, k < o && (o = k), k > p && (p = k), 0 <= t && (u = (-r + B(t)) / (2 * q), 0 < u && 1 > u && (y = w(e, g, i, k, u), y < o && (o = y), y > p && (p = y)), v = (-r - B(t)) / (2 * q), 0 < v && 1 > v && (y = w(e, g, i, k, v), y < o && (o = y), y > p && (p = y))), 'undefined' == typeof l.xMin ? (l.xMin = m, l.xMax = n, l.yMin = o, l.yMax = p) : (l.xMin = A(m, l.xMin), l.xMax = z(n, l.xMax), l.yMin = A(o, l.yMin), l.yMax = z(p, l.yMax));\n}, utilLib.combineTransformMatrix = function (a) {\n  var b,\n      c,\n      d = a.length - 1;\n  if (0 >= d) return a[0];\n\n  for (c = a[0], b = 1; b <= d; b++) {\n    c[0] = c[0] * a[b][0] + c[1] * a[b][3], c[1] = c[0] * a[b][1] + c[1] * a[b][4], c[2] = c[0] * a[b][2] + c[1] * a[b][5] + 1 * c[2], c[3] = c[3] * a[b][0] + c[4] * a[b][3], c[4] = c[3] * a[b][1] + c[4] * a[b][4], c[5] = c[3] * a[b][2] + c[4] * a[b][5] + 1 * c[5];\n  }\n\n  return c;\n}, utilLib.angleBetweenVectors = function (a, b, c, d) {\n  var e = Math.sqrt,\n      f = Math.pow,\n      g = a * d < b * c ? -1 : 1,\n      h = e(f(a, 2) + f(b, 2)),\n      i = e(f(c, 2) + f(d, 2));\n  return g * Math.acos((a * c + b * d) / (h * i));\n}, utilLib.toRGB = function (b) {\n  var c,\n      d,\n      e,\n      f = {\n    r: 0,\n    g: 0,\n    b: 0,\n    status: 0\n  };\n  return d = function d(a) {\n    for (e in a) {\n      a.hasOwnProperty(e) && (0 > a[e] || isNaN(a[e]) ? a[e] = 0 : 255 < a[e] && (a[e] = 255));\n    }\n\n    return f = {\n      r: a[0],\n      g: a[1],\n      b: a[2],\n      status: 1\n    }, f;\n  }, b = b.trim(), b.match(/^rgb\\(|^rgba\\(/i) ? (c = /\\(\\s*(\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})/.exec(b), d([parseInt(c[1]), parseInt(c[2]), parseInt(c[3])])) : b.match(/^#/) && (c = /(\\w{2})(\\w{2})(\\w{2})/.exec(b), d([parseInt(c[1], 16), parseInt(c[2], 16), parseInt(c[3], 16)])), f;\n}, utilLib.StrToDom = function (a) {\n  var b, c;\n  return win.DOMParser ? (b = new DOMParser(), c = b.parseFromString(a, 'text/xml')) : (c = new win.ActiveXObject('Microsoft.XMLDOM'), c.async = !1, c.loadXML(a)), c;\n};\nexport default _SvgDeCanvo;","map":null,"metadata":{},"sourceType":"module"}