{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nvar UNDEF,\n    isWithinCircle = function isWithinCircle(a, b, c, d, e) {\n  var f = Math.pow;\n  return f(c - a, 2) + f(d - b, 2) <= f(e, 2);\n},\n    mathPI = Math.PI,\n    mathCos = Math.cos,\n    mathSin = Math.sin,\n    mathMax = Math.max,\n    mathMin = Math.min,\n    deg2rad = mathPI / 180,\n    rad = function rad(a) {\n  return a % 360 * deg2rad;\n},\n    orientation = function orientation(a, b, c, d, e, f) {\n  var g, h, i;\n  return g = (d - b) * (e - c), h = (c - a) * (f - d), isNaN(g) && (g = 0), isNaN(h) && (h = 0), i = g - h, 0 === i ? 0 : 0 < i ? 1 : 2;\n},\n    onSegment = function onSegment(a, b, c, d, e, f) {\n  return !!(c <= mathMax(a, e) && c >= mathMin(a, e) && d <= mathMax(b, f) && d >= mathMin(b, f));\n},\n    doIntersect = function doIntersect(a, b, c, d, e, f, g, h) {\n  var i = orientation(a, b, c, d, e, f),\n      j = orientation(a, b, c, d, g, h),\n      k = orientation(e, f, g, h, a, b),\n      l = orientation(e, f, g, h, c, d);\n  return !(i === j || k === l) || !!(0 === i && onSegment(a, b, e, f, c, d)) || !!(0 === j && onSegment(a, b, g, h, c, d)) || !!(0 === k && onSegment(e, f, a, b, g, h)) || !!(0 === l && onSegment(e, f, c, d, g, h));\n},\n    isWithinPolygon = function isWithinPolygon(a, b, c, d, e, f, g) {\n  var h,\n      j,\n      k,\n      l,\n      m,\n      n,\n      o,\n      p = 0,\n      q = !1;\n\n  if (isWithinCircle(a, b, c, d, e) && 3 <= f) {\n    for (j = g === UNDEF ? .5 * mathPI : rad(g), o = 2 * mathPI / f, k = c + e * mathCos(-j), n = d + e * mathSin(-j), h = 0; h < f; h++) {\n      if (j += o, l = c + e * mathCos(-j), m = d + e * mathSin(-j), doIntersect(k, n, l, m, a, b, 1 / 0, b)) {\n        if (0 === orientation(k, n, a, b, l, m)) return onSegment(k, n, a, b, l, m);\n        p++;\n      }\n\n      k = l, n = m;\n    }\n\n    q = 0 != p % 2;\n  }\n\n  return q;\n},\n    _compair2closest = function _compair2closest(a, b) {\n  return !a || a && b && b.i > a.i ? b : a;\n};\n\nfunction kdTreeAbs(a) {\n  'use strict';\n\n  function b(a, b, c) {\n    var d = a[b];\n    a[b] = a[c], a[c] = d;\n  }\n\n  function c(a, b, d, g) {\n    var h,\n        i = {},\n        j = g ? 'y' : 'x';\n    return b === d ? (i.point = a[b], i) : 1 == d - b ? (a[b][j] > a[d][j] ? (i.point = a[b], i.left = {\n      point: a[d]\n    }) : (i.point = a[d], i.left = {\n      point: a[b]\n    }), i) : (h = b + d >> 1, g ? _f(a, h, b, d) : _e(a, h, b, d), i.point = a[h], i.left = c(a, b, h - 1, !g), i.right = c(a, h + 1, d, !g), i);\n  }\n\n  var d,\n      _e,\n      _f,\n      g = a && a[0] && a[0].r || 5,\n      h = Math.max,\n      l = Math.floor,\n      o = Math.sqrt,\n      p = Math.min,\n      q = Math.log,\n      r = Math.exp,\n      j = Math.pow;\n\n  for (_e = function e(a, c, d, f) {\n    for (var g, k, u, v, w, x, y, A, B, C; f > d;) {\n      for (600 < f - d && (g = f - d + 1, k = c - d + 1, u = q(g), v = .5 * r(2 * u / 3), w = .5 * o(u * v * (g - v) / g) * (0 > k - g / 2 ? -1 : 1), x = h(d, l(c - k * v / g + w)), y = p(f, l(c + (g - k) * v / g + w)), _e(a, c, x, y)), A = a[c], B = d, C = f, b(a, d, c), a[f].x > A.x && b(a, d, f); B < C;) {\n        for (b(a, B, C), B++, C--; a[B].x < A.x;) {\n          B++;\n        }\n\n        for (; a[C].x > A.x;) {\n          C--;\n        }\n      }\n\n      a[d].x === A.x ? b(a, d, C) : (C++, b(a, C, f)), C <= c && (d = C + 1), c <= C && (f = C - 1);\n    }\n  }, _f = function f(a, c, d, e) {\n    for (var g, k, u, v, w, x, y, A, B, C; e > d;) {\n      for (600 < e - d && (g = e - d + 1, k = c - d + 1, u = q(g), v = .5 * r(2 * u / 3), w = .5 * o(u * v * (g - v) / g) * (0 > k - g / 2 ? -1 : 1), x = h(d, l(c - k * v / g + w)), y = p(e, l(c + (g - k) * v / g + w)), _f(a, c, x, y)), A = a[c], B = d, C = e, b(a, d, c), a[e].y > A.y && b(a, d, e); B < C;) {\n        for (b(a, B, C), B++, C--; a[B].y < A.y;) {\n          B++;\n        }\n\n        for (; a[C].y > A.y;) {\n          C--;\n        }\n      }\n\n      a[d].y === A.y ? b(a, d, C) : (C++, b(a, C, e)), C <= c && (d = C + 1), c <= C && (e = C - 1);\n    }\n  }, a = a || [], d = a.length; d--;) {\n    a[d].r > g && (g = a[d].r), a[d].i = d, a[d].x = +a[d].x, a[d].y = +a[d].y;\n  }\n\n  return {\n    tree: 0 === a.length ? {} : c(a, 0, a.length - 1, !1),\n    search: function search(c, d, e, a) {\n      function f(a, b, c, d) {\n        return o(j(a - c, 2) + j(b - d, 2));\n      }\n\n      function b(g, a) {\n        return 'circle' === e ? f(g, a, c, d) <= q : g >= q && g <= r && a >= s && a <= t;\n      }\n\n      function h(b, a, c) {\n        return b >= a && b <= c;\n      }\n\n      function i(a) {\n        var b = h(c, a.x1, a.x2) && h(d, a.y1, a.y2),\n            e = f(c, d, a.point.x, a.point.y);\n        return l ? void (b ? u ? a.point.i > l.point.i && (l = a, u = b, v = e) : (l = a, u = b, v = e) : !u && e < v && (l = a, u = b, v = e)) : (l = a, u = b, void (v = e));\n      }\n\n      function k(a, b) {\n        'circle' === e ? q = a : (q = c - a || 0, r = c + a || 0, s = d - b || 0, t = d + b || 0);\n      }\n\n      var l,\n          m,\n          n,\n          p = this.tree,\n          q = c - g,\n          r = c + g,\n          s = d - g,\n          t = d + g,\n          u = !1,\n          v = 0;\n      return a = a || {}, n = function n(c) {\n        var d, e;\n        c && c.point && (d = a.rx || c.point.r, e = a.ry || c.point.r, k(d, e), b(c.point.x, c.point.y) && i(c), s <= c.point.y && m(c.left), t >= c.point.y && m(c.right));\n      }, m = function m(c) {\n        var d, e;\n        c && c.point && (d = a.rx || c.point.r, e = a.ry || c.point.r, k(d, e), b(c.point.x, c.point.y) && i(c), q <= c.point.x && n(c.left), r >= c.point.x && n(c.right));\n      }, m(p), l && l.point || l;\n    }\n  };\n}\n\nvar KdTree =\n/*#__PURE__*/\nfunction () {\n  function KdTree(a) {\n    _classCallCheck(this, KdTree);\n\n    var b = this;\n    b.configure(a);\n  }\n\n  _createClass(KdTree, [{\n    key: \"configure\",\n    value: function configure(a) {\n      var b = this;\n      b.validatorFn = a ? b.shapeValidator() : b.defaultValidator();\n    }\n  }, {\n    key: \"defaultValidator\",\n    value: function defaultValidator() {\n      var a = Math.pow,\n          b = this;\n      return function (c) {\n        var d = b.mousePoint;\n        return !!(c && 1 >= a((c.x - d.x) / b.xLimit, 2) + a((c.y - d.y) / b.yLimit, 2));\n      };\n    }\n  }, {\n    key: \"shapeValidator\",\n    value: function shapeValidator() {\n      var a = this;\n      return function (b) {\n        var c,\n            d,\n            e,\n            f,\n            g,\n            h,\n            i,\n            j,\n            k,\n            l = a.mousePoint,\n            m = b && b.shapeInfo,\n            n = !1,\n            o = l.x,\n            p = l.y;\n        return c = m && m.type, 'circle' === c ? (e = m.radius, n = isWithinCircle(o, p, b.x, b.y, e)) : 'arc' === c ? (d = m.innerradius, e = m.radius, n = !isWithinCircle(o, p, b.x, b.y, d) && isWithinCircle(o, p, b.x, b.y, e)) : 'polygon' === c ? (e = m.radius, g = m.startAngle, f = m.sides, n = isWithinPolygon(o, p, b.x, b.y, e, f, g)) : 'rect' === c || 'rectangle' === c ? (h = b.x, j = b.y, i = h + (m.width || 0), k = j + (m.height || 0), n = o >= h && o <= i && p >= j && p <= k) : 'default' === c ? n = !1 : void 0, n;\n      };\n    }\n  }, {\n    key: \"buildKdTree\",\n    value: function buildKdTree(a) {\n      return this.kdTree = kdTreeAbs(a), this.tree = this.kdTree.tree, this;\n    }\n  }, {\n    key: \"getNeighbour\",\n    value: function getNeighbour(a, b, c) {\n      var d = this,\n          e = d.tree,\n          f = {\n        x1: a.x - d.xLimit,\n        x2: a.x + d.xLimit,\n        y1: a.y - d.yLimit,\n        y2: a.y + d.yLimit\n      },\n          g = d.validatorFn;\n      return d.mousePoint = a, b ? this.kdTree && this.kdTree.search(a.x, a.y, c, a.options) : e ? d._searchBtwnLimit(f, e, !0, g) : void 0;\n    }\n  }, {\n    key: \"_searchBtwnLimit\",\n    value: function _searchBtwnLimit(a, b, c, d) {\n      var e,\n          f,\n          g = this,\n          h = c ? 'x' : 'y',\n          i = c ? a.x1 : a.y1,\n          j = c ? a.x2 : a.y2;\n      if (e = b && b.point && b.point[h], e !== UNDEF) return d(b.point) && (f = b.point), e >= i && b.left && (f = _compair2closest(f, g._searchBtwnLimit(a, b.left, !c, d))), e <= j && b.right && (f = _compair2closest(f, g._searchBtwnLimit(a, b.right, !c, d))), f;\n    }\n  }, {\n    key: \"_setSearchLimit\",\n    value: function _setSearchLimit(a, b) {\n      var c = this;\n      c.xLimit = a, c.yLimit = b;\n    }\n  }]);\n\n  return KdTree;\n}();\n\nKdTree.prototype.constructor = KdTree;\nexport default KdTree;","map":null,"metadata":{},"sourceType":"module"}