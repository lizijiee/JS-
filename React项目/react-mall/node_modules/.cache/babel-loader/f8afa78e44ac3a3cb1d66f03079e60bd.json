{"ast":null,"code":"import _defineProperty from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\n\nvar _R$_availableAttrs;\n\nimport eve from './eve/eve';\nimport extend, { merge, getArrayCopy, cacher } from './raphael.lib';\n\nvar _win = 'undefined' == typeof window ? 'undefined' == typeof global ? null : global : window;\n\nfunction R(e) {\n  var t, n, a;\n  return void 0 === R._url && (R._url = E), R.is(e, FUNCTION) ? loaded ? e() : eve.on('raphael.DOMload', e) : R.is(e, ARRAY) ? R._engine.create[APPLY](R, e.splice(0, 3 + R.is(e[0], NU))).add(e) : (n = getArrayCopy(arguments), t = Array.prototype.slice.call(n, 0), R.is(t[t.length - 1], FUNCTION) ? (a = t.pop(), loaded ? a.call(R._engine.create[APPLY](R, t)) : eve.on('raphael.DOMload', function () {\n    a.call(R._engine.create[APPLY](R, t));\n  })) : R._engine.create[APPLY](R, arguments));\n}\n\nR.upgrade = '1.0.0', R.version = '2.1.0', R.eve = eve;\n\nvar loaded,\n    UNDEF,\n    undef,\n    __data,\n    E = '',\n    S = ' ',\n    HAS = 'hasOwnProperty',\n    APPLY = 'apply',\n    CONCAT = 'concat',\n    NU = 'number',\n    STRING = 'string',\n    ARRAY = 'array',\n    OBJECT = 'object',\n    FINITE = 'finite',\n    SPLIT = 'split',\n    NONE = 'none',\n    BLACK = '#000',\n    NULL = 'null',\n    FUNCTION = 'function',\n    AUTO = 'auto',\n    NORMAL = 'normal',\n    COMMA = ',',\n    TOKEN1 = '$1',\n    rCheckRegex = /R/i,\n    isIE = /trident/i.test(_win.navigator.userAgent),\n    paramCounts = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  r: 4,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0\n},\n    arraySplice = Array.prototype.splice,\n    hasPrototypeBug = function () {\n  return function () {}.hasOwnProperty('prototype');\n}(),\n    g = {\n  doc: _win.document,\n  win: _win\n},\n    doc = g.doc,\n    win = g.win,\n    safePointerEventMapping = R.safePointerEventMapping = {\n  mouseover: 'pointerover',\n  mousedown: 'pointerdown',\n  mousemove: 'pointermove',\n  mouseup: 'pointerup',\n  mouseout: 'pointerout'\n},\n    navigator = win.navigator,\n    supportsTouch = R.supportsTouch = 'ontouchstart' in doc || navigator.maxTouchPoints || navigator.msMaxTouchPoints,\n    supportsPointer = R.supportsPointer = 'onpointerover' in doc,\n    isEdge = R.isEdge = /Edge/.test(navigator.userAgent),\n    isIE11 = R.isIE11 = /trident/i.test(navigator.userAgent) && /rv:11/i.test(navigator.userAgent) && !win.opera,\n    isFirefox = R.isFirefox = /Firefox/.test(navigator.userAgent),\n    isWindows = R.isWindows = /Windows/.test(navigator.userAgent),\n    mStr = 'm',\n    lStr = 'l',\n    strM = 'M',\n    strL = 'L',\n    __params = [],\n    charRegex = /[a-z]/i,\n    pathStringBreakFn = function pathStringBreakFn(e, t, n) {\n  var a = t.toLowerCase(),\n      r = [],\n      o = 0;\n  if (__params.length = 0, n.replace(pathValues, function (e, t) {\n    t && __params.push(+t);\n  }), 'r' === a) __data.push([t][CONCAT](__params));else if ('z' === a) __data.push([t]);else if (__params.length >= paramCounts[a]) {\n    for (; o < __params.length;) {\n      o % paramCounts[a] ? r.push(__params[o]) : (r.length && __data.push(r) && (r = []), r.push(t, __params[o])), o++;\n    }\n\n    __data.push(r);\n  }\n},\n    CustomAttributes = function CustomAttributes() {},\n    caproto = R.ca = R.customAttributes = CustomAttributes.prototype,\n    Paper = function Paper() {\n  this.ca = this.customAttributes = new CustomAttributes(), this._CustomAttributes = function () {}, this._CustomAttributes.prototype = this.ca, this._elementsById = {}, this.id = R._oid++, eve('raphael.new', this);\n},\n    paperproto = R.fn = Paper.prototype = R.prototype,\n    events = 'click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel dragstart dragmove dragend'.split(' '),\n    touchMap = {\n  dragstart: 'touchstart',\n  dragmove: 'touchmove',\n  dragend: 'touchend'\n},\n    Str = String,\n    toFloat = win.parseFloat,\n    toInt = win.parseInt,\n    math = Math,\n    mmax = math.max,\n    mmin = math.min,\n    abs = math.abs,\n    pow = math.pow,\n    mathCos = math.cos,\n    mathSin = math.sin,\n    mathSqrt = math.sqrt,\n    round = math.round,\n    PI = math.PI,\n    deg2rad = PI / 180,\n    rad2deg = 180 / PI,\n    lowerCase = Str.prototype.toLowerCase,\n    upperCase = Str.prototype.toUpperCase,\n    objectToString = Object.prototype.toString,\n    separator = /[, ]+/,\n    formatrg = /\\{(\\d+)\\}/g,\n    colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\))\\s*$/i,\n    bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n    commaSpaces = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/,\n    p2s = /,?([achlmqrstvxz]),?/gi,\n    pathCommaRegex = /,?[a-z],?/i,\n    pathCommand = /([achlmrqstvz])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n    tCommand = /([rstm])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n    pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/ig,\n    isnan = {\n  NaN: 1,\n  Infinity: 1,\n  \"-Infinity\": 1\n},\n    hsrg = {\n  hs: 1,\n  rg: 1\n},\n    availableAttrs = R._availableAttrs = (_R$_availableAttrs = {\n  \"arrow-end\": 'none',\n  \"arrow-start\": 'none',\n  blur: 0,\n  \"clip-rect\": '0 0 1e9 1e9',\n  \"clip-path\": '',\n  cursor: 'default',\n  cx: 0,\n  cy: 0,\n  fill: '#fff',\n  \"fill-opacity\": 1,\n  font: '10px \"Arial\"',\n  \"font-family\": '\"Arial\"',\n  \"font-size\": '10',\n  \"font-style\": 'normal',\n  \"font-weight\": 400,\n  gradient: 0,\n  height: 0,\n  href: 'about:blank',\n  \"letter-spacing\": 0,\n  \"line-height\": 12,\n  \"vertical-align\": 'middle',\n  opacity: 1,\n  path: 'M0,0',\n  r: 0,\n  rx: 0,\n  ry: 0,\n  src: '',\n  stroke: '#000',\n  \"stroke-dasharray\": '',\n  \"stroke-linecap\": 'butt',\n  \"stroke-linejoin\": 'butt',\n  \"stroke-miterlimit\": 0,\n  \"stroke-opacity\": 1,\n  \"stroke-width\": 1,\n  target: '_blank',\n  \"text-anchor\": 'middle',\n  visibility: '',\n  title: '',\n  transform: '',\n  rotation: 0,\n  width: 0,\n  x: 0,\n  y: 0,\n  \"shape-rendering\": 'auto',\n  alpha: 'number',\n  \"font-stretch\": 'normal',\n  \"alignment-baseline\": 'auto',\n  \"baseline-shift\": 'auto',\n  \"clip-rule\": 'nonzero',\n  direction: 'ltr',\n  \"dominant-baseline\": 'auto',\n  \"fill-rule\": 'nonzero',\n  filter: 'none',\n  \"flood-color\": '#000',\n  \"flood-opacity\": 1,\n  \"font-size-adjust\": 'none'\n}, _defineProperty(_R$_availableAttrs, \"font-stretch\", 'normal'), _defineProperty(_R$_availableAttrs, \"font-variant\", 'normal'), _defineProperty(_R$_availableAttrs, \"kerning\", 'auto'), _defineProperty(_R$_availableAttrs, \"lighting-color\", 'white'), _defineProperty(_R$_availableAttrs, \"marker-end\", 'none'), _defineProperty(_R$_availableAttrs, \"marker-mid\", 'none'), _defineProperty(_R$_availableAttrs, \"marker-start\", 'none'), _defineProperty(_R$_availableAttrs, \"mask\", 'none'), _defineProperty(_R$_availableAttrs, \"pointer-events\", 'visiblePainted'), _defineProperty(_R$_availableAttrs, \"stop-color\", '#000'), _defineProperty(_R$_availableAttrs, \"stop-opacity\", 1), _defineProperty(_R$_availableAttrs, \"stroke-dashoffset\", 0), _defineProperty(_R$_availableAttrs, \"text-decoration\", 'none'), _defineProperty(_R$_availableAttrs, \"vector-effect\", ''), _defineProperty(_R$_availableAttrs, \"visibility\", 'visible'), _defineProperty(_R$_availableAttrs, \"word-spacing\", 'normal'), _defineProperty(_R$_availableAttrs, \"writing-mode\", 'lr-tb'), _R$_availableAttrs),\n    availableAnimAttrs = R._availableAnimAttrs = {\n  blur: 'number',\n  \"clip-rect\": 'csv',\n  \"clip-path\": 'path',\n  cx: 'number',\n  cy: 'number',\n  fill: 'colour',\n  \"fill-opacity\": 'number',\n  \"font-size\": 'number',\n  height: 'number',\n  opacity: 'number',\n  path: 'path',\n  r: 'number',\n  rx: 'number',\n  ry: 'number',\n  stroke: 'colour',\n  \"stroke-opacity\": 'number',\n  \"stroke-width\": 'number',\n  transform: 'transform',\n  width: 'number',\n  x: 'number',\n  y: 'number',\n  color: 'colour',\n  borderColor: 'colour',\n  borderWidth: 'number',\n  alpha: 'number',\n  \"text-bound\": 'text-bound'\n},\n    eldata = {},\n    sortByNumber = function sortByNumber(e, t) {\n  return toFloat(e) - toFloat(t);\n},\n    fun = function fun() {},\n    pipe = function pipe(e) {\n  return e;\n},\n    rectPath = R._rectPath = function (e, t, n, a, i) {\n  return i ? [[strM, e + i, t], [lStr, n - 2 * i, 0], ['a', i, i, 0, 0, 1, i, i], [lStr, 0, a - 2 * i], ['a', i, i, 0, 0, 1, -i, i], [lStr, 2 * i - n, 0], ['a', i, i, 0, 0, 1, -i, -i], [lStr, 0, 2 * i - a], ['a', i, i, 0, 0, 1, i, -i], ['z']] : [[strM, e, t], [lStr, n, 0], [lStr, 0, a], [lStr, -n, 0], ['z']];\n},\n    ellipsePath = function ellipsePath(e, t, n, a) {\n  return null == a && (a = n), [[strM, e, t], [mStr, 0, -a], ['a', n, a, 0, 1, 1, 0, 2 * a], ['a', n, a, 0, 1, 1, 0, -2 * a], ['z']];\n},\n    getPath = R._getPath = {\n  group: function group() {\n    return !1;\n  },\n  path: function path(e) {\n    return e.attr('path');\n  },\n  circle: function circle(e) {\n    var t = e.attrs;\n    return ellipsePath(t.cx, t.cy, t.r);\n  },\n  ellipse: function ellipse(e) {\n    var t = e.attrs;\n    return ellipsePath(t.cx, t.cy, t.rx, t.ry);\n  },\n  rect: function rect(e) {\n    var t = e.attrs;\n    return rectPath(t.x, t.y, t.width, t.height, t.r);\n  },\n  image: function image(e) {\n    var t = e.attrs;\n    return rectPath(t.x, t.y, t.width, t.height);\n  },\n  text: function text(e) {\n    var t = e._getBBox();\n\n    return rectPath(t.x, t.y, t.width, t.height);\n  }\n},\n    mapPath = R.mapPath = function (e, t) {\n  if (!t) return e;\n  var n, a, r, o, s, l, d;\n\n  for (e = path2curve(e).slice(0), r = 0, s = e.length; r < s; r++) {\n    for (d = e[r] = e[r].slice(0), o = 1, l = d.length; o < l; o += 2) {\n      n = t.x(d[o], d[o + 1]), a = t.y(d[o], d[o + 1]), d[o] = n, d[o + 1] = a;\n    }\n  }\n\n  return e;\n},\n    lastArgIfGroup = R._lastArgIfGroup = function (e, t) {\n  var n = e.length - 1,\n      a = e[n];\n  if (a && a.constructor === R.el.constructor && 'group' === a.type) return t && (e[n] = void 0, delete e[n], arraySplice.call(e, n, 1)), a;\n},\n    serializeArgs = R._serializeArgs = function (e) {\n  var t,\n      n,\n      a,\n      r,\n      o = e[0];\n  if (R.is(o, OBJECT) && !R.is(o, ARRAY) && 'group' !== o.type) for (n = o, o.path && (t = o.path, t && !R.is(t, STRING) && !R.is(t[0], ARRAY) && (t += E)), (a = 1, r = arguments.length); a < r; a += 2) {\n    n[arguments[a]] || (n[arguments[a]] = arguments[a + 1]);\n  } else for (n = {}, a = 1, r = arguments.length; a < r; a += 2) {\n    n[arguments[a]] = e[(a - 1) / 2] || arguments[a + 1];\n  }\n  return n;\n},\n    is = R.is = function (e, t) {\n  return t === FINITE ? !isnan[HAS](+e) : t === ARRAY ? e instanceof Array : (t !== OBJECT || e !== undef && null !== e) && (t == NULL && null === e || t == typeof e && null !== e || t == OBJECT && e === Object(e) || t == ARRAY && Array.isArray && Array.isArray(e) || objectToString.call(e).slice(8, -1).toLowerCase() === t);\n},\n    clone = R.clone = hasPrototypeBug ? function (e) {\n  if (Object(e) !== e) return e;\n  if (e instanceof Function) return e;\n  var t = new e.constructor();\n\n  for (var n in e) {\n    'prototype' !== n && e[HAS](n) && (t[n] = clone(e[n]));\n  }\n\n  return t;\n} : function (e) {\n  if (Object(e) !== e) return e;\n  if (e instanceof Function) return e;\n  var t = new e.constructor();\n\n  for (var n in e) {\n    e[HAS](n) && (t[n] = clone(e[n]));\n  }\n\n  return t;\n},\n    Node = _win.Node;\n\nNode && !Node.prototype.contains && (Node.prototype.contains = function (e) {\n  for (; e = e.parentNode;) {\n    if (e === this) return !0;\n  }\n\n  return !1;\n}), R._g = g, R.merge = merge, R.extend = extend, R.createUUID = function (e, t) {\n  return function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(e, t).toUpperCase();\n  };\n}(/[xy]/g, function (e) {\n  var t = 0 | 16 * math.random(),\n      n = 'x' === e ? t : 8 | 3 & t;\n  return n.toString(16);\n}), R._radial_gradient = /^x?r(?:\\(([^\\)]*?)\\))?/, R._ISURL = /^url\\(['\"]?([^\\)]+?)['\"]?\\)$/i, R.getElementID = function (e) {\n  return 'rr-' + e;\n};\n\nfunction PriorityQueue(e) {\n  this._comparator = e, this._elements = [];\n}\n\nPriorityQueue.prototype.isEmpty = function () {\n  return 0 === this.size();\n}, PriorityQueue.prototype.peek = function () {\n  return this.isEmpty() ? null : this._elements[0];\n}, PriorityQueue.prototype.deq = function () {\n  var e = this.peek(),\n      t = this._elements.pop(),\n      n = this.size();\n\n  if (0 === n) return e;\n  this._elements[0] = t;\n\n  for (var a = 0; a < n;) {\n    var i = a,\n        r = 2 * a + 1,\n        o = 2 * a + 2;\n    if (r < n && 0 <= this._compare(r, i) && (i = r), o < n && 0 <= this._compare(o, i) && (i = o), i === a) break;\n    this._swap(i, a), a = i;\n  }\n\n  return e;\n}, PriorityQueue.prototype.enq = function (e) {\n  for (var t = this._elements.push(e), n = t - 1; 0 < n;) {\n    var a = Math.floor((n - 1) / 2);\n    if (0 >= this._compare(n, a)) break;\n    this._swap(a, n), n = a;\n  }\n\n  return t;\n}, PriorityQueue.prototype.size = function () {\n  return this._elements.length;\n}, PriorityQueue.prototype._compare = function (e, t) {\n  return this._comparator(this._elements[e], this._elements[t]);\n}, PriorityQueue.prototype._swap = function (e, t) {\n  var n = this._elements[e];\n  this._elements[e] = this._elements[t], this._elements[t] = n;\n}, R.type = win.ENABLE_RED_CANVAS && (win.CanvasRenderingContext2D || doc.createElement('canvas').getContext) ? 'CANVAS' : win.SVGAngle || doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1') ? 'SVG' : 'VML', R.svg = !((R.vml = 'VML' === R.type) || (R.canvas = 'CANVAS' === R.type)), R._Paper = Paper, R._id = 0, R._oid = 0, R.rad = function (e) {\n  return e % 360 * deg2rad;\n}, R.deg = function (e) {\n  return e * rad2deg % 360;\n};\n\nvar _toHex = function toHex(e) {\n  if (R.vml) {\n    var t,\n        n = /^\\s+|\\s+$/g;\n\n    try {\n      var a = new ActiveXObject('htmlfile');\n      a.write('<body>'), a.close(), t = a.body;\n    } catch (n) {\n      t = createPopup().document.body;\n    }\n\n    var r = t.createTextRange();\n    _toHex = cacher(function (e) {\n      try {\n        t.style.color = Str(e).replace(n, E);\n        var a = r.queryCommandValue('ForeColor');\n        return a = (255 & a) << 16 | 65280 & a | (16711680 & a) >>> 16, '#' + ('000000' + a.toString(16)).slice(-6);\n      } catch (t) {\n        return NONE;\n      }\n    });\n  } else {\n    var o = g.doc.createElement('i');\n    o.title = 'Rapha\\xEBl Colour Picker', o.style.display = NONE, g.doc.body.appendChild(o), _toHex = cacher(function (e) {\n      return o.style.color = e, g.doc.defaultView.getComputedStyle(o, E).getPropertyValue('color');\n    });\n  }\n\n  return _toHex(e);\n},\n    hsbtoString = function hsbtoString() {\n  return 'hsb(' + [this.h, this.s, this.b] + ')';\n},\n    hsltoString = function hsltoString() {\n  return 'hsl(' + [this.h, this.s, this.l] + ')';\n},\n    rgbtoString = function rgbtoString() {\n  return this.hex;\n},\n    prepareRGB = function prepareRGB(e, t, n) {\n  if (null == t && is(e, OBJECT) && 'r' in e && 'g' in e && 'b' in e && (n = e.b, t = e.g, e = e.r), null == t && is(e, STRING)) {\n    var a = R.getRGB(e);\n    e = a.r, t = a.g, n = a.b;\n  }\n\n  return (1 < e || 1 < t || 1 < n) && (e /= 255, t /= 255, n /= 255), [e, t, n];\n},\n    packageRGB = function packageRGB(e, t, n, a) {\n  var i = {\n    r: e *= 255,\n    g: t *= 255,\n    b: n *= 255,\n    hex: R.rgb(e, t, n),\n    toString: rgbtoString\n  };\n  return is(a, FINITE) && (i.opacity = a), i;\n};\n\nR.color = function (e) {\n  var t;\n  return R.is(e, OBJECT) && 'h' in e && 's' in e && 'b' in e ? (t = R.hsb2rgb(e), e.r = t.r, e.g = t.g, e.b = t.b, e.hex = t.hex) : R.is(e, OBJECT) && 'h' in e && 's' in e && lStr in e ? (t = R.hsl2rgb(e), e.r = t.r, e.g = t.g, e.b = t.b, e.hex = t.hex) : (R.is(e, STRING) && (e = R.getRGB(e)), R.is(e, OBJECT) && 'r' in e && 'g' in e && 'b' in e ? (t = R.rgb2hsl(e), e.h = t.h, e.s = t.s, e.l = t.l, t = R.rgb2hsb(e), e.v = t.b) : (e = {\n    hex: NONE\n  }, e.r = e.g = e.b = e.h = e.s = e.v = e.l = -1)), e.toString = rgbtoString, e;\n}, R.hsb2rgb = function (e, t, n, a) {\n  this.is(e, OBJECT) && 'h' in e && 's' in e && 'b' in e && (n = e.b, t = e.s, e = e.h, a = e.o), e *= 360;\n  var i, r, l, d, p;\n  return e = e % 360 / 60, p = n * t, d = p * (1 - abs(e % 2 - 1)), i = r = l = n - p, e = ~~e, i += [p, d, 0, 0, d, p][e], r += [d, p, p, d, 0, 0][e], l += [0, 0, d, p, p, d][e], packageRGB(i, r, l, a);\n}, R.hsl2rgb = function (e, t, n, a) {\n  this.is(e, OBJECT) && 'h' in e && 's' in e && lStr in e && (n = e.l, t = e.s, e = e.h), (1 < e || 1 < t || 1 < n) && (e /= 360, t /= 100, n /= 100), e *= 360;\n  var i, r, o, d, p;\n  return e = e % 360 / 60, p = 2 * t * (.5 > n ? n : 1 - n), d = p * (1 - abs(e % 2 - 1)), i = r = o = n - p / 2, e = ~~e, i += [p, d, 0, 0, d, p][e], r += [d, p, p, d, 0, 0][e], o += [0, 0, d, p, p, d][e], packageRGB(i, r, o, a);\n}, R.rgb2hsb = function (e, t, n) {\n  n = prepareRGB(e, t, n), e = n[0], t = n[1], n = n[2];\n  var a, i, o, s;\n  return o = mmax(e, t, n), s = o - mmin(e, t, n), a = 0 === s ? null : o === e ? (t - n) / s : o === t ? (n - e) / s + 2 : (e - t) / s + 4, a = 60 * ((a + 360) % 6) / 360, i = 0 === s ? 0 : s / o, {\n    h: a,\n    s: i,\n    b: o,\n    toString: hsbtoString\n  };\n}, R.rgb2hsl = function (e, t, n) {\n  n = prepareRGB(e, t, n), e = n[0], t = n[1], n = n[2];\n  var a, i, o, s, l, d;\n  return s = mmax(e, t, n), l = mmin(e, t, n), d = s - l, a = 0 === d ? null : s === e ? (t - n) / d : s === t ? (n - e) / d + 2 : (e - t) / d + 4, a = 60 * ((a + 360) % 6) / 360, o = (s + l) / 2, i = 0 === d ? 0 : .5 > o ? d / (2 * o) : d / (2 - 2 * o), {\n    h: a,\n    s: i,\n    l: o,\n    toString: hsltoString\n  };\n}, R._path2string = function () {\n  return this.join(COMMA).replace(p2s, TOKEN1);\n}, R._cacher = cacher;\n\nfunction clrToString() {\n  return this.hex;\n}\n\nR.getRGB = cacher(function (e) {\n  var n, a, i, r, o, s, l;\n  return (e && is(e, OBJECT) && 'opacity' in e && (n = e.opacity), !e || !!((e = Str(e)).indexOf('-') + 1)) ? {\n    r: -1,\n    g: -1,\n    b: -1,\n    hex: NONE,\n    error: 1,\n    toString: clrToString\n  } : e === NONE ? {\n    r: -1,\n    g: -1,\n    b: -1,\n    hex: NONE,\n    toString: clrToString\n  } : (hsrg[HAS](e.toLowerCase().substring(0, 2)) || '#' === e.charAt() || (e = _toHex(e)), l = e.match(colourRegExp)) ? (l[2] && (r = toInt(l[2].substring(5), 16), i = toInt(l[2].substring(3, 5), 16), a = toInt(l[2].substring(1, 3), 16)), l[3] && (r = toInt((o = l[3].charAt(3)) + o, 16), i = toInt((o = l[3].charAt(2)) + o, 16), a = toInt((o = l[3].charAt(1)) + o, 16)), l[4] && (s = l[4][SPLIT](commaSpaces), a = toFloat(s[0]), '%' === s[0].slice(-1) && (a *= 2.55), i = toFloat(s[1]), '%' === s[1].slice(-1) && (i *= 2.55), r = toFloat(s[2]), '%' === s[2].slice(-1) && (r *= 2.55), 'rgba' === l[1].toLowerCase().slice(0, 4) && (n = toFloat(s[3])), s[3] && '%' === s[3].slice(-1) && (n /= 100)), l[5]) ? (s = l[5][SPLIT](commaSpaces), a = toFloat(s[0]), '%' === s[0].slice(-1) && (a *= 2.55), i = toFloat(s[1]), '%' === s[1].slice(-1) && (i *= 2.55), r = toFloat(s[2]), '%' === s[2].slice(-1) && (r *= 2.55), ('deg' === s[0].slice(-3) || '\\xB0' === s[0].slice(-1)) && (a /= 360), 'hsba' === l[1].toLowerCase().slice(0, 4) && (n = toFloat(s[3])), s[3] && '%' === s[3].slice(-1) && (n /= 100), R.hsb2rgb(a, i, r, n)) : l[6] ? (s = l[6][SPLIT](commaSpaces), a = toFloat(s[0]), '%' === s[0].slice(-1) && (a *= 2.55), i = toFloat(s[1]), '%' === s[1].slice(-1) && (i *= 2.55), r = toFloat(s[2]), '%' === s[2].slice(-1) && (r *= 2.55), ('deg' === s[0].slice(-3) || '\\xB0' === s[0].slice(-1)) && (a /= 360), 'hsla' === l[1].toLowerCase().slice(0, 4) && (n = toFloat(s[3])), s[3] && '%' === s[3].slice(-1) && (n /= 100), R.hsl2rgb(a, i, r, n)) : (l = {\n    r: a,\n    g: i,\n    b: r,\n    toString: clrToString\n  }, l.hex = '#' + (16777216 | r | i << 8 | a << 16).toString(16).slice(1), R.is(n, FINITE) && (l.opacity = n), l) : {\n    r: -1,\n    g: -1,\n    b: -1,\n    hex: NONE,\n    error: 1,\n    toString: clrToString\n  };\n}, R), R.tintshade = cacher(function (e, t) {\n  var n,\n      a = R.getRGB(e),\n      i = 255;\n  return 0 > t && (t *= -1, i = 0), 1 < t && (t = 1), n = 0 === t ? a : {\n    r: i - (i - a.r) * t,\n    g: i - (i - a.g) * t,\n    b: i - (i - a.b) * t,\n    toString: clrToString\n  }, n.hex = R.rgb(n.r, n.g, n.b), a.error && (n.error = a.error), 'opacity' in a ? (n.rgba = 'rgba(' + [n.r, n.g, n.b, a.opacity].join(',') + ')', n.opacity = a.opacity) : n.rgba = 'rgb(' + [n.r, n.g, n.b].join(',') + ')', n;\n}, R), R.rgb = cacher(function (e, t, n) {\n  return '#' + (16777216 | n | t << 8 | e << 16).toString(16).slice(1);\n});\n\nfunction catmullRom2bezier(e, t) {\n  for (var n, a = [], r = 0, o = e.length; o - 2 * !t > r; r += 2) {\n    n = [{\n      x: +e[r - 2],\n      y: +e[r - 1]\n    }, {\n      x: +e[r],\n      y: +e[r + 1]\n    }, {\n      x: +e[r + 2],\n      y: +e[r + 3]\n    }, {\n      x: +e[r + 4],\n      y: +e[r + 5]\n    }], t ? r ? o - 4 == r ? n[3] = {\n      x: +e[0],\n      y: +e[1]\n    } : o - 2 == r && (n[2] = {\n      x: +e[0],\n      y: +e[1]\n    }, n[3] = {\n      x: +e[2],\n      y: +e[3]\n    }) : n[0] = {\n      x: +e[o - 2],\n      y: +e[o - 1]\n    } : o - 4 == r ? n[3] = n[2] : !r && (n[0] = {\n      x: +e[r],\n      y: +e[r + 1]\n    }), a.push(['C', (-n[0].x + 6 * n[1].x + n[2].x) / 6, (-n[0].y + 6 * n[1].y + n[2].y) / 6, (n[1].x + 6 * n[2].x - n[3].x) / 6, (n[1].y + 6 * n[2].y - n[3].y) / 6, n[2].x, n[2].y]);\n  }\n\n  return a;\n}\n\nR.sanitizePath = function (e) {\n  var t;\n  return t = e.join ? e.join(COMMA) : e, t = rCheckRegex.test(t) ? R._pathToAbsolute(t) : t.replace(p2s, TOKEN1), t;\n}, R.parsePathString = function (e) {\n  if (!e || !e.length) return null;\n  var t = paths(e);\n  if (t.arr) return pathClone(t.arr);\n  if (__data = undef, R.is(e, ARRAY)) if (e = Str(e).replace(/,?([A-Z]),?/g, ',$1,').replace(/(^,?)|(,?$)/g, '').replace(/,,?/g, ',').split(','), R.is(e[0], ARRAY)) __data = pathClone(e);else {\n    var n,\n        a,\n        r,\n        o = [],\n        s = e.length;\n\n    for (__data = [], n = 0; n < s; n += 1) {\n      charRegex.test(e[n]) ? (o.length && __data.push(o), a = e[n], o = [a], r = paramCounts[a.toLowerCase()]) : r ? (o.push(+e[n]), r--) : e[n].length && (__data.push(o), o = [a].concat(+e[n]), r = paramCounts[a.toLowerCase()] - 1);\n    }\n\n    __data.push(o);\n  }\n  return __data && __data.length || (__data = [], Str(e).replace(pathCommand, pathStringBreakFn)), __data.toString = R._path2string, t.arr = __data, t.arr;\n}, R.parseTransformString = cacher(function (e) {\n  if (!e) return null;\n  var t = [];\n  return R.is(e, ARRAY) && R.is(e[0], ARRAY) && (t = pathClone(e)), t.length || Str(e).replace(tCommand, function (e, n, a) {\n    var i = [],\n        r = lowerCase.call(n);\n    a.replace(pathValues, function (e, t) {\n      t && i.push(+t);\n    }), t.push([n][CONCAT](i));\n  }), t.toString = R._path2string, t;\n});\nvar _pathCache = {},\n    paths = cacher(function () {\n  return {};\n}, undef, undef, undef, 500, _pathCache, !0);\n\nR.findDotsAtSegment = function (e, n, a, i, r, o, s, l, d) {\n  var t = 1 - d,\n      p = pow(t, 3),\n      c = pow(t, 2),\n      g = d * d,\n      h = g * d,\n      u = e + 2 * d * (a - e) + g * (r - 2 * a + e),\n      m = n + 2 * d * (i - n) + g * (o - 2 * i + n),\n      f = a + 2 * d * (r - a) + g * (s - 2 * r + a),\n      y = i + 2 * d * (o - i) + g * (l - 2 * o + i),\n      x = 90 - 180 * math.atan2(u - f, m - y) / PI;\n  return (u > f || m < y) && (x += 180), {\n    x: p * e + 3 * c * d * a + 3 * t * d * d * r + h * s,\n    y: p * n + 3 * c * d * i + 3 * t * d * d * o + h * l,\n    m: {\n      x: u,\n      y: m\n    },\n    n: {\n      x: f,\n      y: y\n    },\n    start: {\n      x: t * e + d * a,\n      y: t * n + d * i\n    },\n    end: {\n      x: t * r + d * s,\n      y: t * o + d * l\n    },\n    alpha: x\n  };\n};\n\nfunction base3(e, t, n, a, i) {\n  return e * (e * (-3 * t + 9 * n - 9 * a + 3 * i) + 6 * t - 12 * n + 6 * a) - 3 * t + 3 * n;\n}\n\nfunction bezlen(e, t, n, a, r, o, s, l, d) {\n  null == d && (d = 1), d = 1 < d ? 1 : 0 > d ? 0 : d;\n\n  for (var p = d / 2, c = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816], g = [.2491, .2491, .2335, .2335, .2032, .2032, .1601, .1601, .1069, .1069, .0472, .0472], h = 0, u = 0; u < 12; u++) {\n    var m = p * c[u] + p,\n        f = base3(m, e, n, r, s),\n        y = base3(m, t, a, o, l);\n    h += g[u] * mathSqrt(f * f + y * y);\n  }\n\n  return p * h;\n}\n\nfunction getTatLen(e, t, n, a, i, r, o, s, d) {\n  if (!(0 > d || bezlen(e, t, n, a, i, r, o, s) < d)) {\n    var p,\n        c = 1 / 2,\n        g = 1 - c;\n\n    for (p = bezlen(e, t, n, a, i, r, o, s, g); abs(p - d) > .01;) {\n      c /= 2, g += (p < d ? 1 : -1) * c, p = bezlen(e, t, n, a, i, r, o, s, g);\n    }\n\n    return g;\n  }\n}\n\nfunction intersect(e, t, n, a, i, r, o, s) {\n  if (!(mmax(e, n) < mmin(i, o) || mmin(e, n) > mmax(i, o) || mmax(t, a) < mmin(r, s) || mmin(t, a) > mmax(r, s))) {\n    var l = (e - n) * (r - s) - (t - a) * (i - o);\n\n    if (l) {\n      var d = ((e * a - t * n) * (i - o) - (e - n) * (i * s - r * o)) / l,\n          p = ((e * a - t * n) * (r - s) - (t - a) * (i * s - r * o)) / l,\n          c = +d.toFixed(2),\n          g = +p.toFixed(2);\n      return c < +mmin(e, n).toFixed(2) || c > +mmax(e, n).toFixed(2) || c < +mmin(i, o).toFixed(2) || c > +mmax(i, o).toFixed(2) || g < +mmin(t, a).toFixed(2) || g > +mmax(t, a).toFixed(2) || g < +mmin(r, s).toFixed(2) || g > +mmax(r, s).toFixed(2) ? void 0 : {\n        x: d,\n        y: p\n      };\n    }\n  }\n}\n\nR._removedFactory = function (e) {\n  return function () {\n    eve('raphael.log', null, \"Rapha\\xEBl: you are calling to method \\u201C\" + e + \"\\u201D of removed object\", e);\n  };\n};\n\nvar pathDimensions = R.pathBBox = function (e) {\n  var t = paths(e);\n  if (!e) return {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    x2: 0,\n    y2: 0\n  };\n  e = path2curve(e);\n\n  for (var n, a = 0, r = 0, o = [], s = [], l = 0, d = e.length; l < d; l++) {\n    if (n = e[l], n[0] === strM) a = n[1], r = n[2], o.push(a), s.push(r);else {\n      var c = curveDim(a, r, n[1], n[2], n[3], n[4], n[5], n[6]);\n      o = o[CONCAT](c.min.x, c.max.x), s = s[CONCAT](c.min.y, c.max.y), a = n[5], r = n[6];\n    }\n  }\n\n  var g = mmin[APPLY](0, o),\n      h = mmin[APPLY](0, s),\n      u = mmax[APPLY](0, o),\n      m = mmax[APPLY](0, s),\n      f = {\n    x: g,\n    y: h,\n    x2: u,\n    y2: m,\n    width: u - g,\n    height: m - h\n  };\n  return t.bbox = clone(f), f;\n},\n    pathClone = function pathClone(e) {\n  var t = clone(e);\n  return t.toString = R._path2string, t;\n},\n    pathToAbsolute = R._pathToAbsolute = function (e) {\n  var t,\n      n = paths(e);\n\n  if (!n.abs) {\n    if (R.is(e, ARRAY) && R.is(e && e[0], ARRAY) || (e = R.parsePathString(e)), !e || !e.length) return t = [[strM, 0, 0]], t.toString = R._path2string, t;\n    var a = 0,\n        o = 0,\n        s = 0,\n        l = 0,\n        d = 0;\n    t = [], e[0][0] === strM && (a = +e[0][1], o = +e[0][2], s = a, l = o, d++, t[0] = [strM, a, o]);\n\n    for (var p, c, g = 3 === e.length && e[0][0] === strM && 'R' === e[1][0].toUpperCase() && 'Z' === e[2][0].toUpperCase(), h = d, u = e.length; h < u; h++) {\n      if (t.push(p = []), c = e[h], c[0] != upperCase.call(c[0])) switch (p[0] = upperCase.call(c[0]), p[0]) {\n        case 'A':\n          p[1] = c[1], p[2] = c[2], p[3] = c[3], p[4] = c[4], p[5] = c[5], p[6] = +(c[6] + a), p[7] = +(c[7] + o);\n          break;\n\n        case 'V':\n          p[1] = +c[1] + o;\n          break;\n\n        case 'H':\n          p[1] = +c[1] + a;\n          break;\n\n        case 'R':\n          for (var m = [a, o][CONCAT](c.slice(1)), f = 2, b = m.length; f < b; f++) {\n            m[f] = +m[f] + a, m[++f] = +m[f] + o;\n          }\n\n          t.pop(), t = t[CONCAT](catmullRom2bezier(m, g));\n          break;\n\n        case 'M':\n          s = +c[1] + a, l = +c[2] + o;\n\n        default:\n          for (f = 1, b = c.length; f < b; f++) {\n            p[f] = +c[f] + (f % 2 ? a : o), f % 2 ? a = p[f] : o = p[f];\n          }\n\n      } else if ('R' === c[0]) m = [a, o][CONCAT](c.slice(1)), t.pop(), t = t[CONCAT](catmullRom2bezier(m, g)), p = ['R'][CONCAT](c.slice(-2));else for (var v = 0, _ = c.length; v < _; v++) {\n        p[v] = c[v];\n      }\n\n      switch (p[0]) {\n        case 'Z':\n          a = s, o = l;\n          break;\n\n        case 'H':\n          a = p[1];\n          break;\n\n        case 'V':\n          o = p[1];\n          break;\n\n        case 'M':\n          s = p[p.length - 2], l = p[p.length - 1];\n\n        default:\n          a = p[p.length - 2], o = p[p.length - 1];\n      }\n    }\n\n    t.toString = R._path2string, n.abs = t;\n  }\n\n  return pathClone(n.abs);\n},\n    l2c = function l2c(e, t, n, a) {\n  return [e, t, n, a, n, a];\n},\n    q2c = function q2c(e, t, n, a, i, r) {\n  var o = 1 / 3,\n      s = 2 / 3;\n  return [o * e + s * n, o * t + s * a, o * i + s * n, o * r + s * a, i, r];\n},\n    a2c = function a2c(e, n, a, r, o, s, l, d, p, c) {\n  l = l && +l, s = s && +s;\n  var g,\n      u = 120 * PI / 180,\n      m = deg2rad * (+o || 0),\n      f = [],\n      b = cacher(function (e, t, n) {\n    var a = e * mathCos(n) - t * mathSin(n),\n        i = e * mathSin(n) + t * mathCos(n);\n    return {\n      x: a,\n      y: i\n    };\n  });\n\n  if (!c) {\n    g = b(e, n, -m), e = g.x, n = g.y, g = b(d, p, -m), d = g.x, p = g.y;\n\n    var v = mathCos(deg2rad * o),\n        _ = mathSin(deg2rad * o),\n        A = (e - d) / 2,\n        x = (n - p) / 2,\n        y = A * A / (a * a) + x * x / (r * r);\n\n    1 < y && (y = mathSqrt(y), a = y * a, r = y * r);\n    var C = a * a,\n        T = r * r,\n        w = (s === l ? -1 : 1) * mathSqrt(abs((C * T - C * x * x - T * A * A) / (C * x * x + T * A * A))),\n        k = w * a * x / r + (e + d) / 2,\n        S = w * -r * A / a + (n + p) / 2,\n        E = math.asin(((n - S) / r).toFixed(9)),\n        P = math.asin(((p - S) / r).toFixed(9));\n    E = e < k ? PI - E : E, P = d < k ? PI - P : P, 0 > E && (E = 2 * PI + E), 0 > P && (P = 2 * PI + P), l && E > P && (E -= 2 * PI), !l && P > E && (P -= 2 * PI);\n  } else E = c[0], P = c[1], k = c[2], S = c[3];\n\n  var I = P - E;\n\n  if (abs(I) > u) {\n    var L = P,\n        F = d,\n        j = p;\n    P = E + u * (l && P > E ? 1 : -1), d = k + a * mathCos(P), p = S + r * mathSin(P), f = a2c(d, p, a, r, o, 0, l, F, j, [P, L, k, S]);\n  }\n\n  I = P - E;\n  var O = mathCos(E),\n      N = mathSin(E),\n      B = mathCos(P),\n      D = mathSin(P),\n      R = math.tan(I / 4),\n      t = 4 / 3 * a * R,\n      M = 4 / 3 * r * R,\n      V = [e, n],\n      Y = [e + t * N, n - M * O],\n      q = [d + t * D, p - M * B],\n      H = [d, p];\n  if (Y[0] = 2 * V[0] - Y[0], Y[1] = 2 * V[1] - Y[1], c) return [Y, q, H][CONCAT](f);\n  f = [Y, q, H][CONCAT](f).join()[SPLIT](COMMA);\n\n  for (var z = [], X = 0, G = f.length; X < G; X++) {\n    z[X] = X % 2 ? b(f[X - 1], f[X], m).y : b(f[X], f[X + 1], m).x;\n  }\n\n  return z;\n},\n    findDotAtSegment = function findDotAtSegment(e, n, a, i, r, o, s, l, d) {\n  var t = 1 - d;\n  return {\n    x: pow(t, 3) * e + 3 * pow(t, 2) * d * a + 3 * t * d * d * r + pow(d, 3) * s,\n    y: pow(t, 3) * n + 3 * pow(t, 2) * d * i + 3 * t * d * d * o + pow(d, 3) * l\n  };\n},\n    curveDim = cacher(function (e, t, n, i, r, o, s, l) {\n  var d,\n      p = r - 2 * n + e - (s - 2 * r + n),\n      g = 2 * (n - e) - 2 * (r - n),\n      h = e - n,\n      u = (-g + mathSqrt(g * g - 4 * p * h)) / 2 / p,\n      m = (-g - mathSqrt(g * g - 4 * p * h)) / 2 / p,\n      f = [t, l],\n      y = [e, s];\n  return '1e12' < abs(u) && (u = .5), '1e12' < abs(m) && (m = .5), 0 < u && 1 > u && (d = findDotAtSegment(e, t, n, i, r, o, s, l, u), y.push(d.x), f.push(d.y)), 0 < m && 1 > m && (d = findDotAtSegment(e, t, n, i, r, o, s, l, m), y.push(d.x), f.push(d.y)), p = o - 2 * i + t - (l - 2 * o + i), g = 2 * (i - t) - 2 * (o - i), h = t - i, u = (-g + mathSqrt(g * g - 4 * p * h)) / 2 / p, m = (-g - mathSqrt(g * g - 4 * p * h)) / 2 / p, '1e12' < abs(u) && (u = .5), '1e12' < abs(m) && (m = .5), 0 < u && 1 > u && (d = findDotAtSegment(e, t, n, i, r, o, s, l, u), y.push(d.x), f.push(d.y)), 0 < m && 1 > m && (d = findDotAtSegment(e, t, n, i, r, o, s, l, m), y.push(d.x), f.push(d.y)), {\n    min: {\n      x: mmin[APPLY](0, y),\n      y: mmin[APPLY](0, f)\n    },\n    max: {\n      x: mmax[APPLY](0, y),\n      y: mmax[APPLY](0, f)\n    }\n  };\n}),\n    path2curve = R._path2curve = cacher(function (e, t) {\n  var n = !t && paths(e);\n  if (!t && n.curve) return pathClone(n.curve);\n\n  for (var a = pathToAbsolute(e), r = t && pathToAbsolute(t), o = {\n    x: 0,\n    y: 0,\n    bx: 0,\n    by: 0,\n    X: 0,\n    Y: 0,\n    qx: null,\n    qy: null\n  }, s = {\n    x: 0,\n    y: 0,\n    bx: 0,\n    by: 0,\n    X: 0,\n    Y: 0,\n    qx: null,\n    qy: null\n  }, l = function l(e, t) {\n    var n, a;\n    if (!e) return ['C', t.x, t.y, t.x, t.y, t.x, t.y];\n\n    switch ((e[0] in {\n      T: 1,\n      Q: 1\n    }) || (t.qx = t.qy = null), e[0]) {\n      case 'M':\n        t.X = e[1], t.Y = e[2];\n        break;\n\n      case 'A':\n        e = ['C'][CONCAT](a2c[APPLY](0, [t.x, t.y][CONCAT](e.slice(1))));\n        break;\n\n      case 'S':\n        n = t.x + (t.x - (t.bx || t.x)), a = t.y + (t.y - (t.by || t.y)), e = ['C', n, a][CONCAT](e.slice(1));\n        break;\n\n      case 'T':\n        t.qx = t.x + (t.x - (t.qx || t.x)), t.qy = t.y + (t.y - (t.qy || t.y)), e = ['C'][CONCAT](q2c(t.x, t.y, t.qx, t.qy, e[1], e[2]));\n        break;\n\n      case 'Q':\n        t.qx = e[1], t.qy = e[2], e = ['C'][CONCAT](q2c(t.x, t.y, e[1], e[2], e[3], e[4]));\n        break;\n\n      case 'L':\n        e = ['C'][CONCAT](l2c(t.x, t.y, e[1], e[2]));\n        break;\n\n      case 'H':\n        e = ['C'][CONCAT](l2c(t.x, t.y, e[1], t.y));\n        break;\n\n      case 'V':\n        e = ['C'][CONCAT](l2c(t.x, t.y, t.x, e[1]));\n        break;\n\n      case 'Z':\n        e = ['C'][CONCAT](l2c(t.x, t.y, t.X, t.Y));\n    }\n\n    return e;\n  }, d = function d(e, t) {\n    if (7 < e[t].length) {\n      e[t].shift();\n\n      for (var n = e[t]; n.length;) {\n        e.splice(t++, 0, ['C'][CONCAT](n.splice(0, 6)));\n      }\n\n      e.splice(t, 1), g = mmax(a.length, r && r.length || 0);\n    }\n  }, p = function p(e, t, n, o, s) {\n    e && t && e[s][0] === strM && t[s][0] != strM && !s && (t.splice(s, 0, [strM, o.x, o.y]), n.bx = 0, n.by = 0, n.x = e[s][1], n.y = e[s][2], g = mmax(a.length, r && r.length || 0));\n  }, c = 0, g = mmax(a.length, r && r.length || 0); c < g; c++) {\n    a[c] = l(a[c], o), d(a, c), r && (r[c] = l(r[c], s)), r && d(r, c), p(a, r, o, s, c), p(r, a, s, o, c);\n    var h = a[c],\n        u = r && r[c],\n        m = h.length,\n        f = r && u.length;\n    o.x = h[m - 2], o.y = h[m - 1], o.bx = toFloat(h[m - 4]) || o.x, o.by = toFloat(h[m - 3]) || o.y, s.bx = r && (toFloat(u[f - 4]) || s.x), s.by = r && (toFloat(u[f - 3]) || s.y), s.x = r && u[f - 2], s.y = r && u[f - 1];\n  }\n\n  return r || (n.curve = pathClone(a)), r ? [a, r] : a;\n}, null, pathClone),\n    parseDots = R._parseDots = cacher(function (e) {\n  for (var t = [], n = 0, a = e.length; n < a; n++) {\n    var r = {},\n        o = e[n].match(/^([^:]*):?([\\d\\.]*)/);\n    if (r.color = R.getRGB(o[1]), r.color.error) return null;\n    r.opacity = r.color.opacity, r.color = r.color.hex, o[2] && (r.offset = o[2] + '%'), t.push(r);\n  }\n\n  for (n = 1, a = t.length - 1; n < a; n++) {\n    if (!t[n].offset) {\n      for (var s = toFloat(t[n - 1].offset || 0), l = 0, p = n + 1; p < a; p++) {\n        if (t[p].offset) {\n          l = t[p].offset;\n          break;\n        }\n      }\n\n      l || (l = 100, p = a), l = toFloat(l);\n\n      for (var c = (l - s) / (p - n + 1); n < p; n++) {\n        s += c, t[n].offset = s + '%';\n      }\n    }\n  }\n\n  return t;\n}),\n    tear = R._tear = function (e, t) {\n  e === t.top && (t.top = e.prev), e === t.bottom && (t.bottom = e.next), e.next && (e.next.prev = e.prev), e.prev && (e.prev.next = e.next);\n},\n    tofront = R._tofront = function (e, t) {\n  return t.top !== e && (tear(e, t), e.next = null, e.prev = t.top, t.top.next = e, t.top = e, !0);\n},\n    toback = R._toback = function (e, t) {\n  return t.bottom !== e && (tear(e, t), e.next = t.bottom, e.prev = null, t.bottom.prev = e, t.bottom = e, !0);\n},\n    insertafter = R._insertafter = function (e, t, n, a) {\n  tear(e, n), e.parent = a, t === a.top && (a.top = e), t.next && (t.next.prev = e), e.next = t.next, e.prev = t, t.next = e;\n},\n    insertbefore = R._insertbefore = function (e, t, n, a) {\n  tear(e, n), e.parent = a, t === a.bottom && (a.bottom = e), t.prev && (t.prev.next = e), e.prev = t.prev, t.prev = e, e.next = t;\n},\n    extractTransform = R._extractTransform = function (e, n) {\n  if (null == n) return e._.transform;\n  n = Str(n).replace(/\\.{3}|\\u2026/g, e._.transform || E);\n  var a = R.parseTransformString(n),\n      r = 0,\n      o = 0,\n      s = 0,\n      l = 1,\n      d = 1,\n      p = e._,\n      c = new Matrix();\n  if (p.transform = a || [], a) for (var g = 0, h = a.length; g < h; g++) {\n    var u,\n        m,\n        f,\n        y,\n        x,\n        b = a[g],\n        t = b.length,\n        v = Str(b[0]).toLowerCase(),\n        _ = b[0] != v,\n        A = _ ? c.invert() : 0;\n\n    't' === v && 3 === t ? _ ? (u = A.x(0, 0), m = A.y(0, 0), f = A.x(b[1], b[2]), y = A.y(b[1], b[2]), c.translate(f - u, y - m)) : c.translate(b[1], b[2]) : 'r' === v ? 2 === t ? (x = p.bb || (p.bb = e.getBBox(1)), c.rotate(b[1], x.x + x.width / 2, x.y + x.height / 2), r += b[1]) : 4 === t && (_ ? (f = A.x(b[2], b[3]), y = A.y(b[2], b[3]), c.rotate(b[1], f, y)) : c.rotate(b[1], b[2], b[3]), r += b[1]) : 's' === v ? 2 === t || 3 === t ? (x = p.bb || (p.bb = e.getBBox(1)), c.scale(b[1], b[t - 1], x.x + x.width / 2, x.y + x.height / 2), l *= b[1], d *= b[t - 1]) : 5 === t && (_ ? (f = A.x(b[3], b[4]), y = A.y(b[3], b[4]), c.scale(b[1], b[2], f, y)) : c.scale(b[1], b[2], b[3], b[4]), l *= b[1], d *= b[2]) : v === mStr && 7 === t && c.add(b[1], b[2], b[3], b[4], b[5], b[6]), p.dirtyT = 1, e.matrix = c;\n  }\n  e.matrix = c, p.sx = l, p.sy = d, p.deg = r, p.dx = o = c.e, p.dy = s = c.f, 1 === l && 1 === d && !r && p.bbox ? (p.bbox.x += +o, p.bbox.y += +s) : p.dirtyT = 1;\n},\n    getEmpty = function getEmpty(e) {\n  var t = e[0];\n\n  switch (t.toLowerCase()) {\n    case 't':\n      return [t, 0, 0];\n\n    case 'm':\n      return [t, 1, 0, 0, 1, 0, 0];\n\n    case 'r':\n      return 4 === e.length ? [t, 0, e[2], e[3]] : [t, 0];\n\n    case 's':\n      return 5 === e.length ? [t, 1, 1, e[3], e[4]] : 3 === e.length ? [t, 1, 1] : [t, 1];\n  }\n},\n    equaliseTransform = R._equaliseTransform = function (e, t) {\n  t = Str(t).replace(/\\.{3}|\\u2026/g, e), e = R.parseTransformString(e) || [], t = R.parseTransformString(t) || [];\n\n  for (var n, a, r, o, s = mmax(e.length, t.length), l = [], d = [], p = 0; p < s; p++) {\n    if (r = e[p] || getEmpty(t[p]), o = t[p] || getEmpty(r), r[0] != o[0] || 'r' === r[0].toLowerCase() && (r[2] != o[2] || r[3] != o[3]) || 's' === r[0].toLowerCase() && (r[3] != o[3] || r[4] != o[4])) return;\n\n    for (l[p] = [], d[p] = [], (n = 0, a = mmax(r.length, o.length)); n < a; n++) {\n      n in r && (l[p][n] = r[n]), n in o && (d[p][n] = o[n]);\n    }\n  }\n\n  return {\n    from: l,\n    to: d\n  };\n};\n\nR._getContainer = function (e, t, n, a) {\n  var i;\n  return i = null != a || R.is(e, OBJECT) ? e : g.doc.getElementById(e), null == i ? void 0 : i.tagName ? null == t ? {\n    container: i,\n    width: i.style.pixelWidth || i.offsetWidth,\n    height: i.style.pixelHeight || i.offsetHeight\n  } : {\n    container: i,\n    width: t,\n    height: n\n  } : {\n    container: 1,\n    x: e,\n    y: t,\n    width: n,\n    height: a\n  };\n}, R._engine = {}, R.path2curve = path2curve, R.matrix = function (t, n, a, i, r, e) {\n  return new Matrix(t, n, a, i, r, e);\n};\n\nfunction Matrix(t, n, a, i, r, e) {\n  null == t ? (this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0) : (this.a = +t, this.b = +n, this.c = +a, this.d = +i, this.e = +r, this.f = +e);\n}\n\n(function (e) {\n  function t(e) {\n    return e[0] * e[0] + e[1] * e[1];\n  }\n\n  function n(e) {\n    var n = mathSqrt(t(e));\n    e[0] && (e[0] /= n), e[1] && (e[1] /= n);\n  }\n\n  e.add = function (t, n, a, i, r, e) {\n    var o,\n        s,\n        l,\n        d,\n        p = [[], [], []],\n        c = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n        g = [[t, a, r], [n, i, e], [0, 0, 1]];\n\n    for (t && t instanceof Matrix && (g = [[t.a, t.c, t.e], [t.b, t.d, t.f], [0, 0, 1]]), o = 0; 3 > o; o++) {\n      for (s = 0; 3 > s; s++) {\n        for (d = 0, l = 0; 3 > l; l++) {\n          d += c[o][l] * g[l][s];\n        }\n\n        p[o][s] = d;\n      }\n    }\n\n    this.a = p[0][0], this.b = p[1][0], this.c = p[0][1], this.d = p[1][1], this.e = p[0][2], this.f = p[1][2];\n  }, e.invert = function () {\n    var e = this,\n        t = e.a * e.d - e.b * e.c;\n    return new Matrix(e.d / t, -e.b / t, -e.c / t, e.a / t, (e.c * e.f - e.d * e.e) / t, (e.b * e.e - e.a * e.f) / t);\n  }, e.clone = function () {\n    return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n  }, e.translate = function (e, t) {\n    this.add(1, 0, 0, 1, e, t);\n  }, e.scale = function (e, t, n, a) {\n    null == t && (t = e), (n || a) && this.add(1, 0, 0, 1, n, a), this.add(e, 0, 0, t, 0, 0), (n || a) && this.add(1, 0, 0, 1, -n, -a);\n  }, e.rotate = function (e, t, n) {\n    e = R.rad(e), t = t || 0, n = n || 0;\n    var i = +mathCos(e).toFixed(9),\n        r = +mathSin(e).toFixed(9);\n    this.add(i, r, -r, i, t, n), this.add(1, 0, 0, 1, -t, -n);\n  }, e.x = function (e, t) {\n    return e * this.a + t * this.c + this.e;\n  }, e.y = function (e, t) {\n    return e * this.b + t * this.d + this.f;\n  }, e.get = function (e) {\n    return +this[Str.fromCharCode(97 + e)].toFixed(4);\n  }, e.toString = function () {\n    return R.svg ? 'matrix(' + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ')' : [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();\n  }, e.toMatrixString = function () {\n    return 'matrix(' + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ')';\n  }, e.toFilter = function () {\n    return 'progid:DXImageTransform.Microsoft.Matrix(M11=' + this.get(0) + ', M12=' + this.get(2) + ', M21=' + this.get(1) + ', M22=' + this.get(3) + ', Dx=' + this.get(4) + ', Dy=' + this.get(5) + ', sizingmethod=\\'auto expand\\')';\n  }, e.offset = function () {\n    return [this.e.toFixed(4), this.f.toFixed(4)];\n  }, e.split = function () {\n    var e = {\n      dx: this.e,\n      dy: this.f\n    },\n        a = [[this.a, this.c], [this.b, this.d]];\n    e.scalex = mathSqrt(t(a[0])), n(a[0]), e.shear = a[0][0] * a[1][0] + a[0][1] * a[1][1], a[1] = [a[1][0] - a[0][0] * e.shear, a[1][1] - a[0][1] * e.shear], e.scaley = mathSqrt(t(a[1])), n(a[1]), e.shear /= e.scaley;\n    var i = -a[0][1],\n        r = a[1][1];\n    return 0 > r ? (e.rotate = R.deg(math.acos(r)), 0 > i && (e.rotate = 360 - e.rotate)) : e.rotate = R.deg(math.asin(i)), e.isSimple = !+e.shear.toFixed(9) && (e.scalex.toFixed(9) === e.scaley.toFixed(9) || !e.rotate), e.isSuperSimple = !+e.shear.toFixed(9) && e.scalex.toFixed(9) === e.scaley.toFixed(9) && !e.rotate, e.noRotation = !+e.shear.toFixed(9) && !e.rotate, e;\n  }, e.toTransformString = function (e) {\n    var t = e || this[SPLIT]();\n    return t.isSimple ? (t.scalex = +t.scalex.toFixed(4), t.scaley = +t.scaley.toFixed(4), t.rotate = +t.rotate.toFixed(4), (t.dx || t.dy ? 't' + [t.dx, t.dy] : E) + (1 != t.scalex || 1 != t.scaley ? 's' + [t.scalex, t.scaley, 0, 0] : E) + (t.rotate ? 'r' + [t.rotate, 0, 0] : E)) : mStr + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n  };\n})(Matrix.prototype);\n\nvar navigator = win.navigator,\n    version = navigator.userAgent.match(/Version\\/(.*?)\\s/) || navigator.userAgent.match(/Chrome\\/(\\d+)/);\npaperproto.safari = 'Apple Computer, Inc.' === navigator.vendor && (version && 4 > version[1] || 'iP' === navigator.platform.slice(0, 2)) || 'Google Inc.' === navigator.vendor && version && 8 > version[1] ? function () {\n  var e = this.rect(-99, -99, this.width + 99, this.height + 99).attr({\n    stroke: NONE\n  });\n  return setTimeout(function () {\n    e.remove();\n  }), !0;\n} : fun;\n\nfor (var preventDefault = function preventDefault() {\n  this.returnValue = !1;\n}, preventTouch = function preventTouch() {\n  return this.originalEvent.preventDefault();\n}, stopPropagation = function stopPropagation() {\n  this.cancelBubble = !0;\n}, stopTouch = function stopTouch() {\n  return this.originalEvent.stopPropagation();\n}, eventCopyList = {\n  stopPropagation: 'fn',\n  stopImmediatePropagation: 'fn',\n  preventDefault: 'fn',\n  type: !0,\n  clientX: !0,\n  clientY: !0,\n  pageX: !0,\n  pageY: !0,\n  bubbles: !0,\n  cancelable: !0,\n  touches: !0,\n  target: !0,\n  originalTarget: !0,\n  srcElement: !0,\n  relatedTarget: !0,\n  fromElement: !0,\n  changedTouches: !0,\n  layerX: !0,\n  layerY: !0,\n  deltaX: !0,\n  deltaY: !0\n}, makeSelectiveCopy = R.makeSelectiveCopy = function (e, t) {\n  var _loop = function _loop(n) {\n    e[n] = 'fn' === eventCopyList[n] ? function () {\n      return function () {\n        t[n]();\n      };\n    }(t) : t[n];\n  };\n\n  for (var n in eventCopyList) {\n    _loop(n);\n  }\n\n  e.originalEvent = t, e.type || (e.type = t.originalEvent && t.originalEvent.type);\n}, addEvent = R.addEvent = function () {\n  if (g.doc.addEventListener) return function (t, n, a, r) {\n    var e,\n        i,\n        o = supportsPointer ? safePointerEventMapping[n] : supportsTouch ? touchMap[n] : n;\n    return isIE || (i = {\n      capture: !1\n    }), r.dragFn && ('pointerup' === o ? o = 'mouseup' : o === UNDEF && (o = 'touchend')), e = function e(o) {\n      var s,\n          l = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n          d = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n      if (supportsTouch && touchMap[n]) for (var p = 0, c = o.targetTouches && o.targetTouches.length; p < c; p++) {\n        if (s = o.targetTouches[p].target, s === t || 'tspan' === s.nodeName && s.parentNode === t) {\n          var h = o;\n          o = o.targetTouches[p], o.originalEvent = h, o.preventDefault = preventTouch, o.stopPropagation = stopTouch;\n          break;\n        }\n      }\n      return a.call(r, o, o.clientX + d, o.clientY + l);\n    }, t.addEventListener(o, e, i), function () {\n      return t.removeEventListener(o, e, i), !0;\n    };\n  };\n  return g.doc.attachEvent ? function (e, t, n, a) {\n    var i = function i(t) {\n      t = t || g.win.event;\n      var i = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n          r = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n          o = t.clientX + r,\n          s = t.clientY + i;\n      return t.preventDefault = t.preventDefault || preventDefault, t.stopPropagation = t.stopPropagation || stopPropagation, n.call(a, t, o, s);\n    };\n\n    e.attachEvent('on' + t, i);\n    return function () {\n      return e.detachEvent('on' + t, i), !0;\n    };\n  } : void 0;\n}(), dragMove = function dragMove(t) {\n  var e,\n      n = Math.abs,\n      a = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n      r = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n      o = (t.clientX === UNDEF ? t.changedTouches && t.changedTouches[0].clientX : t.clientX) + r,\n      s = (t.clientY === UNDEF ? t.changedTouches && t.changedTouches[0].clientY : t.clientY) + a,\n      l = {},\n      d = this,\n      p = d.dragInfo.onmove.length;\n  if (!(d.dragStartFn && !(2.5 <= n(o - d._drag.x) || 2.5 <= n(s - d._drag.y)) || d._blockDrag || supportsPointer && supportsTouch && !t.isPrimary)) for (; p--;) {\n    if (supportsTouch && 'touchmove' === t.type) for (var c, h = t.touches.length; h--;) {\n      if (c = t.touches[h], c.identifier === d._drag.id) {\n        o = c.clientX + r, s = c.clientY + a;\n        break;\n      }\n    }\n\n    if (!d.removed) {\n      if (d.dragStartFn && (d.dragStartFn(p), d.dragStartFn = void 0, d.dragInfo._dragmove = !0), g.win.opera) {\n        var u = R._engine.getNode(d),\n            m = u.nextSibling,\n            f = u.parentNode,\n            b = u.style.display;\n\n        f.removeChild(u), u.style.display = NONE, u.style.display = b, m ? f.insertBefore(u, m) : f.appendChild(u);\n      }\n\n      makeSelectiveCopy(l, t), e = l.data = [o - d._drag.x, s - d._drag.y, o, s], eve('raphael.drag.move.' + d.id, d.dragInfo.move_scope[p] || d, l, e);\n    }\n  }\n}, dragUp = function dragUp(t) {\n  var e = this,\n      n = e.dragInfo,\n      a = n.onend.length;\n  if (e.dragInfo._dragmove) for (; a--;) {\n    e._drag = {}, eve('raphael.drag.end.' + e.id, n.end_scope[a] || n.start_scope[a] || n.move_scope[a] || e, t);\n  }\n  e.dragInfo._dragmove = void 0, !supportsTouch || isIE11 || isEdge || isWindows && isFirefox || (e.paper.canvas.style['touch-action'] = 'auto'), R.undragmove.call(e, dragMove), R.undragend.call(e, dragUp), R.unmousemove.call(e, dragMove).unmouseup.call(e, dragUp);\n}, elproto = R.el = {}, i = events.length; i--;) {\n  (function (e) {\n    R[e] = elproto[e] = function (t, n, a) {\n      return R.is(t, FUNCTION) && (this.events = this.events || [], this.events.push({\n        name: e,\n        f: t,\n        unbind: addEvent(a || this.shape || this.node || g.doc, e, t, n || this)\n      })), this;\n    }, R['un' + e] = elproto['un' + e] = function (t) {\n      for (var n = this.events || [], a = n.length; a--;) {\n        if (n[a].name === e && n[a].f === t) return n[a].unbind(), n.splice(a, 1), n.length || delete this.events, this;\n      }\n\n      return this;\n    };\n  })(events[i]);\n}\n\nelproto.data = function (e, t) {\n  var n = eldata[this.id] = eldata[this.id] || {};\n\n  if (1 === arguments.length) {\n    if (R.is(e, OBJECT)) {\n      for (var a in e) {\n        e[HAS](a) && this.data(a, e[a]);\n      }\n\n      return this;\n    }\n\n    return R.stopPartialEventPropagation || eve('raphael.data.get.' + this.id, this, n[e], e), n[e];\n  }\n\n  return n[e] = t, R.stopPartialEventPropagation || eve('raphael.data.set.' + this.id, this, t, e), this;\n}, elproto.removeData = function (e) {\n  return null == e ? delete eldata[this.id] : eldata[this.id] && delete eldata[this.id][e], this;\n}, elproto.dbclick = function (t, n) {\n  var e,\n      a = this,\n      i = function i(e) {\n    return !e.touches || e.touches && 1 === e.touches.length;\n  },\n      r = function r(_r) {\n    (!supportsPointer || _r.isPrimary) && (_r && _r.preventDefault(), i(_r) && (a._tappedOnce ? (t.call(n || a, _r), a._tappedOnce = !1) : (a._tappedOnce = !0, setTimeout(function () {\n      a._tappedOnce = !1;\n    }, 500))));\n  };\n\n  e = supportsPointer ? 'pointerup' : R.supportsTouch ? 'touchstart' : 'mouseup', a.node.addEventListener(e, r), R.storeHandlers(a, t, r);\n}, elproto.undbclick = function (e) {\n  var t = this,\n      n = removeHandlers(t, e);\n  n && t.node.removeEventListener(supportsPointer ? 'pointerup' : R.supportsTouch ? 'touchstart' : 'mouseup', n);\n}, elproto.getData = function () {\n  return clone(eldata[this.id] || {});\n};\n\nvar downables = [],\n    mouseDown = function mouseDown() {\n  this.untrack = addEvent(g.doc, 'mouseup', mouseUp, this);\n},\n    mouseUp = function mouseUp() {\n  return this.untrack(), this.untrack = null, this.fn && this.fn.apply(this.scope || this.el, arguments);\n};\n\nelproto.mouseup = function (e, t, n, a) {\n  return n ? (downables.push(n = {\n    el: this,\n    fn: e,\n    scope: t\n  }), n.unbind = addEvent(this.shape || this.node || g.doc, 'mousedown', mouseDown, n), this) : R.mouseup.apply(this, [e, t, a]);\n}, elproto.unmouseup = function (e) {\n  for (var t, n = downables.length; n--;) {\n    downables[n].el === this && downables[n].fn === e && (t = downables[n], t.unbind(), t.untrack && t.untrack(), downables.splice(n, 1));\n  }\n\n  return t ? this : R.unmouseup.apply(this, arguments);\n}, elproto.hover = function (e, t, n, a) {\n  return this.on('fc-mouseover', e, n).on('fc-mouseout', t, a);\n}, elproto.unhover = function (e, t) {\n  return this.off('fc-mouseover', e).off('fc-mouseout', t);\n}, elproto.fcclick = function (t, n) {\n  var e,\n      a,\n      i,\n      r,\n      o,\n      s = Math.abs,\n      l = this,\n      d = l.node,\n      p = function p(t) {\n    l._lastEventTriggered = 'mousedown', i = t.clientX === UNDEF ? t.changedTouches && t.changedTouches[0].clientX : t.clientX, r = t.clientY === UNDEF ? t.changedTouches && t.changedTouches[0].clientY : t.clientY;\n  },\n      c = function c(t) {\n    var e = t.clientX === UNDEF ? t.changedTouches && t.changedTouches[0].clientX : t.clientX,\n        n = t.clientY === UNDEF ? t.changedTouches && t.changedTouches[0].clientY : t.clientY;\n    (2.5 <= s(i - e) || 2.5 <= s(r - n)) && (l._lastEventTriggered = void 0);\n  };\n\n  if (l._clickStoreActual || (l._clickStoreActual = []), l._clickStoreDerived || (l._clickStoreDerived = []), !l._clickHandlerHelper) {\n    for (e in o = !supportsPointer && R.supportsTouch ? {\n      touchstart: function touchstart() {\n        l._lastEventTriggered = 'touchstart', l._lastEventTriggeredAt = new Date().getTime();\n      },\n      touchmove: c\n    } : supportsPointer && R.supportsTouch ? {\n      pointerdown: p,\n      pointermove: c\n    } : {\n      mousedown: p,\n      mousemove: c\n    }, o) {\n      d.addEventListener ? d.addEventListener(e, o[e]) : d.attachEvent('on' + e, o[e]);\n    }\n\n    l._clickHandlerHelper = o;\n  }\n\n  return !supportsPointer && R.supportsTouch ? (e = 'touchend', a = function a(_a) {\n    'touchstart' === l._lastEventTriggered && 500 >= new Date().getTime() - l._lastEventTriggeredAt && setTimeout(function () {\n      t.call(n || l, _a);\n    }, 0);\n  }) : (e = 'click', a = function a(_a2) {\n    'mousedown' === l._lastEventTriggered && t.call(n || l, _a2);\n  }), d.addEventListener ? d.addEventListener(e, a) : d.attachEvent('on' + e, a), l._clickStoreDerived.push(a), l._clickStoreActual.push(t), l;\n}, elproto.fcunclick = function (e) {\n  var t,\n      n,\n      a = this,\n      r = a.node,\n      o = a._clickHandlerHelper,\n      s = a._clickStoreActual,\n      l = a._clickStoreDerived;\n\n  if (s) {\n    for (t = s.length - 1; 0 <= t; t--) {\n      s[t] === e && (r.removeEventListener ? r.removeEventListener(!supportsPointer && R.supportsTouch ? 'touchend' : 'click', l[t]) : r.detachEvent('onclick', l[t]), s.splice(t, 1), l.splice(t, 1));\n    }\n\n    if (!s.length) {\n      for (n in o) {\n        r.removeEventListener ? r.removeEventListener(n, o[n]) : r.detachEvent('on' + n, o[n]);\n      }\n\n      a._clickHandlerHelper = void 0;\n    }\n  }\n\n  return a;\n};\nvar draggable = [];\nelproto.drag = function (e, t, n, a, i, r) {\n  var o = this,\n      s = o.dragInfo || (o.dragInfo = {\n    onmove: [],\n    onstart: [],\n    onend: [],\n    move_scope: [],\n    start_scope: [],\n    end_scope: []\n  });\n  return e && s.onmove.push(e) && s.move_scope.push(a), t && s.onstart.push(t) && s.start_scope.push(i), n && s.onend.push(n) && s.end_scope.push(r), o.dragFn = o.dragFn || function (t) {\n    var e,\n        n,\n        a,\n        r,\n        s,\n        l,\n        d,\n        p,\n        c,\n        h,\n        u = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n        m = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n        f = {},\n        y = o.dragInfo,\n        x = [dragMove, undef, g.doc];\n\n    if (!supportsPointer || t.isPrimary) {\n      for (supportsTouch && (supportsPointer ? !(isIE11 || isEdge) && !(isWindows && isFirefox) && (o.paper.canvas.style['touch-action'] = 'none') : t.preventDefault()), o._drag.x = c = (t.clientX === UNDEF ? t.changedTouches && t.changedTouches[0].clientX : t.clientX) + m, o._drag.y = h = (t.clientY === UNDEF ? t.changedTouches && t.changedTouches[0].clientY : t.clientY) + u, o._drag.id = t.identifier, supportsTouch && !supportsPointer ? R.dragmove.apply(o, x) : R.mousemove.apply(o, x).mouseup.call(o, dragUp, undef, undef, g.doc), supportsTouch && R.dragend.call(o, dragUp, undef, g.doc), makeSelectiveCopy(f, t), e = f.data = [c, h], (n = 0, s = y.onstart.length); n < s; n++) {\n        eve.on('raphael.drag.start.' + o.id, y.onstart[n]);\n      }\n\n      for (a = 0, l = y.onmove.length; a < l; a++) {\n        eve.on('raphael.drag.move.' + o.id, y.onmove[a]);\n      }\n\n      for (r = 0, d = y.onend.length; r < d; r++) {\n        eve.on('raphael.drag.end.' + o.id, y.onend[r]);\n      }\n\n      s && !l && (p = function p() {\n        o.undragmove(), y.onmove = [];\n      }, y.onmove.push(p), eve.on('raphael.drag.end.' + o.id, p)), o.dragStartFn = function (t) {\n        eve('raphael.drag.start.' + o.id, o.dragInfo.start_scope[t] || o.dragInfo.move_scope[t] || o, f, e);\n      };\n    }\n  }, o._drag = {}, draggable.push({\n    el: o,\n    start: o.dragFn,\n    onstart: t,\n    onmove: e,\n    onend: n\n  }), t && !o.startHandlerAttached && (supportsTouch && !supportsPointer ? o.dragstart(o.dragFn) : o.mousedown(o.dragFn), o.startHandlerAttached = !0), o;\n}, elproto.onDragOver = function (e) {\n  e ? eve.on('raphael.drag.over.' + this.id, e) : eve.unbind('raphael.drag.over.' + this.id);\n}, elproto.undrag = function () {\n  for (var e = this, t = draggable.length; t--;) {\n    draggable[t].el === e && (e.unmousedown(e.dragFn), draggable.splice(t, 1), eve.unbind('raphael.drag.*.' + e.id), e.dragInfo = void 0, e.dragFn = void 0, e.startHandlerAttached = void 0);\n  }\n\n  R.unmousemove.call(e, dragMove).unmouseup.call(e, dragUp), R.undragmove.call(e, dragMove), R.undragend.call(e, dragUp), delete e._drag;\n}, elproto.undragstart = function (e) {\n  var t,\n      n,\n      a = this,\n      r = a.dragInfo,\n      o = r && r.onstart,\n      s = r && r.start_scope;\n  if (e) for (t = 0, n = o && o.length; t < n; t++) {\n    if (o[t] === e) {\n      o.splice(t, 1), s.splice(t, 1), eve.unbind('raphael.drag.start.' + this.id, e);\n      break;\n    }\n  }\n  o && o.length && e || (R.undragstart.call(a, a.dragFn), R.unmousedown.call(a, a.dragFn), eve.unbind('raphael.drag.start.' + this.id), a.startHandlerAttached = !1, r && (r.onstart = [], r.start_scope = []));\n}, elproto.undragmove = function (e) {\n  var t,\n      n,\n      a = this,\n      r = a.dragInfo,\n      o = r && r.onmove,\n      s = r && r.move_scope;\n  if (e) for (t = 0, n = o && o.length; t < n; t++) {\n    if (o[t] === e) {\n      o.splice(t, 1), s.splice(t, 1), eve.unbind('raphael.drag.move.' + this.id, e);\n      break;\n    }\n  }\n  o && o.length && e || (R.undragmove.call(a, dragMove), R.unmousemove.call(a, dragMove), r && (r.onmove = [], r.move_scope = []), eve.unbind('raphael.drag.move.' + this.id));\n}, elproto.undragend = function (e) {\n  var t,\n      n,\n      a = this,\n      r = a.dragInfo,\n      o = r && r.onend,\n      s = r && r.end_scope;\n  if (e) for (t = 0, n = o && o.length; t < n; t++) {\n    if (o[t] === e) {\n      o.splice(t, 1), s.splice(t, 1), eve.unbind('raphael.drag.end.' + this.id, e);\n      break;\n    }\n  }\n  o && o.length && e || (R.undragend.call(a, dragUp), R.unmouseup.call(a, dragUp), r && (r.onend = [], r.end_scope = []), eve.unbind('raphael.drag.end.' + this.id));\n}, elproto.follow = function (e, t, n) {\n  return e.removed || e.constructor !== R.el.constructor ? this : (e.followers.push({\n    el: this,\n    stalk: n = {\n      before: 'insertBefore',\n      after: 'insertAfter'\n    }[n],\n    cb: t\n  }), n && this[n](e), this);\n}, elproto.unfollow = function (e) {\n  if (e.removed || e.constructor !== R.el.constructor) return this;\n\n  for (var t = 0, n = e.followers.length; t < n; t++) {\n    if (e.followers[t].el === this) {\n      e.followers.splice(t, 1);\n      break;\n    }\n  }\n\n  return this;\n}, paperproto.hide = function () {\n  var e = this;\n  return e.canvas.style.visibility = 'hidden', e;\n}, paperproto.show = function () {\n  var e = this;\n  return e.canvas.style.visibility = E, e;\n}, paperproto.group = function () {\n  var e = this,\n      t = getArrayCopy(arguments),\n      n = lastArgIfGroup(t, !0),\n      a = R._engine.group(e, t[0], n);\n\n  return e.__set__ && e.__set__.push(a), e._elementsById[a.id] = a;\n}, paperproto.circle = function () {\n  var e = this,\n      t = getArrayCopy(arguments),\n      n = lastArgIfGroup(t, !0),\n      a = e._addDefAttribs() ? serializeArgs(t, 'cx', 0, 'cy', 0, 'r', 0, 'fill', NONE, 'stroke', BLACK) : serializeArgs(t),\n      i = R._engine.circle(e, a, n);\n\n  return e.__set__ && e.__set__.push(i), e._elementsById[i.id] = i;\n}, paperproto.rect = function () {\n  var e = this,\n      t = getArrayCopy(arguments),\n      n = lastArgIfGroup(t, !0),\n      a = e._addDefAttribs() ? serializeArgs(t, 'x', 0, 'y', 0, 'width', 0, 'height', 0, 'r', 0, 'fill', NONE, 'stroke', BLACK) : serializeArgs(t),\n      i = R._engine.rect(e, a, n);\n\n  return e.__set__ && e.__set__.push(i), e._elementsById[i.id] = i;\n}, paperproto.ellipse = function () {\n  var e = this,\n      t = getArrayCopy(arguments),\n      n = lastArgIfGroup(t, !0),\n      a = e._addDefAttribs() ? serializeArgs(t, 'x', 0, 'y', 0, 'rx', 0, 'ry', 0, 'fill', NONE, 'stroke', BLACK) : serializeArgs(t),\n      i = R._engine.ellipse(this, a, n);\n\n  return e.__set__ && e.__set__.push(i), e._elementsById[i.id] = i;\n}, paperproto.path = function () {\n  var e = this,\n      t = getArrayCopy(arguments),\n      n = lastArgIfGroup(t, !0),\n      a = e.config,\n      i = a && a['stroke-linecap'] || 'butt',\n      r = e._addDefAttribs() ? serializeArgs(t, 'path', E, 'fill', NONE, 'stroke', BLACK, 'stroke-linecap', i) : serializeArgs(t),\n      o = R._engine.path(e, r, n);\n\n  return e.__set__ && e.__set__.push(o), e._elementsById[o.id] = o;\n}, paperproto.image = function () {\n  var e = this,\n      t = getArrayCopy(arguments),\n      n = lastArgIfGroup(t, !0),\n      a = e._addDefAttribs() ? serializeArgs(t, 'x', 0, 'y', 0, 'width', 0, 'height', 0) : serializeArgs(t),\n      i = R._engine.image(e, a, n);\n\n  return e.__set__ && e.__set__.push(i), e._elementsById[i.id] = i;\n}, paperproto.text = function () {\n  var e = this,\n      t = getArrayCopy(arguments),\n      n = lastArgIfGroup(t, !0),\n      a = e._addDefAttribs() ? serializeArgs(t, 'x', 0, 'y', 0, 'text', E, 'stroke', NONE, 'fill', BLACK, 'text-anchor', 'middle', 'vertical-align', 'middle') : serializeArgs(t),\n      i = R._engine.text(e, a, n, t[1]);\n\n  return e.__set__ && e.__set__.push(i), e._elementsById[i.id] = i;\n}, paperproto._addDefAttribs = function () {\n  return !(R.svg && this.config && this.config.noDefaultAttribs);\n}, paperproto.setConfig = function (e, t) {\n  var n = this;\n  return void 0 !== e && void 0 !== t && (n.config = n.config || {}, n.config[e] = t), n.config;\n}, paperproto._createDOMNodes = function (e, t, n) {\n  var a,\n      r,\n      o,\n      s,\n      l = this,\n      d = {},\n      p = R._createNode,\n      c = t.tagName,\n      g = t.children || [];\n\n  for (s in n || (n = {}), t) {\n    'tagName' !== s && 'children' !== s && (d[s] = t[s]);\n  }\n\n  if (d.id || (d.id = R.getElementID(R.createUUID())), !l.canvas.getElementById(d.id) && c) for (a = e.appendChild(p(c, d)), n.element = a, n.id = d.id, o = g.length, 0 < o && (n.children = []), r = 0; r < o; r++) {\n    n.children[r] = {}, l._createDOMNodes(a, g[r], n.children[r]);\n  }\n  return n;\n}, paperproto.addDefs = function (e) {\n  if (R.svg) {\n    var t,\n        n = this,\n        a = {},\n        i = n.defs;\n\n    for (t in e) {\n      a[t] = {}, n._createDOMNodes(i, e[t], a[t]);\n    }\n\n    return a;\n  }\n}, paperproto.setSize = function (e, t) {\n  return R._engine.setSize.call(this, e, t);\n}, paperproto.setDimension = function (e, t) {\n  var n,\n      a = this;\n  typeof e == OBJECT ? (n = e.width, t = e.height, a.setSize(e.width, e.height)) : (n = e, a.setSize(n, t));\n}, paperproto.attr = function (e) {\n  var t = this;\n  return null == e ? {\n    width: t.width,\n    height: t.height\n  } : R.is(e, STRING) ? t[e] : (t.setDimension(e), t);\n}, paperproto.status = function (e, t) {\n  return elproto.status.call(this, e, t);\n}, paperproto.animateWith = function (e, t, n, a, i, r, o) {\n  return elproto.animateWith.call(this, e, t, n, a, i, r, o);\n}, paperproto.animate = function (e, t, n, a) {\n  return elproto.animate.call(this, e, t, n, a);\n}, paperproto.setViewBox = function (e, t, n, a, i) {\n  return R._engine.setViewBox.call(this, e, t, n, a, i);\n}, paperproto.getById = function (e) {\n  return this._elementsById[e] || null;\n}, paperproto.top = paperproto.bottom = null, paperproto.raphael = R;\n\nfunction x_y() {\n  return this.x + S + this.y;\n}\n\nfunction x_y_w_h() {\n  return this.x + S + this.y + S + this.width + ' \\xD7 ' + this.height;\n}\n\nelproto.getBBox = function (e) {\n  if (this.removed) return {};\n  var t = this._;\n  return e ? ((t.dirty || !t.bboxwt) && (this.realPath = getPath[this.type](this), t.bboxwt = pathDimensions(this.realPath), t.bboxwt.toString = x_y_w_h, t.dirty = 0), t.bboxwt) : ((t.dirty || t.dirtyT || !t.bbox) && ((t.dirty || !this.realPath) && (t.bboxwt = 0, this.realPath = getPath[this.type](this)), t.bbox = pathDimensions(mapPath(this.realPath, this.matrix)), t.bbox.toString = x_y_w_h, t.dirty = t.dirtyT = 0), t.bbox);\n}, elproto.clone = function (e, t) {\n  if (this.removed) return null;\n  var n,\n      a,\n      i = this,\n      r = i.attr();\n  if (!e) a = i.paper[i.type]().attr(r);else {\n    for (n in e) {\n      r[n] = e[n];\n    }\n\n    a = i.paper[i.type](r, t);\n  }\n  return i.__set__ && i.__set__.push(a), a;\n};\n\nvar curveslengths = {},\n    getPointAtSegmentLength = function getPointAtSegmentLength(e, t, n, a, i, r, o, s, l) {\n  return null == l ? bezlen(e, t, n, a, i, r, o, s) : R.findDotsAtSegment(e, t, n, a, i, r, o, s, getTatLen(e, t, n, a, i, r, o, s, l));\n},\n    getLengthFactory = function getLengthFactory(e, t) {\n  return function (n, a, r) {\n    n = path2curve(n);\n\n    for (var o, s, d, c, g, h = E, u = {}, m = 0, f = 0, b = n.length; f < b; f++) {\n      if (d = n[f], d[0] === strM) o = +d[1], s = +d[2];else {\n        if (c = getPointAtSegmentLength(o, s, d[1], d[2], d[3], d[4], d[5], d[6]), m + c > a) {\n          if (t && !u.start) {\n            if (g = getPointAtSegmentLength(o, s, d[1], d[2], d[3], d[4], d[5], d[6], a - m), h += ['C' + g.start.x, g.start.y, g.m.x, g.m.y, g.x, g.y], r) return h;\n            u.start = h, h = [strM + g.x, g.y + 'C' + g.n.x, g.n.y, g.end.x, g.end.y, d[5], d[6]].join(), m += c, o = +d[5], s = +d[6];\n            continue;\n          }\n\n          if (!e && !t) return g = getPointAtSegmentLength(o, s, d[1], d[2], d[3], d[4], d[5], d[6], a - m), {\n            x: g.x,\n            y: g.y,\n            alpha: g.alpha\n          };\n        }\n\n        m += c, o = +d[5], s = +d[6];\n      }\n      h += d.shift() + d;\n    }\n\n    return u.end = h, g = e ? m : t ? u : R.findDotsAtSegment(o, s, d[0], d[1], d[2], d[3], d[4], d[5], 1), g.alpha && (g = {\n      x: g.x,\n      y: g.y,\n      alpha: g.alpha\n    }), g;\n  };\n},\n    getTotalLength = getLengthFactory(1),\n    getPointAtLength = getLengthFactory(),\n    getSubpathsAtLength = getLengthFactory(0, 1);\n\nR.getTotalLength = getTotalLength, R.getPointAtLength = getPointAtLength, elproto.getTotalLength = function () {\n  return 'path' == this.type ? this.node.getTotalLength ? this.node.getTotalLength() : getTotalLength(this.attrs.path) : void 0;\n}, elproto.getPointAtLength = function (e) {\n  return 'path' == this.type ? getPointAtLength(this.attrs.path, e) : void 0;\n};\nvar ef = R.easing_formulas = {\n  linear: function linear(e) {\n    return e;\n  },\n  \"<\": function _(e) {\n    return pow(e, 1.7);\n  },\n  \">\": function _(e) {\n    return pow(e, .48);\n  },\n  \"<>\": function _(e) {\n    var n = .48 - e / 1.04,\n        a = mathSqrt(.1734 + n * n),\n        i = a - n,\n        r = pow(abs(i), 1 / 3) * (0 > i ? -1 : 1),\n        o = -a - n,\n        s = pow(abs(o), 1 / 3) * (0 > o ? -1 : 1),\n        l = r + s + .5;\n    return 3 * (1 - l) * l * l + l * l * l;\n  },\n  backIn: function backIn(e) {\n    var t = 1.70158;\n    return e * e * ((t + 1) * e - t);\n  },\n  backOut: function backOut(e) {\n    --e;\n    var t = 1.70158;\n    return e * e * ((t + 1) * e + t) + 1;\n  },\n  elastic: function elastic(e) {\n    return e === !!e ? e : pow(2, -10 * e) * mathSin((e - .075) * (2 * PI) / .3) + 1;\n  },\n  bounce: function bounce(e) {\n    var t,\n        a = 7.5625,\n        i = 2.75;\n    return e < 1 / i ? t = a * e * e : e < 2 / i ? (e -= 1.5 / i, t = a * e * e + .75) : e < 2.5 / i ? (e -= 2.25 / i, t = a * e * e + .9375) : (e -= 2.625 / i, t = a * e * e + .984375), t;\n  },\n  oneBounceOut: function oneBounceOut(e) {\n    return .9 >= e ? 1.33 * ef.easeIn(e) : 1.2 - e / 5;\n  },\n  elasticOnce: function elasticOnce(e) {\n    var t = .9;\n    return e === !!e ? e : Math.pow(2, -10 * e) * Math.sin((e - t / 4) * (2 * Math.PI) / t) + 1;\n  },\n  easeInQuad: function easeInQuad(e) {\n    return e * e;\n  },\n  easeOutQuad: function easeOutQuad(e) {\n    return e * (2 - e);\n  },\n  easeInOutQuad: function easeInOutQuad(e) {\n    return .5 > e ? 2 * e * e : -1 + (4 - 2 * e) * e;\n  },\n  easeInCubic: function easeInCubic(e) {\n    return e * e * e;\n  },\n  easeOutCubic: function easeOutCubic(e) {\n    return --e * e * e + 1;\n  },\n  easeInOutCubic: function easeInOutCubic(e) {\n    return .5 > e ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;\n  },\n  easeInQuart: function easeInQuart(e) {\n    return e * e * e * e;\n  },\n  easeOutQuart: function easeOutQuart(e) {\n    return 1 - --e * e * e * e;\n  },\n  easeInOutQuart: function easeInOutQuart(e) {\n    return .5 > e ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;\n  },\n  easeInQuint: function easeInQuint(e) {\n    return e * e * e * e * e;\n  },\n  easeOutQuint: function easeOutQuint(e) {\n    return 1 + --e * e * e * e * e;\n  },\n  easeInOutQuint: function easeInOutQuint(e) {\n    return .5 > e ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;\n  }\n};\nef.easeIn = ef['ease-in'] = ef['<'], ef.easeOut = ef['ease-out'] = ef['>'], ef.easeInOut = ef['ease-in-out'] = ef['<>'], ef['back-in'] = ef.backIn, ef['back-out'] = ef.backOut;\n\nvar requestAnimFrame,\n    animationElements = [],\n    animation = function animation() {\n  for (var n, a, r, o, s = +new Date(), d = 0, p = [], c = 0, g = 0; d < animationElements.length; d++) {\n    if (o = animationElements[d], !(o.el.removed || o.paused || o.parentEl && o.parentEl.e && o.parentEl.e.paused)) {\n      for (var h, u, m, f = s - o.start, y = o.ms, x = o.easing, b = o.from, v = o.diff, _ = o.to, A = o.t, t = o.el, k = {}, C = {}, T = !R.stopPartialEventPropagation, c = 0, w = o.el && o.el.animElements && o.el.animElements.peek(); w && w.pos <= f / y;) {\n        p.push(o.el.animElements.deq()), w = o.el.animElements.peek();\n      }\n\n      if (o.initstatus ? (f = (o.initstatus * o.anim.top - o.prev) / (o.percent - o.prev) * y, o.status = o.initstatus, delete o.initstatus, o.stop && (delete o.el, animationElements.splice(d--, 1))) : o.status = (o.prev + (o.percent - o.prev) * (f / y)) / o.anim.top, u = y, o.parentEl && o.parentEl.animElements ? (y = o.delayend - o.delaystart, f = o.parentEl.cPos - o.delaystart) : o.el.animElements && (o.el.cPos = f / y), !(0 > f)) if (f < y) {\n        var P = x(f / y);\n\n        for (var I in y = u, b) {\n          if (b[HAS](I)) {\n            switch (availableAnimAttrs[I]) {\n              case 'number':\n                h = +b[I] + P * y * v[I];\n                break;\n\n              case 'colour':\n                if (!v[I].length) n = b[I].opacity + P * y * v[I].opacity, isNaN(n) && (n = 1), h = 'rgba(' + [upto255(round(b[I].r + P * y * v[I].r)), upto255(round(b[I].g + P * y * v[I].g)), upto255(round(b[I].b + P * y * v[I].b)), n].join(COMMA) + ')';else {\n                  for (h = [], c = 0, L = b[I].length; c < L; ++c) {\n                    0 === c ? b[I].isRadial || v[I].isRadial ? (a = 'xr(', a += b[I][0].f1 * (1 - P) + v[I][0].f1 * P || E, a += ',', a += b[I][0].f2 * (1 - P) + v[I][0].f2 * P || E, a += ',', a += 100 * (b[I][0].f3 * (1 - P) + v[I][0].f3 * P) || E, a += '%,', a += b[I][0].f4 * (1 - P) + v[I][0].f4 * P || E, a += ',', a += b[I][0].f5 * (1 - P) + v[I][0].f5 * P, a += ',', a += b[I][0].f6, a += ')', h.push(a)) : (h.push(b[I][c] * (1 - P) + P * v[I][c]), 0 >= h[0] && (h[0] += 360)) : h.push('rgba(' + [upto255(round(b[I][c].r + P * y * v[I][c].r)), upto255(round(b[I][c].g + P * y * v[I][c].g)), upto255(round(b[I][c].b + P * y * v[I][c].b)), b[I][c].opacity + P * y * v[I][c].opacity].join(COMMA) + '):' + b[I][c].position);\n                  }\n\n                  h = h.join('-'), (b[I].isRadial || v[I].isRadial) && (h = h.replace('-', E));\n                }\n                break;\n\n              case 'path':\n                h = [];\n\n                for (var c = 0, L = b[I].length; c < L; c++) {\n                  h[c] = [b[I][c][0]];\n                  var F = b[I][c] ? b[I][c].length : 0;\n\n                  for (var O = 1; O < F; O++) {\n                    h[c][O] = (+b[I][c][O] + P * y * v[I][c][O]).toFixed(4);\n                  }\n\n                  h[c] = h[c].join(S);\n                }\n\n                h = h.join(S);\n                break;\n\n              case 'transform':\n                if (v[I].real) for (h = [], c = 0, L = b[I].length; c < L; c++) {\n                  for (h[c] = [b[I][c][0]], O = 1, F = b[I][c].length; O < F; O++) {\n                    h[c][O] = b[I][c][O] + P * y * v[I][c][O];\n                  }\n                } else {\n                  var N = function N(e) {\n                    return +b[I][e] + P * y * v[I][e];\n                  };\n\n                  h = [[mStr, N(0), N(1), N(2), N(3), N(4), N(5)]];\n                }\n                break;\n\n              case 'csv':\n                if ('clip-rect' === I) for (h = [], c = 4; c--;) {\n                  h[c] = +b[I][c] + P * y * v[I][c];\n                }\n                break;\n\n              case 'text-bound':\n                h = [][CONCAT](b[I]);\n                break;\n\n              default:\n                var B = [][CONCAT](b[I]);\n\n                for (h = [], c = t.ca[I].length; c--;) {\n                  h[c] = +B[c] + P * y * v[I][c];\n                }\n\n            }\n\n            k[I] = h;\n          }\n        }\n\n        t.attr(k), T && function (e, t, n) {\n          setTimeout(function () {\n            eve('raphael.anim.frame.' + e, t, n);\n          });\n        }(t.id, t, o.anim);\n      } else {\n        if (function (e, t, n) {\n          setTimeout(function () {\n            T && eve('raphael.anim.frame.' + t.id, t, n), T && eve('raphael.anim.finish.' + t.id, t, n), R.is(e, FUNCTION) && e.call(t);\n          });\n        }(o.callback, t, o.anim), t.attr(_), delete o.el, animationElements.splice(d--, 1), 1 < o.repeat && !o.next) {\n          for (m in _) {\n            _[HAS](m) && (C[m] = o.totalOrigin[m]);\n          }\n\n          o.el.attr(C), runAnimation(o.anim, o.el, o.anim.percents[0], null, o.totalOrigin, o.repeat - 1);\n        }\n\n        o.next && !o.stop && runAnimation(o.anim, o.el, o.next, null, o.totalOrigin, o.repeat);\n      }\n    }\n  }\n\n  for (R.svg && t && t.paper && t.paper.safari(), d = 0, g = p.length; d < g; ++d) {\n    r = R.getInstantAnimFrameFn(), r(function (e) {\n      return function () {\n        runAnimation.apply(null, p[e].params);\n      };\n    }(d));\n  }\n\n  animationElements.length && (requestAnimFrame || R.getAnimFrameFn())(animation);\n},\n    upto255 = function upto255(e) {\n  return 255 < e ? 255 : 0 > e ? 0 : e;\n},\n    checkPercentage = function checkPercentage(e) {\n  return 1 < e && (e = 1), 0 > e && (e = 0), e;\n};\n\nR.getAnimFrameFn = function () {\n  return requestAnimFrame = R.requestAnimFrame || _win.webkitRequestAnimationFrame || _win.mozRequestAnimationFrame || _win.oRequestAnimationFrame || _win.msRequestAnimationFrame || function (e) {\n    setTimeout(e, 16);\n  };\n}, R.getInstantAnimFrameFn = function () {\n  return R.instantRequestAnimFrame || _win.webkitRequestAnimationFrame || _win.mozRequestAnimationFrame || _win.oRequestAnimationFrame || _win.msRequestAnimationFrame || function (e) {\n    setTimeout(e, 16);\n  };\n}, elproto.animateWith = function (e, t, n, r, o, s, l) {\n  var d,\n      p = this,\n      c = {};\n\n  for (d in l = l || {}, l) {\n    l.hasOwnProperty(d) && (c[d] = l[d]);\n  }\n\n  if (l = c, p.removed) return s && s.call(p), p;\n  if (0 === r) return R.is(s, FUNCTION) && setTimeout(function () {\n    s.call(p);\n  }, 0), p.attr(n);\n  var g = n instanceof Animation ? n : R.animation(n, r, o, s);\n  l.start = checkPercentage(l.start || 0), l.end = checkPercentage(l.end || 1), l.start >= l.end && (l.start = l.end), !l.from && .01 < l.start ? (e.animElements = e.animElements || new PriorityQueue(function (e, t) {\n    return t.pos - e.pos;\n  }), e.animElements.enq({\n    pos: l.start,\n    attr: l.start === l.end,\n    params: [g, p, g.percents[0], null, p.attr(), void 0, e, {\n      start: l.start,\n      end: l.end,\n      smartMorph: l.smartMorph,\n      hookFn: l.hookFn\n    }, n],\n    executeOb: {\n      el: this,\n      attrs: n,\n      callback: s,\n      hookFn: l.hookFn\n    }\n  })) : runAnimation(g, p, g.percents[0], null, p.attr(), void 0, e, l);\n\n  for (var a = 0, h = animationElements.length; a < h; a++) {\n    if (animationElements[a].anim === t && animationElements[a].el === e) {\n      animationElements[h - 1].start = animationElements[a].start;\n      break;\n    }\n  }\n\n  return p;\n};\n\nfunction CubicBezierAtTime(e, t, n, a, i, r) {\n  function o(e) {\n    return ((p * e + d) * e + l) * e;\n  }\n\n  function s(e, t) {\n    var n, a, r, s, c, g;\n\n    for (r = e, g = 0; 8 > g; g++) {\n      if (s = o(r) - e, abs(s) < t) return r;\n      if (c = (3 * p * r + 2 * d) * r + l, 1e-6 > abs(c)) break;\n      r -= s / c;\n    }\n\n    if (n = 0, a = 1, r = e, r < n) return n;\n    if (r > a) return a;\n\n    for (; n < a;) {\n      if (s = o(r), abs(s - e) < t) return r;\n      e > s ? n = r : a = r, r = (a - n) / 2 + n;\n    }\n\n    return r;\n  }\n\n  var l = 3 * t,\n      d = 3 * (a - t) - l,\n      p = 1 - l - d,\n      c = 3 * n,\n      g = 3 * (i - n) - c;\n  return function (e, n) {\n    var a = s(e, n);\n    return (((1 - c - g) * a + g) * a + c) * a;\n  }(e, 1 / (200 * r));\n}\n\nelproto.onAnimation = function (e) {\n  return e ? eve.on('raphael.anim.frame.' + this.id, e) : eve.unbind('raphael.anim.frame.' + this.id), this;\n};\n\nfunction Animation(e, t) {\n  var n = [],\n      a = {};\n\n  if (this.ms = t, this.times = 1, e) {\n    for (var i in e) {\n      e[HAS](i) && (a[toFloat(i)] = e[i], n.push(toFloat(i)));\n    }\n\n    n.sort(sortByNumber);\n  }\n\n  this.anim = a, this.top = n[n.length - 1], this.percents = n;\n}\n\nAnimation.prototype.delay = function (e) {\n  var t = new Animation(this.anim, this.ms);\n  return t.times = this.times, t.del = +e || 0, t;\n}, Animation.prototype.repeat = function (e) {\n  var t = new Animation(this.anim, this.ms);\n  return t.del = this.del, t.times = math.floor(mmax(e, 0)) || 1, t;\n};\n\nvar converToRadialIfOneRadial = function converToRadialIfOneRadial(e, t, n) {\n  var a = 0;\n  e.isRadial && !t.isRadial && (a += +t[0], t[0] = {\n    f1: 0,\n    f2: 0,\n    f3: 0,\n    f4: 0,\n    f5: 0,\n    f6: E\n  }, t.isRadial = !0), n || converToRadialIfOneRadial(t, e, !0);\n};\n\nfunction colorNormalizer(e, t, n) {\n  'use strict';\n\n  function a(e) {\n    var t,\n        a = 0,\n        r = 0,\n        o = 0,\n        s = [],\n        l = {},\n        d = 0,\n        p = 0,\n        c = 0,\n        g = 0,\n        h = 0,\n        u = 0,\n        m = {\n      f1: .5,\n      f2: .5\n    };\n\n    for (1 === e.length && (e[0] === NONE && (e[0] = 'rgba(0,0,0,0)'), e.unshift(0), e.defaultAngleSet = !0), isNaN(e[0]) ? ~'rx'.indexOf(e[0].charAt(0)) ? (e.isRadial = !0, g = 1, -1 !== e[0].indexOf(')') && (g = e[0].indexOf(')'), h = e[0].indexOf('(') + 1, u = g, s = e[0].substr(h, u - h).split(','), m.f1 = parseFloat(s[0]) || 0, m.f2 = parseFloat(s[1]) || 0, ~s[2].indexOf('%') && (s[2] = parseFloat(s[2]) / 100), m.f3 = parseFloat(s[2]) || 0, m.f4 = parseFloat(s[3]) || 0, m.f5 = parseFloat(s[4]) || 0, m.f6 = s[5]), e[0] = e[0].substr(u + 1), e.unshift(m)) : e[0] = 0 : e[0] = +e[0], (a = 1, r = e.length); a < r; ++a) {\n      s = e[a].split(':'), l = n(s[0]), e[a] = {}, e[a].r = l.r, e[a].g = l.g, e[a].b = l.b, e[a].opacity = l.opacity, e[a].opacity = +e[a].opacity, isNaN(e[a].opacity) && (e[a].opacity = 1), e[a].position = +s[1];\n    }\n\n    if (e.sort(function (e, t) {\n      return 'number' == typeof e || e.f1 ? -1 : 'number' == typeof t || e.f2 ? 1 : isNaN(e.position) && isNaN(t.position) ? 0 : isNaN(e.position) ? -1 : isNaN(t.position) ? 1 : e.position - t.position;\n    }), 0 != +e[1].position) if (isNaN(e[1].position)) e[1].position = 0;else {\n      for (t in l = {}, e[1]) {\n        l[t] = e[1][t];\n      }\n\n      for (l.position = 0, e.push({}), a = e.length - 1; 1 != a; --a) {\n        e[a] = e[a - 1];\n      }\n\n      e[1] = l;\n    }\n    if (r = e.length - 1, 100 !== e[r].position) if (isNaN(e[r].position)) e[r].position = 100;else {\n      for (t in l = {}, e[r]) {\n        l[t] = e[r][t];\n      }\n\n      l.position = 100, e.push(l);\n    }\n\n    for (a = 2, r = e.length; a < r; ++a) {\n      if (!e[a].position) {\n        for (d = e[a - 1].position, c = 1, o = a + 1; o < r; ++o) {\n          if (++c, !isNaN(e[o].position)) {\n            p = +e[o].position;\n            break;\n          }\n        }\n\n        e[a].position = d + (p - d) / c;\n      }\n    }\n\n    return e.getColorAtPosition = function (e) {\n      for (var t = -1, n = this.length, a = 1, r = this.length, o = 0, s = E, l = {\n        r: 0,\n        g: 0,\n        b: 0\n      }; a < r - 1; ++a) {\n        if (this[a].position <= e && (t = a, n = a + 1), !(this[a].position < e) && this[a].position >= e) {\n          n = a;\n          break;\n        }\n      }\n\n      for (s in o = (e - this[t].position) / (this[n].position - this[t].position), isNaN(o) && (o = 0), l) {\n        l[s] = upto255((1 - o) * this[t][s] + o * this[n][s]);\n      }\n\n      return l.position = e, l.opacity = (1 - o) * this[t].opacity + o * this[n].opacity, l;\n    }, e;\n  }\n\n  var r,\n      o,\n      s = 0,\n      l = 0,\n      d = [],\n      p = [],\n      c = {},\n      g = 0,\n      h = [];\n  if (e = e.constructor === Array ? e[0] : e, t = t.constructor === Array ? t[0] : t, r = e.split('-'), o = t.split('-'), 1 === r.length && 1 === o.length) return [e, t];\n\n  for (r = a(r), o = a(o), !r.defaultAngleSet && o.defaultAngleSet && (o[0] = r[0]), !o.defaultAngleSet && r.defaultAngleSet && (r[0] = o[0]), converToRadialIfOneRadial(r, o), (s = 1, l = r.length); s < l; ++s) {\n    g = r[s].position, h.push(g);\n  }\n\n  for (s = 1, l = o.length; s < l; ++s) {\n    g = o[s].position, -1 === h.indexOf(g) && h.push(g);\n  }\n\n  for (h.push(0), h.sort(function (e, t) {\n    return e - t;\n  }), d = [r[0]], (s = 1, l = h.length); s < l; ++s) {\n    g = h[s], c = r.getColorAtPosition(g), d.push(c);\n  }\n\n  for (p = [o[0]], s = 1, l = h.length; s < l; ++s) {\n    g = h[s], c = o.getColorAtPosition(g), p.push(c);\n  }\n\n  return d.isRadial = r.isRadial, p.isRadial = o.isRadial, [d, p];\n}\n\nfunction pathNormalizer(e, t) {\n  'use strict';\n\n  function n(e) {\n    var t = [],\n        n = 0,\n        a = e.length;\n    if (typeof e == STRING) return e;\n\n    for (n = 0; n < a; ++n) {\n      if (!e[n].join) return;\n      n && e[n + 1] && 'M' === e[n + 1][0] && 'M' === e[n][0] || t.push(e[n].join(S));\n    }\n\n    for (t = t.join(E), t = t.split(/[Mm]/).slice(1), (n = 0, a = t.length); n < a; ++n) {\n      t[n] = 'M' + t[n];\n    }\n\n    return t;\n  }\n\n  function a(e) {\n    var t = 0,\n        n = 0,\n        a = [];\n\n    for (e = e || [], n = e.length, t = 0; t < n; ++t) {\n      e[t].length - 1 && a.push(e[t].join(S));\n    }\n\n    return a.join(E);\n  }\n\n  function r(e, t) {\n    for (var n = e.length; n-- - 1 && e[n].slice(1).toString() === e[n - 1].slice(1).toString();) {\n      e.pop();\n    }\n\n    1 === e.length && t && (e.length = 0);\n  }\n\n  function o(e, t) {\n    for (var n = [], a = [], r = e.length, o = 0, s = 0, l = 0, d = 0, c = 0, g = t - r; 0 <= g;) {\n      o = e.length - 1, e.push(e.slice(o)[0]), --g;\n    }\n\n    for (r = e.length, o = 0; o <= t; ++o) {\n      a.push(p(o / t * r));\n    }\n\n    for (o = 0, s = a.length - 1; o < s; ++o) {\n      n.push(e.slice(a[o], a[o + 1])), 'M' !== n[o][0][0] && n[o][0][0] !== mStr && (d = n[o - 1].length - 1, l = n[o - 1][d][1], c = n[o - 1][d][2], n[o].unshift(['M', l, c]));\n    }\n\n    return n;\n  }\n\n  function s(e) {\n    var t = [],\n        n = [],\n        a = [],\n        r = 0,\n        s = 0,\n        l = !0;\n\n    if (0 !== e) {\n      for (0 < e ? (t = u, l = !1) : (e = -e, t = h), r = 0, s = t.length; r < s; ++r) {\n        n.push(1);\n      }\n\n      for (; e--;) {\n        --r, 0 > r && (r = s - 1), n[r]++;\n      }\n\n      for (r = 0; r < s; ++r) {\n        1 === n[r] ? a.push(t[r]) : a.push.apply(a, o(t[r], n[r]));\n      }\n\n      l ? h = a : u = a;\n    }\n  }\n\n  var l,\n      d = Math.max,\n      p = Math.round,\n      c = [],\n      g = [],\n      h = n(e),\n      u = n(t),\n      m = 0,\n      f = 0,\n      y = document.createElementNS && document.createElementNS.bind(document),\n      x = y && y('http://www.w3.org/2000/svg', 'path');\n  if (!h || !u || !x) return [e, t];\n  if (function (e, t) {\n    function n(e) {\n      for (var t = e.length; t-- - 1 && e[t].join(E) === e[t - 1].join(E);) {\n        e.pop();\n      }\n    }\n\n    function a(e) {\n      for (var t = E, n = 0, a = e.length; n < a; ++n) {\n        t += e[n].join(S);\n      }\n\n      return t;\n    }\n\n    var i,\n        r,\n        o = E,\n        s = E;\n    return (x.setAttribute('d', 'M300 10 L300 300 C50 310,50 640,350 650C600 640,600 310,400 300 L400 10 L295 10'), i = x.getTotalLength(), r = x.getPointAtLength(10), !!(1829.1 > i || 1829.2 < i)) || 300 !== p(r.x) || 20 !== p(r.y) || (n(e), n(t), o = a(e), s = a(t), !(2 < o.split(/[Mm]/).length || 2 < s.split(/[Mm]/).length) && e.length === t.length);\n  }(e, t)) return [e, t];\n  if (!e || !t) return [e, t];\n  if (!document.createElementNS) return [e, t];\n  if (h = n(e), u = n(t), -1 !== h.join().indexOf('undefined')) return [e, t];\n  if (-1 !== u.join().indexOf('undefined')) return [e, t];\n  if (!x.getTotalLength || !x.getPointAtLength) return [e, t];\n\n  for (f = d(h.length, u.length), m = 0; m < f; ++m) {\n    l = _pathNormalizer(h[m], u[m]), h[m] = l[0], u[m] = l[1];\n  }\n\n  for (m = h.length; m--;) {\n    r(h[m], m), h[m].length || h.pop();\n  }\n\n  for (m = u.length; m--;) {\n    r(u[m], m), u[m].length || u.pop();\n  }\n\n  for (s(h.length - u.length), f = d(h.length, u.length), m = 0; m < f; ++m) {\n    l = _pathNormalizer(a(h[m]), a(u[m])), h[m] = l[0], u[m] = l[1];\n  }\n\n  for (m = 0, f = h.length; m < f; ++m) {\n    c = c.concat(h[m]);\n  }\n\n  for (m = 0, f = u.length; m < f; ++m) {\n    g = g.concat(u[m]);\n  }\n\n  return [c, g];\n}\n\nfunction commonPathCalculator(e, t) {\n  'use strict';\n\n  function n(e) {\n    var t = 0,\n        n = 0;\n\n    for (e = e.split(/[MCLmcl]/).slice(1), t = 0, n = e.length; t < n; ++t) {\n      e[t] = e[t].split(S).slice(1), t || e[t].unshift('M'), t && (2 === e[t].length && e[t].unshift(strL) || e[t].unshift('C'));\n    }\n\n    return e;\n  }\n\n  function a(e, t) {\n    var n,\n        a,\n        r = 0,\n        o = e.length;\n\n    for (r = 0, o = e.length; r < o; ++r) {\n      n = e[r].join(S), a = e[r], 'C' === a[0] && a[3] === a[5] && a[4] === a[6] ? e[r].stringValue = [strL, a[3], a[4]].join(S) : a.stringValue = n, t[a.stringValue] && t[a.stringValue].push(r), t[a.stringValue] || (t[a.stringValue] = [r]);\n    }\n  }\n\n  function r(e, t, n, a, r) {\n    for (var o, s = n, l = 0, d = 0; s < a; ++s) {\n      if (o = t[e[s].stringValue], o) for (l = 0, d = o.length; l < d; ++l) {\n        if (o[l] >= r) return {\n          index: s,\n          mapValue: o[l],\n          diff: s - n\n        };\n      }\n    }\n\n    return -1;\n  }\n\n  function o(e) {\n    var t = e.length - 1;\n    return ['M', e[t - 1], e[t]].join(S);\n  }\n\n  function s(e) {\n    return e.join(E);\n  }\n\n  var l,\n      d,\n      p = 0,\n      c = 0,\n      g = 0,\n      h = 0,\n      u = 0,\n      m = 0,\n      f = {},\n      y = {},\n      x = [],\n      b = [],\n      v = -1,\n      _ = -1,\n      A = !0;\n\n  for (e = n(e), t = n(t), a(e, f), a(t, y), g = e.length, h = t.length, p = 0, c = 0; p < g && c < h;) {\n    if (++v, ++_, x[v] = [], b[_] = [], A = e[p].stringValue === t[c].stringValue, p && (x[v].push(o(e[p - 1])), b[_].push(o(t[c - 1]))), A) for (; p < g && c < h && e[p].stringValue === t[c].stringValue;) {\n      x[v].push(e[p].stringValue), b[_].push(t[c].stringValue), ++p, ++c;\n    } else {\n      for (l = r(e, y, p, g, c), d = r(t, f, c, h, p), u = l.index, m = l.mapValue, (!~l || l.diff > d.diff) && (u = d.mapValue, m = d.index), ~l || ~d || (u = g - 1, m = h - 1); p <= u;) {\n        x[v].push(e[p].stringValue), ++p;\n      }\n\n      for (; c <= m;) {\n        b[_].push(t[c].stringValue), ++c;\n      }\n    }\n    x[v] = s(x[v]), b[_] = s(b[_]);\n  }\n\n  if (p < g) {\n    for (++v, x[v] = [], x[v].push(o(e[p - 1])), ++_, b[_] = [], b[_].push(o(t[c - 1])); p < g;) {\n      x[v].push(e[p].stringValue), ++p;\n    }\n\n    x[v] = s(x[v]);\n  }\n\n  if (c < h) {\n    for (++v, x[v] = [], x[v].push(o(e[p - 1])), ++_, b[_] = [], b[_].push(o(t[c - 1])); c < h;) {\n      b[_].push(t[c].stringValue), ++c;\n    }\n\n    b[_] = s(b[_]);\n  }\n\n  return [x, b];\n}\n\nfunction _pathNormalizer(e, t) {\n  'use strict';\n\n  function n(e, t) {\n    var n,\n        a,\n        r = 0,\n        o = {},\n        s = 0,\n        l = 0,\n        d = [],\n        p = [],\n        c = 0,\n        g = Math.round;\n\n    for (n = document.createElementNS('http://www.w3.org/2000/svg', 'path'), n.setAttribute('d', e), a = document.createElementNS('http://www.w3.org/2000/svg', 'path'), a.setAttribute('d', t), s = n.getTotalLength(), l = a.getTotalLength(), c = .15 * Math.max(s, l), c = Math.ceil(c), c && isFinite(c) && !(10 > c) || (c = 10), r = 0; r <= c; ++r) {\n      o = n.getPointAtLength(r / c * s), d.push([r ? strL : strM, g(o.x), g(o.y)]), o = a.getPointAtLength(r / c * l), p.push([r ? strL : strM, g(o.x), g(o.y)]);\n    }\n\n    return [d, p];\n  }\n\n  var a,\n      r,\n      o = 0,\n      s = 0,\n      l = [],\n      d = [];\n\n  for (e && 'M  ' !== e || (e = t.split(S).slice(0, 3).join(S).replace(/[LC]/, E)), t && 'M  ' !== t || (t = e.split(S).slice(0, 3).join(S).replace(/[LC]/, E)), a = commonPathCalculator(e, t), (o = 0, s = a[0].length); o < s; ++o) {\n    r = n(a[0][o], a[1][o]), o ? (l = l.concat(r[0].slice(1)), d = d.concat(r[1].slice(1))) : (l = l.concat(r[0]), d = d.concat(r[1]));\n  }\n\n  return [l, d];\n}\n\nfunction runAnimation(t, n, a, r, o, s, l, d) {\n  a = toFloat(a);\n  var p,\n      c,\n      g,\n      h,\n      u,\n      f,\n      y,\n      x,\n      b = t.ms,\n      v = {},\n      A = {},\n      k = {};\n\n  if (null !== n.type) {\n    if (d = d || {}, d.hookFn && d.hookFn.call(n), d.from = d.from || {}, r) for (T = 0, w = animationElements.length; T < w; T++) {\n      var C = animationElements[T];\n\n      if (C.el.id === n.id && C.anim === t) {\n        C.percent == a ? c = C : (delete C.el.e, delete C.el, animationElements.splice(T, 1), g = 1), n.attr(C.totalOrigin);\n        break;\n      }\n    } else r = +A;\n\n    for (var T = 0, w = t.percents.length; T < w; T++) {\n      if (t.percents[T] === a || t.percents[T] > r * t.top) {\n        a = t.percents[T], u = t.percents[T - 1] || 0, b = b / t.top * (a - u), h = t.percents[T + 1], p = t.anim[a];\n        break;\n      } else r && n.attr(t.anim[t.percents[T]]);\n    }\n\n    if (p) {\n      if (!c) {\n        for (var S in p) {\n          if (p[HAS](S)) if (availableAnimAttrs[HAS](S) || n.ca[S]) {\n            switch (v[S] = d.from[S] || n.attr(S), null == v[S] && (v[S] = availableAttrs[S]), A[S] = p[S], x = !1, availableAnimAttrs[S]) {\n              case 'number':\n                y = A[S] - v[S], (y || isNaN(y)) && (x = !0), k[S] = y / b;\n                break;\n\n              case 'colour':\n                if (v[S] === A[S]) break;else x = !0;\n                var E = colorNormalizer(v[S], A[S], R.getRGB);\n                v[S] = E[0];\n                var P = E[1];\n                if (typeof P == STRING) v[S].toLowerCase() === NONE ? v[S] = {\n                  r: 0,\n                  g: 0,\n                  b: 0,\n                  opacity: 0\n                } : (v[S] = R.getRGB(v[S]), !v[S].opacity && (v[S].opacity = 1)), A[S].toLowerCase() === NONE ? P = {\n                  r: 0,\n                  g: 0,\n                  b: 0,\n                  opacity: 0\n                } : (P = R.getRGB(A[S]), !P.opacity && (P.opacity = 1)), k[S] = {\n                  r: (P.r - v[S].r) / b,\n                  g: (P.g - v[S].g) / b,\n                  b: (P.b - v[S].b) / b,\n                  opacity: (P.opacity - v[S].opacity) / b\n                };else for (k[S] = [], T = 0, w = v[S].length; T < w; ++T) {\n                  0 === T ? k[S].push(P[0]) : k[S].push({\n                    r: (P[T].r - v[S][T].r) / b,\n                    g: (P[T].g - v[S][T].g) / b,\n                    b: (P[T].b - v[S][T].b) / b,\n                    opacity: (P[T].opacity - v[S][T].opacity) / b\n                  });\n                }\n                break;\n\n              case 'path':\n                var I,\n                    L = path2curve(v[S], A[S]);\n\n                for (d.smartMorph && (L = pathNormalizer(L[0], L[1], d)), I = L[1], v[S] = L[0], k[S] = [], (T = 0, w = v[S].length); T < w; T++) {\n                  k[S][T] = [0];\n                  var F = v[S][T] ? v[S][T].length : 0;\n\n                  for (var O = 1; O < F; O++) {\n                    k[S][T][O] = (I[T][O] - v[S][T][O]) / b, !x && k[S][T][O] && (x = !0);\n                  }\n                }\n\n                break;\n\n              case 'transform':\n                var N = n._,\n                    _ = equaliseTransform(N[S], A[S]);\n\n                if (x = !0, _) for (v[S] = _.from, A[S] = _.to, k[S] = [], k[S].real = !0, (T = 0, w = v[S].length); T < w; T++) {\n                  for (k[S][T] = [v[S][T][0]], O = 1, F = v[S][T].length; O < F; O++) {\n                    k[S][T][O] = (A[S][T][O] - v[S][T][O]) / b;\n                  }\n                } else {\n                  var B = n.matrix || new Matrix(),\n                      m = {\n                    _: {\n                      transform: N.transform\n                    },\n                    getBBox: function getBBox() {\n                      return n.getBBox(1);\n                    }\n                  };\n                  v[S] = [B.a, B.b, B.c, B.d, B.e, B.f], extractTransform(m, A[S]), A[S] = m._.transform, k[S] = [(m.matrix.a - B.a) / b, (m.matrix.b - B.b) / b, (m.matrix.c - B.c) / b, (m.matrix.d - B.d) / b, (m.matrix.e - B.e) / b, (m.matrix.f - B.f) / b];\n                }\n                break;\n\n              case 'csv':\n                var D = Str(p[S])[SPLIT](separator),\n                    M = Str(v[S])[SPLIT](separator);\n                if ('clip-rect' === S) for (v[S] = M, k[S] = [], T = M.length; T--;) {\n                  y = D[T] - v[S][T], (y || isNaN(y)) && (x = !0), k[S][T] = y / b;\n                }\n                A[S] = D;\n                break;\n\n              default:\n                for (D = [][CONCAT](p[S]), M = [][CONCAT](v[S]), k[S] = [], T = n.ca[S].length; T--;) {\n                  y = (D[T] || 0) - (M[T] || 0), (y || isNaN(y)) && (x = !0), k[S][T] = y / b;\n                }\n\n            }\n\n            x || (delete v[S], delete A[S], delete p[S], delete k[S]);\n          } else (R._availableAttrs[HAS](S) || 'text' === S || n.ca[S]) && (n.attr(S, p[S]), delete p[S]);\n        }\n\n        var V = p.easing,\n            Y = R.easing_formulas[V];\n        if (!Y) if (Y = Str(V).match(bezierrg), Y && 5 === Y.length) {\n          var q = Y;\n\n          Y = function Y(e) {\n            return CubicBezierAtTime(e, +q[1], +q[2], +q[3], +q[4], b);\n          };\n        } else Y = pipe;\n        if (f = p.start || t.start || +new Date(), n.e = C = {\n          anim: t,\n          percent: a,\n          timestamp: f,\n          start: f + (t.del || 0),\n          status: 0,\n          initstatus: r || 0,\n          stop: !1,\n          ms: b,\n          easing: Y,\n          from: v,\n          diff: k,\n          to: A,\n          el: n,\n          callback: p.callback,\n          prev: u,\n          next: h,\n          repeat: s || t.times,\n          origin: n.attr(),\n          totalOrigin: o,\n          parentEl: l,\n          delayend: d && d.end,\n          delaystart: d && d.start\n        }, animationElements.push(C), r && !c && !g && (C.stop = !0, C.start = new Date() - b * r, 1 === animationElements.length)) return animation();\n        g && (C.start = new Date() - C.ms * r), 1 === animationElements.length && (requestAnimFrame || R.getAnimFrameFn())(animation);\n      } else c.initstatus = r, c.start = new Date() - c.ms * r;\n\n      eve('raphael.anim.start.' + n.id, n, t);\n    }\n  }\n}\n\nR.animation = function (e, t, n, a, i) {\n  if (e instanceof Animation) return e;\n  (R.is(n, FUNCTION) || !n) && (a = a || n || null, n = null), R.stopPartialEventPropagation || (R.stopPartialEventPropagation = i), e = Object(e), t = +t || 0;\n  var r,\n      o,\n      s = {};\n\n  for (o in e) {\n    e[HAS](o) && toFloat(o) != o && toFloat(o) + '%' != o && (r = !0, s[o] = e[o]);\n  }\n\n  return a && (r = !0), r ? (n && (s.easing = n), a && (s.callback = a), new Animation({\n    100: s\n  }, t)) : new Animation(e, t);\n}, elproto.animate = function (e, t, n, a) {\n  var i = this;\n  if (i.removed) return a && a.call(i), i;\n  var r = e instanceof Animation ? e : R.animation(e, t, n, a);\n  return runAnimation(r, i, r.percents[0], null, i.attr()), i;\n}, elproto.status = function (t, n) {\n  var a,\n      r,\n      o = [],\n      s = 0;\n  if (null != n) return runAnimation(t, this, -1, mmin(n, 1)), this;\n\n  for (a = animationElements.length; s < a; s++) {\n    if (r = animationElements[s], r.el.id === this.id && (!t || r.anim === t)) {\n      if (t) return r.status;\n      o.push({\n        anim: r.anim,\n        status: r.status\n      });\n    }\n  }\n\n  return t ? 0 : o;\n}, elproto.pause = function (t, n) {\n  var a,\n      r,\n      o = +new Date();\n\n  for (r = 0; r < animationElements.length; r++) {\n    a = animationElements[r], (a.el.id === this.id || n && a.parentEl && a.parentEl.e.el && a.parentEl.e.el.id === this.id) && (!t || a.anim === t) && !1 !== eve('raphael.anim.pause.' + this.id, this, a.anim) && (a.paused = !0, a.pauseStart = o);\n  }\n\n  return this;\n}, elproto.resume = function (t, n) {\n  var a,\n      r,\n      o = +new Date();\n\n  for (r = 0; r < animationElements.length; r++) {\n    a = animationElements[r], (a.el.id === this.id || n && a.parentEl && a.parentEl.e.el && a.parentEl.e.el.id === this.id) && (!t || a.anim === t) && !1 !== eve('raphael.anim.resume.' + this.id, this, a.anim) && (delete a.paused, a.el.status(a.anim, a.status), a.pauseEnd = o, a.start += (a.parentEl && a.parentEl.e.pauseEnd || a.pauseEnd) - (a.parentEl && a.parentEl.e.pauseStart || a.pauseStart) || 0);\n  }\n\n  return this;\n}, elproto.stop = function (t, n, a) {\n  var r, o, s;\n  if (n) for (o = animationElements.length - 1; 0 <= o; o--) {\n    r = animationElements[o], (r.el.id === this.id || r.parentEl && r.parentEl.id === this.id) && (!t || animationElements[o].anim === t) && (s = r.el, a && s.attr(r.to), r.callback && r.callback.call(s), delete s.e, delete r.el, animationElements.splice(o, 1));\n  } else for (var o = 0; o < animationElements.length; o++) {\n    r = animationElements[o], r.el.id !== this.id || t && r.anim !== t || !1 === eve('raphael.anim.stop.' + this.id, this, r.anim) || animationElements.splice(o--, 1);\n  }\n  return this.animElements && executeAnimQueue(this.animElements), this;\n};\n\nfunction executeAnimQueue(e) {\n  for (var t; t = e.deq();) {\n    t = t.executeOb, t.hookFn && t.hookFn.call(t.el), t.el.attr(t.attrs), t.callback && t.callback.call(t.el);\n  }\n}\n\nfunction stopAnimation(e) {\n  for (var t = 0; t < animationElements.length; t++) {\n    animationElements[t].el.paper === e && animationElements.splice(t--, 1);\n  }\n}\n\neve.on('raphael.remove', stopAnimation), eve.on('raphael.clear', stopAnimation), elproto.toString = function () {\n  return \"Rapha\\xEBl\\u2019s object\";\n}, elproto.toFront = function () {\n  if (this.removed) return this;\n\n  var e,\n      t,\n      n,\n      a = this,\n      r = R._engine.getNode(a),\n      o = a.parent,\n      s = a.followers;\n\n  for (R._tofront(a, o) && o.canvas.appendChild(r), t = 0, n = s.length; t < n; t++) {\n    (e = s[t]).stalk && e.el[e.stalk](a);\n  }\n\n  return a;\n}, elproto.toBack = function () {\n  if (this.removed) return this;\n\n  var e,\n      t,\n      n,\n      a = this,\n      r = R._engine.getNode(a),\n      o = a.parent,\n      s = a.followers;\n\n  for (R._toback(a, o) && o.canvas.insertBefore(r, o.canvas.firstChild), t = 0, n = s.length; t < n; t++) {\n    (e = s[t]).stalk && e.el[e.stalk](a);\n  }\n\n  return a;\n}, elproto.insertAfter = function (e) {\n  if (this.removed) return this;\n\n  var t,\n      n,\n      a,\n      r = this,\n      o = R._engine.getNode(r),\n      s = R._engine.getLastNode(e),\n      l = e.parent.canvas,\n      d = r.followers;\n\n  for (s.nextSibling ? l.insertBefore(o, s.nextSibling) : l.appendChild(o), R._insertafter(r, e, r.parent, e.parent), (n = 0, a = d.length); n < a; n++) {\n    (t = d[n]).stalk && t.el[t.stalk](e);\n  }\n\n  return r;\n}, elproto.insertBefore = function (e) {\n  if (this.removed) return this;\n\n  var t,\n      n,\n      a,\n      r = this,\n      o = R._engine.getNode(r),\n      s = R._engine.getNode(e),\n      l = r.followers;\n\n  for (e.parent.canvas.insertBefore(o, s), R._insertbefore(r, e, r.parent, e.parent), r.parent = e.parent, (n = 0, a = l.length); n < a; n++) {\n    (t = l[n]).stalk && t.el[t.stalk](e);\n  }\n\n  return this;\n}, elproto.appendChild = function (e) {\n  if (this.removed || 'group' !== this.type) return this;\n  var t,\n      n,\n      a,\n      r,\n      o = this,\n      s = o.followers;\n  if (e.parent === o) return e.toFront(), o;\n\n  for (n = R._engine.getNode(e), R._tear(e, e.parent), o.canvas.appendChild(n), e.parent = o, o.bottom || (o.bottom = e), e.prev = o.top, e.next = null, o.top && (o.top.next = e), o.top = e, (a = 0, r = s.length); a < r; a++) {\n    (t = s[a]).stalk && t.el[t.stalk](e);\n  }\n\n  return o;\n}, elproto.appendTo = function (e) {\n  return e.appendChild(this);\n}, elproto.removeChild = function (e) {\n  if (this.removed || 'group' !== this.type || e.parent !== this) return this;\n\n  var t = this,\n      n = R._engine.getNode(e),\n      a = t.paper;\n\n  return R._tear(e, t), a.canvas.appendChild(n), t.parent = a, a.bottom || (a.bottom = t), t.prev = a.top, a.top && (a.top.next = t), a.top = t, t.next = null, t;\n}, R.format = function (e, t) {\n  var n = getArrayCopy(arguments),\n      a = R.is(t, ARRAY) ? [0][CONCAT](t) : n;\n  return e && R.is(e, STRING) && a.length - 1 && (e = e.replace(formatrg, function (e, t) {\n    return null == a[++t] ? E : a[t];\n  })), e || E;\n};\nvar crispFixer = R.vml && .5 || 0;\nR.crispBound = cacher(function (e, t, n, a, i) {\n  var r,\n      o = {};\n  return e = e || 0, t = t || 0, n = n || 0, a = a || 0, i = i || 0, r = i % 2 / 2 + crispFixer, o.x = round(e + r) - r, o.y = round(t + r) - r, o.width = round(e + n + r) - r - o.x, o.height = round(t + a + r) - r - o.y, o['stroke-width'] = i, 0 === o.width && 0 !== n && (o.width = 1), 0 === o.height && 0 !== a && (o.height = 1), o;\n}, R), elproto.crisp = function () {\n  var e,\n      t = this,\n      n = t.attrs,\n      a = t.attr();\n\n  for (e in a = R.crispBound(a.x, a.y, a.width, a.height, a['stroke-width']), a) {\n    n[e] === a[e] && delete a[e];\n  }\n\n  return t.attr(a);\n}, R.define = function (t, n, a, r, o, e) {\n  var s, l;\n\n  if (R.is(t, ARRAY)) {\n    for (s = 0, l = t.length; s < l; s++) {\n      R.define(t[s]);\n    }\n\n    return;\n  }\n\n  return R.is(t, OBJECT) ? void R.define(t.name, t[t.name], t.ca, t.fn, t.e, t.data) : !t || R.fn[t] ? void 0 : (R.fn[t] = function () {\n    var e,\n        i = getArrayCopy(arguments),\n        s = n.apply(this, i);\n    if (r && R.is(r, OBJECT)) for (e in r) {\n      s[e] = r[e];\n    }\n    if (o && R.is(o, OBJECT)) for (e in o) {\n      s[e] && s[e](o[e]);\n    }\n\n    if (a) {\n      if (R.is(a, FUNCTION)) s.ca[t] = a;else for (e in a) {\n        s.ca[e] = a[e];\n      }\n      s.ca[t] && (R._lastArgIfGroup(i, !0), i.length && (i[0][t] ? s.attr.apply(s, i) : s.attr(t, i[0])));\n    }\n\n    return s;\n  }, a && (R.fn[t].ca = a), r && (R.fn[t].fn = r), o && (R.fn[t].e = o), e && (R.fn[t].data = e), R.fn[t]);\n}, function (e, t, _n) {\n  function a() {\n    /in/.test(e.readyState) ? setTimeout(a, 9) : R.eve('raphael.DOMload');\n  }\n\n  null == e.readyState && e.addEventListener && (e.addEventListener(t, _n = function n() {\n    e.removeEventListener(t, _n, !1), e.readyState = 'complete';\n  }, !1), e.readyState = 'loading'), a();\n}(doc, 'DOMContentLoaded'), eve.on('raphael.DOMload', function () {\n  loaded = !0;\n}), R._preload = function (e, t) {\n  var n = g.doc,\n      a = n.createElement('img');\n  a.style.cssText = 'position:absolute;left:-9999em;top:-9999em', a.onload = function () {\n    t.call(this), this.onload = null, n.body.removeChild(this);\n  }, a.onerror = function () {\n    n.body.removeChild(this);\n  }, n.body.appendChild(a), a.src = e;\n};\nexport default R;","map":null,"metadata":{},"sourceType":"module"}