{"ast":null,"code":"import { pluckNumber } from '../../../fc-core/src/lib';\n\nvar UNDEF = void 0,\n    UNDERSCORE = '_',\n    DEFAULT_MACRO_PREFIX = '$',\n    DEFAULT_MACRO_SEPARATOR = '.',\n    pi2 = 2 * Math.PI,\n    threshold = 1e-5,\n    axis2d = [-pi2, -3 * pi2 / 4, -pi2 / 2, -pi2 / 4, 0],\n    axis3d = [pi2, 3 * pi2 / 4, pi2 / 2, pi2 / 4, 0],\n    square = function square(a) {\n  return a * a;\n},\n    deg2Rad = function deg2Rad(a) {\n  return a * (Math.PI / 180);\n},\n    polarToCartesian = function polarToCartesian(a, b) {\n  var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n  var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var e, f;\n  return c || (b = deg2Rad(b)), e = a * Math.cos(b) + (d.x || 0), f = a * Math.sin(b) + (d.y || 0), {\n    x: e,\n    y: f\n  };\n},\n    getQuadrant = function getQuadrant(a, b, c) {\n  return a.x >= b ? a.y <= c ? 0 : 3 : a.y <= c ? 1 : 2;\n},\n    getEllipseRadius = function getEllipseRadius(c, a, b) {\n  var d,\n      e = square(c),\n      f = square(a);\n  return 0 === c || 0 === a ? 0 : (d = c * a / Math.sqrt(f * square(Math.cos(b)) + e * square(Math.sin(b))), d);\n},\n    computeSlice2DBBox = function computeSlice2DBBox(a) {\n  var b = Math.abs,\n      c = Math.min,\n      d = Math.max;\n  var e,\n      f,\n      g,\n      h,\n      j,\n      k,\n      l,\n      m,\n      n,\n      o = a.ringpath,\n      p = [],\n      q = [],\n      r = 1 / 0,\n      s = 1 / 0,\n      t = -Infinity,\n      u = -Infinity;\n\n  for (e = pluckNumber(o[2]), f = pluckNumber(o[3]), g = pluckNumber(o[4]) % pi2, h = pluckNumber(o[5]) % pi2, j = pluckNumber(o[0]), k = pluckNumber(o[1]), m = polarToCartesian(e, g, !0, {\n    x: j,\n    y: k\n  }), n = polarToCartesian(e, h, !0, {\n    x: j,\n    y: k\n  }), q.push(m), q.push(n), l = 0; l < axis2d.length; l++) {\n    axis2d[l] >= g && axis2d[l] <= h && p.push(l);\n  }\n\n  for (l = 0; l < p.length; l++) {\n    m = polarToCartesian(e, axis2d[p[l]], !0, {\n      x: j,\n      y: k\n    }), n = polarToCartesian(f, axis2d[p[l]], !0, {\n      x: j,\n      y: k\n    }), q.push(m), q.push(n);\n  }\n\n  for (m = polarToCartesian(f, g, !0, {\n    x: j,\n    y: k\n  }), n = polarToCartesian(f, h, !0, {\n    x: j,\n    y: k\n  }), q.push(m), q.push(n), l = 0; l < q.length; l++) {\n    t = d(t, q[l].x), r = c(r, q[l].x), u = d(u, q[l].y), s = c(s, q[l].y);\n  }\n\n  return {\n    x: r,\n    y: s,\n    width: b(t - r),\n    height: b(s - u)\n  };\n},\n    computeSlice3DBBox = function computeSlice3DBBox(a) {\n  var b = Math.abs,\n      c = Math.min,\n      d = Math.max;\n  var e,\n      f,\n      g,\n      h,\n      j,\n      k,\n      l,\n      m,\n      n,\n      o = [],\n      p = [],\n      q = 1 / 0,\n      r = 1 / 0,\n      s = -Infinity,\n      t = -Infinity;\n  e = pluckNumber(a.r), f = pluckNumber(e * a.radiusYFactor), g = pluckNumber(a.sAngle) % pi2, h = pluckNumber(a.eAngle) % pi2, j = pluckNumber(a.cx), k = pluckNumber(a.cy), m = polarToCartesian(getEllipseRadius(e, f, g), g, !0, {\n    x: j,\n    y: k\n  }), n = polarToCartesian(getEllipseRadius(e, f, h), h, !0, {\n    x: j,\n    y: k\n  }), p.push(m), p.push(n);\n\n  for (var _b = 0; _b < axis3d.length; _b++) {\n    axis3d[_b] >= g && axis3d[_b] <= h && o.push(_b);\n  }\n\n  for (l = 0; l < o.length; l++) {\n    m = polarToCartesian(getEllipseRadius(e, f, axis3d[o[l]]), axis3d[o[l]], !0, {\n      x: j,\n      y: k\n    }), p.push(m);\n  }\n\n  for (e = pluckNumber(a.innerR, 0), f = pluckNumber(e * a.radiusYFactor, 0), m = polarToCartesian(getEllipseRadius(e, f, g), g, !0, {\n    x: j,\n    y: k\n  }), n = polarToCartesian(getEllipseRadius(e, f, h), h, !0, {\n    x: j,\n    y: k\n  }), p.push(m), p.push(n), l = 0; l < o.length; l++) {\n    m = polarToCartesian(getEllipseRadius(e, f, axis3d[o[l]]), axis3d[o[l]], !0, {\n      x: j,\n      y: k\n    }), p.push(m);\n  }\n\n  for (var _b2 = 0; _b2 < p.length; _b2++) {\n    s = d(s, p[_b2].x), q = c(q, p[_b2].x), t = d(t, p[_b2].y), r = c(r, p[_b2].y);\n  }\n\n  return {\n    x: q,\n    y: r,\n    width: b(s - q),\n    height: b(r - t)\n  };\n},\n    getEllipticalPoint = function getEllipticalPoint(c, a, b) {\n  var d = Math.abs,\n      e = Math.sqrt;\n  var f, g, h;\n  return h = Math.tan(b), f = c * a / e(a * a + c * c * h * h), g = c * a / e(c * c + a * a / (h * h)), b > pi2 / 4 && b < 3 * pi2 / 4 ? f *= -1 : f = d(f), b > pi2 / 2 && b < pi2 ? g *= -1 : g = d(g), d(f) <= threshold && (f = 0), d(g) <= threshold && (g = 0), {\n    x: f,\n    y: g\n  };\n},\n    compute3DSliceBounds = function compute3DSliceBounds(c, d) {\n  var e,\n      f,\n      g = d.props.element.attr,\n      h = g.radiusYFactor,\n      i = g.r,\n      a = i * h,\n      b = g.cx,\n      j = g.cy,\n      k = g.sAngle,\n      l = g.eAngle;\n  return 'slicex' === c || 'slicemiddlex' === c || 'slicecenterx' === c ? (e = (k + l) / 2, f = getEllipticalPoint(i, a, e).x + b) : 'slicey' === c || 'slicemiddley' === c || 'slicecentery' === c ? (e = (k + l) / 2, f = getEllipticalPoint(i, a, e).y + j) : 'slicestartx' === c ? f = getEllipticalPoint(i, a, k).x + b : 'slicestarty' === c ? f = getEllipticalPoint(i, a, k).y + j : 'sliceendx' === c ? f = getEllipticalPoint(i, a, l).x + b : 'sliceendy' === c ? f = getEllipticalPoint(i, a, l).y + j : f = xyCalculator(c, computeSlice3DBBox(g)), f;\n},\n    computeSliceBounds = function computeSliceBounds(a, b) {\n  var c,\n      d,\n      e,\n      f,\n      g,\n      h,\n      i,\n      j,\n      k = b.props.element.attr,\n      l = k.ringpath;\n  return d = l[0], e = l[1], f = l[2], h = l[4], i = l[5], ('slicex' === a || 'slicemiddlex' === a || 'slicecenterx' === a ? (j = (h + i) / 2, c = polarToCartesian(f, j), g = c.x + d) : 'slicey' === a || 'slicemiddley' === a || 'slicecentery' === a ? (j = (h + i) / 2, c = polarToCartesian(f, j), g = c.y + e) : 'slicestartx' === a ? g = polarToCartesian(f, i).x + d : 'slicestarty' === a ? g = polarToCartesian(f, i).y + e : 'sliceendx' === a ? g = polarToCartesian(f, h).x + d : 'sliceendy' === a ? g = polarToCartesian(f, h).y + e : g = xyCalculator(a, computeSlice2DBBox(k)), g);\n},\n    computePlotBounds = function computePlotBounds(a, b) {\n  var c,\n      d,\n      e,\n      f,\n      g,\n      h = a.config || a;\n  return 'column3D' === b || 'bar2D' === b || 'bar3D' === b || 'paretoColumn' === b || 'waterFall2D' === b || 'errorBar2D' === b || 'candlestick' === b || 'heatMap' === b || 'dragColumn' === b || 'sparkColumn' === b || 'marimekko' === b || 'task' === b || 'column' === b ? (d = h.props.element.attr, c = {\n    x: d.x + pluckNumber(d.xDepth, 0),\n    y: d.y - pluckNumber(d.yDepth, 0),\n    width: d.width,\n    height: d.height\n  }) : 'line' === b || 'zoomLine' === b || 'zoomScatter' === b || 'scatter' === b || 'spline' === b || 'splinearea' === b || 'multiaxisline' === b || 'stepLine' === b || 'errorScatter' === b || 'errorLine' === b || 'radar' === b || 'selectScatter' === b || 'dragLine' === b || 'dragArea' === b || 'kagi' === b || 'sparkLine' === b || 'area' === b ? (e = a._xPos, f = a._yPos, g = +h.anchorProps.radius || 0, c = {\n    x: e - g,\n    y: f - g,\n    width: 2 * g,\n    height: 2 * g\n  }) : 'bubble' === b ? (d = h.props.element.attr, c = {\n    x: d.cx - d.r,\n    y: d.cy - d.r,\n    width: 2 * d.r,\n    height: 2 * d.r\n  }) : 'dragNode' === b ? (d = h.props.element.attr, 'rect' === h.shapeType ? c = {\n    x: d.x,\n    y: d.y,\n    width: d.width,\n    height: d.height\n  } : (e = h._xPos, f = h._yPos, g = +h.radius || 0, c = {\n    x: e - g,\n    y: f - g,\n    width: 2 * g,\n    height: 2 * g\n  })) : 'boxandwhisker2D' === b ? (d = h.props.upperBoxElem.attr, c = {\n    x: d.x,\n    y: d.y,\n    width: d.width,\n    height: d.height\n  }) : 'category' === b || 'polarCategory' === b || 'log' === b || 'numeric' === b ? (d = h.props.label.attr, c = {\n    x: d.x - h.width / 2,\n    y: d.y - h.height / 2,\n    width: h.width,\n    height: h.height\n  }, 'end' === d['text-anchor'] || 'left' === d['text-anchor'] ? c.x = d.x - h.width : ('start' === d['text-anchor'] || 'right' === d['text-anchor']) && (c.x = d.x), 'top' === d['vertical-align'] ? c.y = d.y : 'bottom' === d['vertical-align'] && (c.y = d.y - h.height)) : 'multiLevelPie' === b ? (d = h.props.element.attr, c = computeSlice2DBBox(d)) : void 0, c;\n},\n    cleanMacro = function cleanMacro(a) {\n  var b,\n      c,\n      d = '';\n\n  for (b = 0, c = a.length; b < c; b++) {\n    ' ' !== a[b] && (d += a[b]);\n  }\n\n  return d;\n},\n    arrangeItems = function arrangeItems() {\n  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var b,\n      c,\n      d = [],\n      e = [];\n\n  for (c = a.length, b = 0; b < c; b++) {\n    'text' === a[b].type ? e.push(a[b]) : d.push(a[b]);\n  }\n\n  return d.concat(e);\n},\n    xyCalculator = function xyCalculator(a, b) {\n  var c = 0;\n  return c = 'startx' === a ? b.x : 'starty' === a ? b.y : 'x' === a || 'middlex' === a || 'centerx' === a ? b.x + b.width / 2 : 'y' === a || 'middley' === a || 'centery' === a ? b.y + b.height / 2 : 'endx' === a ? b.x + b.width : 'endy' === a ? b.y + b.height : 0, c;\n},\n    axisMacroParser = function axisMacroParser(a, b) {\n  return function (c) {\n    var d,\n        e,\n        f,\n        g,\n        h = c.split(DEFAULT_MACRO_SEPARATOR).slice(1),\n        i = isNaN(+h[0]) ? 0 : +h[0],\n        j = isNaN(+h[0]) ? h[1] : h[2],\n        k = isNaN(+h[0]) ? h[2] : h[3];\n    return d = a.getChildren(b)[i], g = d.components, j = +j, g.labelIndexArr && (j = g.labelIndexArr[j]), e = g.labels[j].config, f = computePlotBounds(e, d.getName()), xyCalculator(k, f);\n  };\n},\n    getEventData = function getEventData(a, b, c) {\n  var d = b.getElement(),\n      e = c.getFromEnv('getMouseCoordinate')(c.getFromEnv('chart-container'), a, c),\n      f = b.getLinkedParent();\n  return {\n    element: d,\n    rawConfig: b.getAttribute(),\n    pageX: e.pageX,\n    pageY: e.pageY,\n    chartX: e.chartX,\n    chartY: e.chartY,\n    annotationId: b.getId(),\n    groupId: f && f.getId(),\n    annotationOptions: b.rawConfig,\n    groupOptions: f && f.rawConfig\n  };\n},\n    pluckBoolean = function pluckBoolean() {\n  var b, c, d;\n\n  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n    a[_key] = arguments[_key];\n  }\n\n  for (c = 0, d = a.length; c < d; c++) {\n    if (b = a[c], !0 === b || !1 === b) return b;\n  }\n\n  return !1;\n},\n    trim = function trim(a) {\n  return a.replace(/^\\s+|\\s+$/g, '');\n},\n    isMacro = function isMacro(a) {\n  return ~a.indexOf(DEFAULT_MACRO_PREFIX);\n},\n    solveEquation = function solveEquation(a) {\n  var b,\n      c,\n      d = +a[0],\n      e = 1,\n      f = a.length;\n\n  for (; e < f; ++e) {\n    c = a[e], e % 2 ? b = c : '+' === b ? d += +c : '-' === b ? d -= +c : void 0;\n  }\n\n  return d;\n},\n    getScaledVal = function getScaledVal(a, b) {\n  var c;\n\n  switch (b.axis) {\n    case 'x':\n    case 'toX':\n      c = b.scaleX;\n      break;\n\n    case 'y':\n    case 'toY':\n      c = b.scaleY;\n      break;\n\n    default:\n      c = b.scaleValue || 1;\n  }\n\n  return a * c;\n},\n    parseEquation = function parseEquation(a, b) {\n  var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n  var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_MACRO_PREFIX;\n  var e,\n      f,\n      g,\n      h,\n      k,\n      l,\n      m = a.split(/([+])/),\n      n = [],\n      o = m.length;\n\n  for (f = 0; f < o; f++) {\n    if (h = m[f], '+' !== h) {\n      for (h = m[f], e = h.split(/([-])/), (g = 0, l = e.length); g < l; g++) {\n        k = e[g], '-' !== k && (n.push(e[g]), g < l - 1 && n.push('-'));\n      }\n\n      f < o - 1 && n.push('+');\n    }\n  }\n\n  return n.map(function (a) {\n    var e,\n        f,\n        g,\n        h = '',\n        i = '',\n        j = '';\n\n    if (a.charAt(0) === d) {\n      if (i = a.replace(/[\\$ ]/g, ''), j = i.split(DEFAULT_MACRO_SEPARATOR)[0], !isNaN(+i)) return +i;\n\n      for (h in b) {\n        if (j === h) {\n          if (f = new RegExp(h, 'g'), 'function' == typeof b[h]) try {\n            e = j.replace(f, b[h](i));\n          } catch (a) {\n            e = j.replace(f, 0);\n          } else e = j.replace(f, b[h] || 0);\n          break;\n        }\n      }\n    } else g = +a, isNaN(g) ? '+' !== a && '-' !== a && (a = 0) : a = c ? getScaledVal(g, c).toString() : g.toString(), e = a;\n\n    return e;\n  });\n};\n\nexport { deg2Rad, polarToCartesian, getQuadrant, computePlotBounds, computeSliceBounds, compute3DSliceBounds, cleanMacro, arrangeItems, axisMacroParser, xyCalculator, UNDEF, UNDERSCORE, DEFAULT_MACRO_PREFIX, DEFAULT_MACRO_SEPARATOR, pluckBoolean, trim, isMacro, solveEquation, parseEquation, getScaledVal, getEventData };","map":null,"metadata":{},"sourceType":"module"}