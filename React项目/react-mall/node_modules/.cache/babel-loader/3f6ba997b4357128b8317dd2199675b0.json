{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { ComponentInterface } from '../component-interface';\nimport ColorBucket from './color-bucket';\nimport GradientColorRange from './gradient-color-range';\nimport { componentFactory, toRaphaelColor, isIE, pluckNumber, dehashify, pluck, getLightColor, getValidColor } from '../lib';\n\nfunction getOppositeColor(a) {\n  return getLightColor(a, 1);\n}\n\nfunction getValidHexColor(a) {\n  return getValidColor(a || DEF_COLOR) || DEF_COLOR;\n}\n\nvar UNDEF,\n    TRACKER_FILL = 'rgba(192,192,192,' + (isIE ? .002 : 1e-6) + ')',\n    PERCENT_STR = '%',\n    DEF_COLOR = '#000000',\n    legendManager = function () {\n  function a(a) {\n    var c,\n        d,\n        e,\n        f = b.getFromEnv('number-formatter');\n\n    for (c = 0, d = a.length; c < d; c++) {\n      (e = a[c].maxvalue, !!e) && (a[c].maxvalue = f.getCleanValue(e));\n    }\n  }\n\n  var b,\n      c = {};\n  return c.legendCarpetConf = {\n    spreadFactor: .85,\n    allowDrag: !1,\n    captionAlignment: 'center',\n    padding: {\n      v: 3,\n      h: 3\n    },\n    style: {\n      fill: '#e4d9c1',\n      stroke: '#c4b89d'\n    }\n  }, c.legendCaptionConf = {\n    spreadFactor: .2,\n    padding: {\n      v: 2,\n      h: 2\n    },\n    style: {\n      fill: '#786B50',\n      fontFamily: 'sans-serif',\n      fontSize: '12px',\n      fontWeight: 'bold',\n      fontStyle: 'normal'\n    },\n    bound: {\n      style: {\n        stroke: 'none'\n      }\n    }\n  }, c.legendBodyConf = {\n    spreadFactor: .8,\n    padding: {\n      v: 2,\n      h: 2\n    },\n    bound: {\n      style: {\n        stroke: 'none'\n      }\n    }\n  }, c.legendAxisConf = {\n    legendAxisHeight: 11,\n    spreadFactor: .4,\n    padding: {\n      v: 1,\n      h: 1\n    },\n    style: {\n      stroke: 'none',\n      \"stroke-opacity\": 0,\n      \"stroke-width\": 1\n    },\n    line: {\n      grooveLength: 3,\n      offset: 8,\n      style: {\n        stroke: 'rgba(255, 255, 255, 0.65)',\n        \"stroke-width\": 1.5\n      }\n    },\n    shadow: {\n      style: {\n        stroke: 'none',\n        fill: toRaphaelColor({\n          FCcolor: {\n            alpha: '25,0,0',\n            angle: 360,\n            color: '000000,FFFFFF,FFFFFF',\n            ratio: '0,30,40'\n          }\n        })\n      }\n    },\n    bound: {\n      style: {\n        stroke: 'none'\n      }\n    }\n  }, c.sliderGroupConf = {\n    showTooltip: 1,\n    outerCircle: {\n      rFactor: 1.4,\n      style: {\n        fill: TRACKER_FILL,\n        stroke: '#757575',\n        \"stroke-width\": 3\n      }\n    },\n    innerCircle: {\n      rFactor: .65,\n      style: {\n        fill: TRACKER_FILL,\n        stroke: '#FFFFFF'\n      }\n    }\n  }, c.axisTextItemConf = {\n    spreadFactor: .3,\n    padding: {\n      v: 1,\n      h: 1\n    },\n    style: {\n      fill: '#786B50',\n      fontFamily: 'sans-serif',\n      fontSize: '12px',\n      fontWeight: 'normal',\n      fontStyle: 'normal'\n    }\n  }, {\n    init: function init(a) {\n      b = a.chart;\n    },\n    legacyDataParser: function legacyDataParser(c, d) {\n      var e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o,\n          p,\n          q = Math.max,\n          r = Math.min,\n          s = {},\n          t = b.getFromEnv('number-formatter'),\n          u = b.getFromEnv('dataSource'),\n          v = u.dataset,\n          w = u.data;\n      if (d = d || {}, !c) return !1;\n\n      for ('maps' === b.defaultDatasetType && (d.min === UNDEF || d.max === UNDEF) ? (d = {\n        min: 1 / 0,\n        max: -Infinity\n      }, w && w.forEach(function (a) {\n        d.min = r(d.min, pluckNumber(a.value, d.min)), d.max = q(d.max, pluckNumber(a.value, d.min));\n      })) : 'HeatMap' === b.getName() && (d.min === UNDEF || d.max === UNDEF) && (d = {\n        min: 1 / 0,\n        max: -Infinity\n      }, v.forEach(function (a) {\n        a.data && a.data.forEach(function (a) {\n          d.min = r(d.min, pluckNumber(a.value, d.min)), d.max = q(d.max, pluckNumber(a.value, d.max));\n        });\n      })), s.mapByPercent = o = !!pluckNumber(c.mapbypercent, 0), e = c.color || [], c.minvalue === UNDEF && (c.minvalue = d.min === UNDEF ? 0 : o ? 0 : d.min), c.maxvalue === UNDEF && (c.maxvalue = d.max === UNDEF ? 100 : o ? 100 : d.max), (c.maxvalue === c.minvalue || d.min === 1 / 0 || d.max === -Infinity) && (c.minvalue = 0, c.maxvalue = 100), p = !1, (i = 0, k = e.length); i < k; i++) {\n        if (e[i].maxvalue) {\n          p = !0;\n          break;\n        }\n      }\n\n      for (p || (e = []), g = c.code, l = s.colorRange = [], s.gradient = !!pluckNumber(c.gradient, 1), e.length ? g = getValidHexColor(g) : (g ? (h = getValidHexColor(g), g = getValidHexColor()) : (g = getValidHexColor(), h = getOppositeColor(g)), e.push({\n        code: h,\n        maxvalue: c.maxvalue,\n        label: UNDEF\n      })), a(e), e = e.sort(function (a, b) {\n        return a.maxvalue - b.maxvalue;\n      }), m = n = c.minvalue && t.getCleanValue(c.minvalue), n = (m !== UNDEF || null !== m) && (o ? m + PERCENT_STR : t.legendValue(m)), l.push({\n        code: dehashify(g),\n        value: m,\n        displayValue: n,\n        label: c.startlabel\n      }), (i = 0, k = e.length); i < k; i++) {\n        (f = e[i], j = getValidHexColor(f.code || f.color), m = n = f.maxvalue, !isNaN(parseInt(m, 10))) && (n = (m !== UNDEF || null !== m) && (o ? m + PERCENT_STR : t.legendValue(m)), l.push({\n          code: dehashify(j),\n          value: m,\n          displayValue: n,\n          label: f.label || f.displayvalue\n        }));\n      }\n\n      return l[l.length - 1].label = c.endlabel || f.label, s;\n    },\n    getDefaultConf: function getDefaultConf(a) {\n      return c[a];\n    }\n  };\n}();\n\nvar ColorRange =\n/*#__PURE__*/\nfunction (_ComponentInterface) {\n  _inherits(ColorRange, _ComponentInterface);\n\n  function ColorRange() {\n    var _this;\n\n    _classCallCheck(this, ColorRange);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ColorRange).call(this)), _this.datasource = {}, _this.config.legendItemIds = [];\n    return _this;\n  }\n\n  _createClass(ColorRange, [{\n    key: \"configure\",\n    value: function configure() {\n      var a,\n          b,\n          c,\n          d = this,\n          e = this.getFromEnv('chart'),\n          f = 'maps' === e.defaultDatasetType,\n          g = 'TreeMap' === e.getName(),\n          h = this.getFromEnv('dataSource').chart.mapbycategory,\n          i = e.getFromEnv('number-formatter'),\n          j = e.config.showLegend,\n          k = e.getChildren('colorRange') && e.getChildren('colorRange')[0];\n      e.addToEnv('colorManager', d), d.datasource = e.getFromEnv('dataSource'), a = d.datasource.colorrange, k && k.remove({\n        instant: !0\n      }), j || (d.config.legendItemIds = []), b = f ? a.gradient && +a.gradient ? 'gradient' : a.color ? 'icon' : 'none' : g ? 'gradient' : a.gradient && '0' != a.gradient && !+h ? 'gradient' : 'icon';\n      'gradient' === b ? (legendManager.init({\n        chart: e\n      }), c = legendManager.legacyDataParser(a), componentFactory(e, GradientColorRange, 'colorRange', 1, [c]), k = e.getChildren('colorRange')[0], e.addToEnv('colorRange', k), c || (k._dontPlot = !0), d.config.legendItemIds = [], d._configureGradientLegend(k)) : 'icon' === b ? (componentFactory(e, ColorBucket, 'colorRange', 1, [{\n        colorRange: a,\n        sortLegend: 0,\n        mapByCategory: pluckNumber(h, 0),\n        defaultColor: 'cccccc',\n        numberFormatter: i\n      }]), e.addToEnv('colorRange', e.getChildren('colorRange')[0]), j && d._addLegendItems()) : 'none' === b ? (e.deleteFromEnv('colorManager'), d.config.legendItemIds = []) : void 0;\n    }\n  }, {\n    key: \"_configureGradientLegend\",\n    value: function _configureGradientLegend(a) {\n      var b = this,\n          c = b.getFromEnv('chart'),\n          d = c.getFromEnv('gLegend');\n      d && (d.setColorRange(a), b.addExtEventListener('rangeUpdated', function (a, c) {\n        b.fireEvent('legendUpdate', {\n          \"original-event\": a,\n          maxMinArray: c,\n          component: 'gradientlegend'\n        });\n      }, d));\n    }\n  }, {\n    key: \"_addLegendItems\",\n    value: function _addLegendItems() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f = this,\n          g = f.config,\n          h = f.getFromEnv('chart'),\n          j = h.getChildren('legend')[0],\n          k = h.getFromEnv('colorRange'),\n          l = k.colorArr,\n          m = l.length;\n\n      for (d = 0; d < m; d++) {\n        e = {\n          label: pluck(l[d].label, l[d].displayvalue),\n          datasetObj: l[d],\n          index: d\n        }, b = getLightColor(l[d].code, 40), a = {\n          FCcolor: {\n            color: l[d].code + ',' + l[d].code + ',' + b,\n            ratio: '0,70,30',\n            angle: 270,\n            alpha: '100,100,100'\n          }\n        }, c = j.getItem(g.legendItemIds[d]), c || (g.legendItemIds.push(j.createItem(f)), c = j.getItem(g.legendItemIds[d]), c.addEventListener('fc-click', c.itemClickFn)), c.removeLegendState('hidden'), l[d].legendItemId = c && c.getId(), c.configure(e), c.setStateCosmetics('default', {\n          symbol: {\n            fill: toRaphaelColor(a),\n            rawFillColor: l[d].code\n          }\n        });\n      }\n\n      for (d = m; d < g.legendItemIds.length; d++) {\n        j.disposeItem(g.legendItemIds[d]);\n      }\n\n      g.legendItemIds.splice(m);\n    }\n  }, {\n    key: \"legendInteractivity\",\n    value: function legendInteractivity(a) {\n      var b = this,\n          c = b.getFromEnv('colorRange').colorArr[a.config.index];\n      b.fireEvent('legendUpdate', {\n        legendItem: a,\n        colorObj: c,\n        component: 'legend'\n      });\n    }\n  }, {\n    key: \"getColor\",\n    value: function getColor(a) {\n      var b = this,\n          c = b.datasource.colorrange,\n          d = b.datasource.chart.mapbycategory;\n      return !+d && +c.gradient ? {\n        code: b.getColorByValue(a)\n      } : b.getColorObj(a);\n    }\n  }, {\n    key: \"getValueRatio\",\n    value: function getValueRatio() {\n      return this.getFromEnv('colorRange').getValueRatio();\n    }\n  }, {\n    key: \"getCumulativeValueRatio\",\n    value: function getCumulativeValueRatio() {\n      return this.getFromEnv('colorRange').getCumulativeValueRatio();\n    }\n  }, {\n    key: \"getBoxFill\",\n    value: function getBoxFill(a) {\n      return this.getFromEnv('colorRange').getBoxFill(a);\n    }\n  }, {\n    key: \"getColorByValue\",\n    value: function getColorByValue(a) {\n      return this.getFromEnv('colorRange').getColorByValue(a);\n    }\n  }, {\n    key: \"getColorObj\",\n    value: function getColorObj(a) {\n      return this.getFromEnv('colorRange').getColorObj(a);\n    }\n  }]);\n\n  return ColorRange;\n}(ComponentInterface);\n\nexport default ColorRange;","map":null,"metadata":{},"sourceType":"module"}