{"ast":null,"code":"import { pluck } from '../../lib';\nexport default function (a) {\n  var b = /rgba\\([\\d]+\\,[\\d]+\\,[\\d]+\\,0\\)$/;\n  var c,\n      d = window,\n      e = Math,\n      f = e.cos,\n      g = e.sin,\n      j = e.PI,\n      k = d.parseInt,\n      l = d.parseFloat,\n      i = String,\n      h = Array.prototype.slice,\n      m = /\\s*\\,\\s*/g;\n  a && a._availableAnimAttrs && a._availableAnimAttrs.cx && (a._availableAnimAttrs['scroll-position'] = a._availableAnimAttrs.cx), a.define && a.define([{\n    name: 'polypath',\n    polypath: function polypath() {\n      return this.path(c, a._lastArgIfGroup(arguments));\n    },\n    ca: {\n      polypath: function polypath(b, c, d, e, m, n) {\n        var o, p, q, s, t;\n        if (o = [], b = k(b, 10) || 0, c = l(c) || 0, d = l(d) || 0, e = l(e) || 0, m = null === m || isNaN(m) ? .5 * j : a.rad(m), n = null === n || isNaN(n) ? 0 : l(n), s = m, 2 < b) switch (p = 2 * j / b, n) {\n          case 0:\n            for (q = 0; q < b; q++) {\n              o.push('L', c + e * f(-s), d + e * g(-s)), s += p;\n            }\n\n            o[0] = 'M', o.push('Z');\n            break;\n\n          case 1:\n            for (q = 0; q < b; q++) {\n              o.push('M', c, d, 'L', c + e * f(-s), d + e * g(-s)), s += p;\n            }\n\n            break;\n\n          default:\n            for (p *= .5, t = e * f(p) * (1 - n), q = 0; q < b; q++) {\n              o.push('L', c + e * f(-s), d + e * g(-s)), s += p, o.push('L', c + t * f(-s), d + t * g(-s)), s += p;\n            }\n\n            o[0] = 'M', o.push('Z');\n        } else 0 === e ? o.push('M', c, d, 'L', c, d, 'Z') : o.push('M', c - e, d, 'A', e, e, 0, 0, 0, c + e, d, 'A', e, e, 0, 0, 0, c - e, d, 'Z');\n        return {\n          path: o\n        };\n      },\n      r: function r(a) {\n        var b = this,\n            c = b.attrs.polypath;\n        return c[3] = a, b.attr('polypath', c), !1;\n      }\n    }\n  }]), a.ca['text-bound'] = function (d, e, f, g, h, i, j) {\n    var k = this,\n        l = k.paper,\n        m = k._.textbound;\n    if (this._origOpacity = j === c ? 1 : j, 'text' === this.type) return (!e || 'none' === e || b.test(e)) && (!d || 'none' === d || b.test(d)) ? (k._.textbound = m && m.unfollow(k).remove(), !1) : (k.attrs['text-bound'] = arguments, f && a.is(f, 'finite') || (f = 0), h && a.is(h, 'finite') || (h = 0), m || (m = k._.textbound = l.rect(0, 0, 0, 0, k.group).follow(k, a.ca['text-bound'].reposition, 'before')), m.attr({\n      stroke: e || 'none',\n      \"stroke-width\": f,\n      fill: d || 'none',\n      \"shape-rendering\": 1 === f && 'crisp' || '',\n      r: h\n    }), j !== c && m.attr('opacity', j), i && m.attr('stroke-dasharray', i), a.ca['text-bound'].reposition.call(m, k.attr(), k), !1);\n  }, a.ca['text-bound'].reposition = function (a, b) {\n    var c,\n        d,\n        e,\n        f,\n        g,\n        j,\n        k,\n        n,\n        p,\n        q = Math.max,\n        r = this,\n        o = {};\n    a.hasOwnProperty('visibility') && r.attr('visibility', a.visibility);\n    (a.hasOwnProperty('text-bound') || a.hasOwnProperty('x') || a.hasOwnProperty('y') || a.hasOwnProperty('text') || a.hasOwnProperty('text-anchor') || a.hasOwnProperty('text-align') || a.hasOwnProperty('font-size') || a.hasOwnProperty('line-height') || a.hasOwnProperty('vertical-align') || a.hasOwnProperty('transform') || a.hasOwnProperty('rotation') || a.hasOwnProperty('opacity')) && (c = b.attrs, d = c['text-bound'], e = i(d && d[3] || '0').split(m), f = l(e[0]) || 0, g = pluck(l(e[1]), f), j = b.getBBox(), n = j.width, p = j.height, r._origOpacity = b._origOpacity || 1, k = l(a.opacity || c.opacity), o.opacity = isNaN(k) ? r._origOpacity : r._origOpacity * k, !isNaN(n) && (o.x = j.x - f, o.y = j.y - g, o.width = q(n + 2 * f, 0), o.height = q(p + 2 * g, 0)), r.attr(o));\n  }, a.fn.symbol = function () {\n    var b,\n        d = this,\n        e = arguments,\n        f = e.length - 1,\n        g = e[f];\n    return g && g.constructor === a.el.constructor ? e[f] = c : g = c, b = d.path(c, g), b.ca.symbol = a.fn.symbol.ca.symbol, e.length === !!g + 0 ? b : b.attr('symbol', e);\n  }, a.fn.getSuggestiveRotation = function () {\n    var a, b, c, d;\n    return a = arguments[0], 1 === arguments.length ? (b = a.angle, c = a.x, d = a.y) : (b = a, c = arguments[1], d = arguments[2]), b = b || 0, 'r' + b + ',' + c + ',' + d;\n  }, a.fn.symbol.cache = {\n    \"\": a._cacher(function (a, b, c, d) {\n      return 3 < arguments.length ? ['M', a, b, 'h', c, 'v', d, 'h', -c, 'v', -d, 'z'] : ['M', a - c, b - c, 'h', c *= 2, 'v', c, 'h', -c, 'v', -c, 'z'];\n    })\n  }, a.fn.symbol.ca = {\n    symbol: function symbol(b) {\n      var c,\n          d,\n          e = this,\n          f = a.is(b, 'object') && 1 === arguments.length && !a.is(b, 'function') ? b : arguments;\n      f === b && (b = f[0]), c = a.is(b, 'function') && b || a.fn.symbol.cache[b] || a.fn.symbol.cache[''], d = c && c.apply(a, h.call(f, 1)), a.is(d, 'array') || a.is(d, 'string') ? e.attr('path', d) : d && e.attr(d);\n    }\n  }, a.addSymbol = function (b, c) {\n    var d,\n        e,\n        f = a.fn.symbol.cache,\n        g = [];\n\n    for (e in d = a.is(c, 'function') && (d = {}, d[b] = c, d) || b, d) {\n      c = d[e], f[e] = a.is(c, 'function') && a._cacher(c, a) || (g.push(e), c);\n    }\n\n    for (e = g.pop(); e;) {\n      f[e] = f[f[e]], e = g.pop();\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}