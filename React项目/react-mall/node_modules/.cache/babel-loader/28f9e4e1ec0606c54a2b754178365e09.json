{"ast":null,"code":"import _slicedToArray from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport Axis from './axis';\nimport { UNDEF, pluckNumber, parseUnsafeString, DASH_DEF, getDashStyle, pluck, extend2, setLineHeight, NORMAL, POSITION_START, POSITION_END, POSITION_MIDDLE, POSITION_BOTTOM, POSITION_TOP, POINTER, BLANKSTRING, parseTooltext, ONESTRING, toRaphaelColor, getValidValue, getSuggestiveRotation, convertColor } from '../lib';\nimport cartesianAxisAnimation from './cartesian-axis.animation';\nimport interpolateNumber from './utils/interpolators/number';\nimport difference from './utils/array/diff';\nimport differenceWith from 'ramda/src/differenceWith';\nimport { addDep } from '../dependency-manager';\nimport { Scroller } from '../toolbox/tools';\nimport { setAxisDimention, shiftLabels, _createContainer } from './common-api';\n\nvar CRISP = 'crisp',\n    BUTT = 'butt',\n    EVENTARGS = 'eventArgs',\n    TREND_ID = '_trend',\n    TICK_ID = '_tick',\n    LABEL_ID = '_label',\n    getCrispPath = function getCrispPath(e, a) {\n  var i,\n      t,\n      l = Math.round,\n      n = !1,\n      o = a % 2;\n  return e[1] === e[4] && (i = e[1], t = l(i), e[1] = e[4] = o ? t > i ? t - .5 : t + .5 : t, n = !0), e[2] === e[5] && (i = e[2], t = l(i), e[2] = e[5] = o ? t > i ? t - .5 : t + .5 : t, n = !0), {\n    path: e,\n    isCrisped: n\n  };\n},\n    isVisible = function isVisible(e) {\n  return function (a, i) {\n    return !!(e.minValue <= a && e.maxValue >= a || e.minValue <= i && e.maxValue >= i);\n  };\n},\n    isInBetween = function isInBetween(e) {\n  return function (a) {\n    return !!(e.minValue <= a && e.maxValue >= a);\n  };\n},\n    queryOptions = {\n  wrtVisible: !0\n},\n    minimumEnquiry = function minimumEnquiry(e) {\n  for (var a = 0, t = e.length; a < t; a++) {\n    if (e[a].label || e[a].oriLabel) return a;\n  }\n};\n\nfunction getAxisNamePaddingOffset(e, a) {\n  var i = Math.max;\n  var t = 0;\n  return e.relativeAxis && e.relativeAxis.config && e.relativeAxis.config.axisNamePadding && (t = i(e.relativeAxis.config.axisNamePadding, t)), e.isOpposit && a.canvasMarginRight && (t = i(t, a.canvasMarginRight - a.marginLeft - e.nameMaxW)), !e.isOpposit && a.canvasMarginLeft && (t = i(t, a.canvasMarginLeft - a.marginRight - e.nameMaxW)), t;\n}\n\naddDep({\n  name: 'cartesianAxisAnimation',\n  type: 'animationRule',\n  extension: cartesianAxisAnimation\n});\n\nvar Cartesian =\n/*#__PURE__*/\nfunction (_Axis) {\n  _inherits(Cartesian, _Axis);\n\n  function Cartesian() {\n    var _this;\n\n    _classCallCheck(this, Cartesian);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Cartesian).call(this)), _this.config.referenceInfo = [], _this.config.prevTicks = [], _this.config.prevIntervalArr = [], _this.config.prevTrendLabels = [], _this.config.prevCategoryIntervalArr = [];\n    return _this;\n  }\n\n  _createClass(Cartesian, [{\n    key: \"configureAttributes\",\n    value: function configureAttributes(e) {\n      _get(_getPrototypeOf(Cartesian.prototype), \"configureAttributes\", this).call(this, e);\n    }\n  }, {\n    key: \"placeAxis\",\n    value: function placeAxis(e) {\n      var a,\n          i = this,\n          t = i.getScale(),\n          l = i.getFromEnv('chart'),\n          n = i.getChildren('scrollBar') && i.getChildren('scrollBar')[0],\n          o = i.config.isVertical,\n          r = i.config.isOpposit,\n          s = i.config.isReverse,\n          d = l.config,\n          g = {};\n      return n && !n.getState('removed') && (a = n.getLogicalSpace(), a && (o ? (l.config.shift = a.width + n.config.conf.padding, g[r ? 'right' : 'left'] = l.config.shift) : (l.config.shift = a.height + n.config.conf.padding, g[r ? 'top' : 'bottom'] = l.config.shift), l._allocateSpace(g))), o ? (s ? t.setRange([d.canvasBottom, d.canvasTop]) : t.setRange([d.canvasTop, d.canvasBottom]), i._placeVerticalAxis(e)) : (s ? t.setRange([d.canvasRight, d.canvasLeft]) : t.setRange([d.canvasLeft, d.canvasRight]), i._placeHorizontalAxis(e));\n    }\n  }, {\n    key: \"_placeVerticalAxis\",\n    value: function _placeVerticalAxis(e) {\n      var a,\n          t,\n          l,\n          n,\n          o,\n          r,\n          s,\n          d,\n          g,\n          h,\n          c,\n          m,\n          x,\n          b,\n          p,\n          f,\n          v,\n          u,\n          L = Math.min,\n          w = Math.max,\n          T = this,\n          y = T.config,\n          k = T.getFromEnv('chart'),\n          C = k.config,\n          V = k.getFromEnv('smartLabel'),\n          P = y.axisRange,\n          A = y.minLabelWidthPercent,\n          S = y.name,\n          D = y.isOpposit,\n          E = T.getFromEnv('number-formatter'),\n          M = C.canvasHeight,\n          F = y.labelPadding = pluckNumber(y.rawAttr.axisValuePadding, 4),\n          R = pluckNumber(y.rawAttr.axisNamePadding, 5),\n          W = y.useEllipsesWhenOverflow,\n          H = y.name.style,\n          N = y.trend.trendStyle,\n          O = y.axisName,\n          I = y.trendLines,\n          B = y.drawLabelsOpposit,\n          _ = y.drawAxisNameOpposit,\n          z = 0,\n          G = 0,\n          Z = 0,\n          X = 0,\n          Y = 0,\n          J = 0,\n          U = {\n        left: 0,\n        right: 0\n      },\n          Q = '',\n          K = '',\n          $ = 0,\n          q = -1;\n\n      if (A && (q = A / 100 * C.width), y.oriCanvasHeight = M, 0 > F && (y.labelPadding = 2), f = y.drawTick && y.tickLength ? y.axisLineThickness + y.tickLength : y.axisLineThickness, y.showAxisLine ? (y.labelPadding = pluckNumber(F, 2) + f, 0 > y.labelPadding && (y.labelPadding = (0 > y.axisLineThickness ? 0 : f) + 2), e -= y.axisLineThickness) : (y.labelPadding = pluckNumber(F, 2), 0 > y.labelPadding && (y.labelPadding = 2)), g = P.max, h = P.min, y.name.rotation = 0, y.labels.step = y.labelStep, y.labels.isDraw = 1, y.labels.drawNormalVal = y.showDivLineValues, y.labels.drawLimitVal = y.showLimits, $ = H.lineHeight, $ = +$.replace(/px/i, ''), O && $ < e && (e -= $), 1 !== y.showLimits && 1 !== y.showDivLineValues && (y.labels.isDraw = 0), m = y.drawLabels ? T._getVMaxLabelDimention(e - y.labelPadding) : {\n        width: 0,\n        height: 0\n      }, (m.width + y.labelPadding > e && !y.tickValues || 0 === m.width) && (y.labels.isDraw = 0), y.labels.isDraw && (y.labelMaxW = m.width > q ? m.width : q, y.labelMaxH = m.height, z = y.labelMaxW + y.labelPadding, Z = z), y.drawTrendLines && y.drawTrendLabels && I && I.length) {\n        for (n = y.isPercent ? E.percentValue : y.isVertical ? E.yAxis : E.xAxis, V.useEllipsesOnOverflow(C.useEllipsesWhenOverflow), V.setStyle({\n          fontSize: N.fontSize,\n          fontFamily: N.fontFamily,\n          lineHeight: N.lineHeight,\n          fontWeight: N.fontWeight\n        }), (a = 0, t = I.length); a < t; a += 1) {\n          for (d = 0, x = I[a].line && I[a].line.length; d < x; d += 1) {\n            b = I[a].line[d], v = E.getCleanValue(pluck(b.startvalue, b.value, 0)), u = pluckNumber(b.endvalue, v), v <= g && v >= h && u <= g && u >= h && (y.isOpposit && (b.valueonright = 1), p = pluckNumber(b.valueonright, 0), s = 1 === p ? b.endvalue || b.startvalue : b.startvalue || b.endvalue, c = parseUnsafeString(b.origText || b.displayvalue || s || ''), c === s && (c = '' + n.call(E, c)), p ? c.length > K.length && (K = c) : c.length > Q.length && (Q = c));\n          }\n        }\n\n        for (m = V.getOriSize(K), J = m.width + y.labelPadding, m = V.getOriSize(Q), Y = m.width + y.labelPadding, D ? (J > Z && J > e && (J = e), Z = w(Z, J + y.labelPadding), Y > e - Z && (Y = L(Y, e - Z))) : (Y > Z && Y > e && (Y = e), Z = w(Z, Y + y.labelPadding), J > e - Z && (J = L(J, e - Z))), (a = 0, t = I.length); a < t; a += 1) {\n          for (d = 0, x = I[a].line && I[a].line.length; d < x; d += 1) {\n            b = I[a].line[d], v = E.getCleanValue(pluck(b.startvalue, b.value, 0)), u = pluckNumber(b.endvalue, v), c = 1 === +b.valueonright ? b.origText || b.displayvalue || '' + u || '' : b.origText || b.displayvalue || '' + v || '', c = parseUnsafeString('' + c), (c === b.endvalue || c === b.startvalue) && (c = '' + n.call(E, c)), b.origText = c, p = pluckNumber(b.valueonright, 0), r = p ? V.getSmartText(c, J, k.canvasHeight, W) : V.getSmartText(c, Z, k.canvasHeight, W), l = y.parsedTrendLabels[G++], l && (l.attr.text = b.displayvalue = r.text, y.isOpposit && (l.valueOnRight = 1, l.attr['text-anchor'] = POSITION_START)), r.tooltext ? (b.valueToolText = r.tooltext, l && (l.valueToolText = b.valueToolText)) : (delete b.valueToolText, l && delete l.valueToolText);\n          }\n        }\n      }\n\n      return e += $, !y.drawAxisName || 0 >= e - Z - J || '' === O ? (S.isDraw = !1, S.value = '') : (V.setStyle({\n        fontSize: H.fontSize,\n        fontFamily: H.fontFamily,\n        lineHeight: H.lineHeight,\n        fontWeight: H.fontWeight\n      }), S.isDraw = !0, y.rotateAxisName ? (y.name.rotation = D ? 90 : 270, o = V.getSmartText(O, M, e - Z - J), S.value = O, y.nameMaxW = L(o.height), X = y.nameMaxW + R) : (o = V.getSmartText(O, e - Z - J, M), S.value = O, y.nameMaxW = L(o.width, e - Z), y.nameMaxH = o.height, 0 <= y.axisNameWidth && (y.nameMaxW = L(y.nameMaxW, y.axisNameWidth)), X = y.nameMaxW + R)), D ? (B ? (U.left += w(z, Y), U.right += J) : (U.left += Y, U.right += w(z, J)), _ ? (y.axisNamePadding = U.left + R, U.left += X) : (y.axisNamePadding = U.right + R, U.right += X)) : (B ? (U.left += Y, U.right += w(z, J)) : (U.left += w(z, Y), U.right += J), _ ? (y.axisNamePadding = U.right + R, U.right += X) : (y.axisNamePadding = U.left + R, U.left += X)), S.isDraw && y.axisNamePadding + y.nameMaxW > e && (y.axisNamePadding = e - y.nameMaxW, X = y.nameMaxW + y.axisNamePadding - Z), U;\n    }\n  }, {\n    key: \"_placeHorizontalAxis\",\n    value: function _placeHorizontalAxis(e) {\n      var a,\n          t,\n          l,\n          n,\n          o,\n          r,\n          s,\n          d,\n          g,\n          h,\n          c,\n          m,\n          x,\n          b,\n          p,\n          f,\n          v,\n          u,\n          L,\n          w,\n          T = this,\n          y = T.config,\n          k = T.getFromEnv('chart'),\n          C = k.config,\n          V = k.getFromEnv('smartLabel'),\n          P = y.axisRange,\n          A = y.name,\n          S = y.isOpposit,\n          D = k.getFromEnv('number-formatter'),\n          E = y.drawLabelsOpposit,\n          M = y.drawAxisNameOpposit,\n          F = 0,\n          R = C.canvasWidth,\n          W = y.labelPadding = pluckNumber(y.rawAttr.axisValuePadding, 4),\n          H = pluckNumber(y.rawAttr.axisNamePadding, 5),\n          N = y.useEllipsesWhenOverflow,\n          O = y.name.style,\n          I = y.trend.trendStyle,\n          B = y.axisName,\n          _ = y.vTrendLines,\n          z = 0,\n          G = 0,\n          Z = 0,\n          X = {\n        top: 0,\n        bottom: 0\n      },\n          Y = 0,\n          J = 0;\n      if (0 > W && (y.labelPadding = 2), u = y.drawTick && y.tickLength ? y.axisLineThickness + y.tickLength : y.axisLineThickness, y.showAxisLine ? (y.labelPadding = pluckNumber(W, 2) + u, 0 > y.labelPadding && (y.labelPadding = (0 > y.axisLineThickness ? 0 : u) + 2), e -= y.axisLineThickness) : (y.labelPadding = pluckNumber(W, 2), 0 > y.labelPadding && (y.labelPadding = 2)), d = P.max, g = P.min, y.labels.rotation = 0, y.labels.step = y.labelStep, y.labels.isDraw = 1, y.labels.drawNormalVal = y.showDivLineValues, y.labels.drawLimitVal = y.showLimits, J = O.lineHeight, J = +J.replace(/px/i, ''), B && J < e && (e -= J), y.rotateLabels && 'stagger' !== y.labelDisplay && 'none' !== y.labelDisplay && (y.labelDisplay = 'rotate'), 1 !== y.showLimits && 1 !== y.showDivLineValues && (y.labels.isDraw = 0), f = y.drawLabels ? T._getHMaxLabelDimention(e - y.labelPadding) : {\n        width: 0,\n        height: 0\n      }, y.labels.rotation ? f.width + y.labelPadding > e && !y.tickValues && (y.labels.isDraw = 0) : f.height + y.labelPadding > e && !y.tickValues && (y.labels.isDraw = 0), y.labels.isDraw && (y.labels.rotation ? (y.labelMaxW = f.height, y.labelMaxH = f.width, F = f.width + y.labelPadding) : (y.labelMaxW = f.width, y.labelMaxH = f.height, F = f.height + y.labelPadding), z = F), z = Math.max(z, y.labelPadding), m = z <= e ? e - z : e, y.drawTrendLines && y.drawTrendLabels && _ && y.isActive) for (v = y.isPercent ? T.getFromEnv('number-formatter').percentValue : y.isVertical ? T.getFromEnv('number-formatter').yAxis : T.getFromEnv('number-formatter').xAxis, V.useEllipsesOnOverflow(C.useEllipsesWhenOverflow), V.setStyle({\n        fontSize: I.fontSize,\n        fontFamily: I.fontFamily,\n        lineHeight: I.lineHeight,\n        fontWeight: I.fontWeight\n      }), (l = 0, n = _.length); l < n; l += 1) {\n        for (s = 0, c = _[l].line && _[l].line.length; s < c; s += 1) {\n          x = _[l].line[s], L = D.getCleanValue(pluck(x.startvalue, x.value, 0)), w = pluckNumber(x.endvalue, L), L <= d && L >= g && w <= d && w >= g && (a = pluckNumber(x.valueonright, 0), t = 1 === a ? x.endvalue || x.startvalue : x.startvalue || x.endvalue, h = parseUnsafeString(x.origText || x.displayvalue || t || ''), h === t && (h = '' + v.call(k.getFromEnv('number-formatter'), h)), x.origText = h, b = V.getSmartText(h, k.canvasWidth, I.lineHeight, N), p = b.height + 2, 0 > m - p ? x.displayvalue = '' : (o = y.parsedTrendLabels[G++], o && (o.attr.text = x.displayvalue = b.text), Y = Y < b.height ? b.height : Y), b.tooltext ? (x.valueToolText = b.tooltext, o && (o.valueToolText = x.valueToolText)) : (delete x.valueToolText, o && delete o.valueToolText));\n        }\n      }\n      return m -= Y, z += Y, m += J, e += J, !y.drawAxisName || 0 >= m || '' === B ? (A.isDraw = !1, A.value = '') : (V.setStyle({\n        fontSize: O.fontSize,\n        fontFamily: O.fontFamily,\n        lineHeight: O.lineHeight,\n        fontWeight: O.fontWeight\n      }), A.isDraw = !0, r = V.getSmartText(B, R, m), A.value = B, y.nameMaxW = R, y.nameMaxH = r.height, Z = r.height + H, y.axisNamePadding = H + z, y.axisNamePadding + r.height > e && (y.axisNamePadding = e - r.height, Z = r.height + y.axisNamePadding - z)), S ? (E ? X.bottom += F + Y : (X.top += F, X.bottom += Y), y.trendBottomPadding = X.bottom - Y + 2, M ? X.bottom += Z : X.top += Z) : (E ? (X.top += F, X.bottom += Y) : X.bottom += F + Y, y.trendBottomPadding = X.bottom - Y + 2, M ? X.top += Z : X.bottom += Z), X;\n    }\n  }, {\n    key: \"_parseCategoryPlotLine\",\n    value: function _parseCategoryPlotLine() {\n      var e,\n          a,\n          t,\n          l = this,\n          n = l.config,\n          o = n.axisRange,\n          r = n.tickValues.tickValue,\n          s = convertColor(n.divLineColor, n.divLineAlpha),\n          d = n.divLineThickness,\n          g = n.divLineIsDashed ? getDashStyle(n.divLineDashLen, n.divLineDashGap, d) : DASH_DEF,\n          h = isInBetween(l.getVisibleConfig()),\n          c = n._allTicks,\n          m = c.length;\n      if ((e = {\n        stroke: s,\n        \"stroke-width\": d,\n        \"stroke-dasharray\": g\n      }, !(r[0] && (r[0].x !== UNDEF || r[0].y !== UNDEF))) && n.lines.isDraw && n.categoryNumDivLines) for (a = 0; a < m; ++a) {\n        (t = c[a], !!h(t)) && t !== o.min && t !== o.max && l.setReferenceInfo({\n          from: t,\n          type: 'line',\n          layer: 1,\n          attr: e\n        });\n      }\n    }\n  }, {\n    key: \"_drawComponents\",\n    value: function _drawComponents() {\n      var e = this,\n          a = e.config;\n      a.drawAxisName && e._drawAxisName(), a.drawAxisLine && e._drawAxisLine(), a.tickValues ? a.drawLabels && e._drawCategory() : a.drawLabels && e._drawLabel(), a.drawTrendLines && e.drawTrendLabel();\n    }\n  }, {\n    key: \"drawTrendLabel\",\n    value: function drawTrendLabel() {\n      var e,\n          a,\n          t,\n          l,\n          n,\n          o,\n          r,\n          s,\n          d,\n          g,\n          h,\n          c,\n          m,\n          x,\n          b,\n          p,\n          f = this,\n          v = f.config,\n          u = v.parsedTrendLabels,\n          L = f.getFromEnv('animationManager'),\n          w = this.getFromEnv('toolTipController'),\n          T = v.axisTrendLabelContainer,\n          y = v.isOpposit,\n          k = v.labelPadding,\n          C = v.vTrendLines,\n          V = v.trendLines,\n          P = v.axisDimention,\n          A = f.getVisibleConfig(),\n          S = A.minValue,\n          D = A.maxValue,\n          E = !0;\n\n      for (b = 0, p = u.length; b < p; b++) {\n        u[b].id = b + TREND_ID;\n      }\n\n      for (C ? l = y ? P.opposite - (v.trendBottomPadding || 0) : P.y + (v.trendBottomPadding || 0) : (l = y ? P.opposite + (k || 0) : P.x - (k || 0), n = y ? P.x + (k || 0) : P.opposite + (k || 0)), m = differenceWith(function (e, a) {\n        return e.attr.text === a.attr.text;\n      }, v.prevTrendLabels, u), (b = 0, p = m.length); b < p; b++) {\n        c = f.getGraphicalElement(m[b].id), c && f.removeGraphicalElement(c);\n      }\n\n      if (v.prevTrendLabels = extend2([], u), !v.drawTrendLabels) {\n        for (b = 0, p = u.length; b < p; b++) {\n          c = f.getGraphicalElement(u[b].id), c && f.removeGraphicalElement(c);\n        }\n\n        return;\n      }\n\n      for (b = 0, p = u.length; b < p; b++) {\n        a = u[b], t = f.getGraphicalElement(b + TREND_ID), r = +a.from, d = +a.to, E = !0, x = !isNaN(d), x ? (s = r + (d - r) / 2, (S > s || D < s) && (E = !1)) : (S > r || D < r) && (E = !1), E ? (C ? (g = f.getPixel(r, queryOptions), h = d ? f.getPixel(d, queryOptions) : 0, o = pluckNumber(a.isTrendZone, v.isTrendZone, 1), x && d != r && o ? (a.attr.x = g + (h - g) / 2, a.attr.y = l) : (a.attr.x = d ? h : g, a.attr.y = l)) : V && (g = f.getPixel(r, queryOptions), h = d ? f.getPixel(d, queryOptions) : 0, e = pluckNumber(a.valueOnRight, 0), o = pluckNumber(a.isTrendZone, v.isTrendZone, 0), x && d != r && o ? (a.attr.x = e ? n : l, a.attr.y = g + (h - g) / 2) : (a.attr.x = e ? n : l, a.attr.y = d ? e ? h : g : g)), t = f.addGraphicalElement(b + TREND_ID, L.setAnimation({\n          container: T,\n          el: t || 'text',\n          attr: a.attr,\n          css: a.css,\n          data: {\n            value: s || r\n          },\n          component: f,\n          label: 'text'\n        })), v.showTooltip && a.valueToolText ? w.enableToolTip(t, a.valueToolText) : w.disableToolTip(t)) : t && f.removeGraphicalElement(t);\n      }\n    }\n  }, {\n    key: \"_drawAxisName\",\n    value: function _drawAxisName() {\n      var e,\n          a,\n          i,\n          t,\n          l,\n          n,\n          o = Math.max,\n          r = this,\n          s = r.config,\n          d = this.getFromEnv('toolTipController'),\n          g = r.getLinkedItem('canvas').getEffectiveDimensions(),\n          h = r.getFromEnv('animationManager'),\n          c = g.left,\n          m = g.top,\n          x = g.width,\n          b = g.height,\n          p = m + b,\n          f = r.getFromEnv('chart').config,\n          v = s.name.style,\n          u = s.name.value,\n          L = s.isOpposit,\n          w = s.isVertical,\n          T = r.getFromEnv('smartLabel'),\n          y = s.axisNameContainer,\n          k = s.axisNamePadding,\n          C = s.nameMaxH,\n          V = s.nameMaxW,\n          P = s.axisDimention,\n          A = w ? P.x : P.y,\n          S = P.opposite,\n          D = r.getGraphicalElement('axisName'),\n          E = pluckNumber(s.name.rotation, w ? 90 : 270),\n          M = r.getFromEnv('paper'),\n          F = {\n        fontFamily: v.fontFamily,\n        fontSize: v.fontSize,\n        lineHeight: v.lineHeight,\n        fontWeight: v.fontWeight,\n        fontStyle: v.fontStyle\n      };\n      s.name.isDraw ? (e = {\n        fontFamily: v.fontFamily,\n        fill: v.color,\n        \"vertical-align\": 'middle',\n        \"font-size\": v.fontSize,\n        \"line-height\": v.lineHeight\n      }, T.useEllipsesOnOverflow(f.useEllipsesWhenOverflow), T.setStyle({\n        fontSize: v.fontSize,\n        fontFamily: v.fontFamily,\n        lineHeight: v.lineHeight,\n        fontWeight: v.fontWeight\n      }), s.drawAxisNameOpposit && (L = !L, A = S), w ? (k = o(k, getAxisNamePaddingOffset(s, f)), t = s.axisNameAlignCanvas || f.captionalignment && 'left' === f.captionalignment ? b : o(b, s.oriCanvasHeight || 0), E ? (a = T.getSmartText(u, t, V), i = a.tooltext, l = a.width) : (a = T.getSmartText(u, V, t), i = a.tooltext, l = a.height), n = s.drawAxisNameFromBottom ? p - l / 2 : l > b ? f.height / 2 : m + b / 2, e.text = a.text, e.x = L ? (A || c + x) + k + V / 2 : (A || c) - k - V / 2, e.y = n) : (a = T.getSmartText(u, x, C), i = a.tooltext, L && f.canvasMarginTop && (k = o(k, f.canvasMarginTop - f.marginTop - C)), !L && f.canvasMarginBottom && (k = o(k, f.canvasMarginBottom - f.marginBottom - C)), e.text = a.text, e.x = c + x / 2, e.y = L ? (A || m) - k - C / 2 : (A || p) + k + C / 2), e['text-bound'] = '' === a.text ? [] : [v.backgroundColor, v.borderColor, v.borderColor ? v.borderThickness : 0, v.borderPadding, v.borderRadius, v.borderDash], e.transform = M.getSuggestiveRotation(w ? E : 0, e.x, e.y), D = r.addGraphicalElement('axisName', h.setAnimation({\n        css: F,\n        el: D || 'text',\n        attr: e,\n        container: y,\n        component: r,\n        label: 'text'\n      })), s.showTooltip ? d.enableToolTip(D, i) : d.disableToolTip(D)) : D && r.removeGraphicalElement(D);\n    }\n  }, {\n    key: \"_drawAxisLine\",\n    value: function _drawAxisLine() {\n      var e = 'axisLine';\n      var a,\n          t,\n          l,\n          n,\n          o,\n          r,\n          s,\n          d,\n          g,\n          h,\n          c,\n          m,\n          x,\n          b,\n          p,\n          f,\n          v,\n          u,\n          L = this,\n          w = L.config,\n          T = w.isVertical,\n          y = w.isOpposit,\n          k = L.getFromEnv('chart'),\n          C = L.getLinkedItem('canvas').getEffectiveDimensions(),\n          V = L.getFromEnv('animationManager'),\n          P = C.top,\n          A = C.left,\n          S = P + C.height,\n          D = A + C.width,\n          E = w.axisDimention,\n          M = T ? E.x : E.y,\n          F = w.drawAxisLineWRTCanvas,\n          R = k.getFromEnv('dataSource').chart,\n          W = w.axisAxisLineContainerBottom,\n          H = L.getGraphicalElement('axisLine'),\n          N = [];\n\n      if (n = 1 === pluckNumber(R.showyaxisline, R.showyaxisline) ? pluckNumber(R.yaxislinethickness, R.pyaxislinethickness, 1) : 0, w.showAxisLine) {\n        if (T ? (y ? (M = F ? D : M, o = M + w.axisLineThickness / 2) : (M = F ? A : M, o = M - w.axisLineThickness / 2), f = getCrispPath(['M', o, S, 'L', o, P], w.axisLineThickness), l = f.path) : (y ? (M = F ? P : M, o = M - w.axisLineThickness / 2) : (M = F ? S : M, o = M + w.axisLineThickness / 2), f = getCrispPath(['M', A - n, o, 'L', D, o], w.axisLineThickness), l = f.path), d = {\n          path: l,\n          stroke: w.axisLineColor,\n          \"stroke-linecap\": BUTT,\n          \"stroke-width\": w.axisLineThickness,\n          \"shape-rendering\": f.isCrisped ? CRISP : UNDEF\n        }, w.drawTick && w.tickLength) for (a = {\n          stroke: w.tickColor,\n          \"stroke-width\": w.tickWidth\n        }, r = T ? y ? o + w.tickLength : o - w.tickLength : y ? o - w.tickLength : o + w.tickLength, v = w.tickValues ? w.tickValues.tickValue.map(function (e) {\n          return T ? e.y : e.x;\n        }) : w.ticks, (p = 0, u = v.length); p < u; p += 1) {\n          m = v[p], x = \"\".concat(m).concat(TICK_ID), h = L.getGraphicalElement(x), s = L.getPixel(m, queryOptions), a.path = getCrispPath(T ? ['M', o, s, 'L', r, s] : ['M', s, o, 'L', s, r], w.tickWidth).path, g = V.setAnimation({\n            el: h || 'path',\n            attr: a,\n            data: {\n              value: m,\n              path: a.path\n            },\n            container: W,\n            component: L,\n            label: 'path'\n          }), h || L.addGraphicalElement(x, g), N.push(x);\n        }\n        t = V.setAnimation({\n          el: H || 'path',\n          attr: d,\n          container: W,\n          component: L,\n          label: 'path'\n        }), H || L.addGraphicalElement(e, t), N.push(e);\n      }\n\n      for (b = difference(w.prevTicks, N), p = 0, u = b.length; p < u; p++) {\n        c = L.getGraphicalElement(b[p]), c && L.removeGraphicalElement(c);\n      }\n\n      w.prevTicks = N;\n    }\n  }, {\n    key: \"_parseCategory\",\n    value: function _parseCategory() {\n      var e,\n          a,\n          t,\n          l,\n          n,\n          o,\n          r,\n          s,\n          d,\n          g,\n          h,\n          c,\n          m,\n          x,\n          b,\n          p,\n          f,\n          v,\n          u,\n          L,\n          w,\n          T,\n          y,\n          k,\n          C,\n          V,\n          P,\n          A,\n          S,\n          D = Math.abs,\n          E = this,\n          M = E.config,\n          F = M.axisDimention || {},\n          R = E.getFromEnv('chart'),\n          W = R.getFromEnv('smartLabel'),\n          H = E.components,\n          N = H.labels,\n          O = E.getLinkedItem('canvas').getEffectiveDimensions(),\n          I = R.config,\n          B = M.isOpposit,\n          _ = M.labels,\n          z = _.style,\n          G = M.isVertical,\n          Z = O.top,\n          j = O.left,\n          X = Z + O.height,\n          Y = j + O.width,\n          J = M.labelPadding,\n          U = G ? F.x : F.y,\n          Q = F.opposite,\n          K = R.getFromEnv('dataSource').categories,\n          $ = {},\n          q = M.tickValues.tickValue,\n          ee = M.axisRange.min,\n          ae = M.drawnStaggerLines,\n          ie = (M.labelStep !== M.labels.step || 1 !== E.getZoom()) && 'stagger' === M.labelDisplay;\n      if (M.labels.isDraw) for (G && (C = D(E.getPixel(0, queryOptions) - E.getPixel(0 + M.axisRange.tickInterval, queryOptions)), M.labelMaxH > C && (w = Math.ceil(M.labelMaxH / C)), w > M.labels.step && (M.labels.step = w)), ie && (k = 2 * D(E.getPixel(ee, queryOptions) - E.getPixel(ee + M.labels.step, queryOptions)) * M.sWidthAdjstFactor - 1), l = M.labels.rotation, P = l ? M.labelMaxH : M.labelMaxW, A = l ? M.labelMaxW : M.labelMaxH, M.drawLabelsOpposit && (B = !B, U = Q), K && K[0] && 'auto' !== M.xAxisLabelMode && ($.fontFamily = K[0].font, $.fontSize = K[0].fontsize, $.color = K[0].fontcolor), M.ParentCss = m = {\n        fontFamily: pluck($.fontFamily, z.fontFamily),\n        fontSize: pluck($.fontSize, z.fontSize),\n        fontWeight: pluck(z.fontWeight),\n        fontStyle: pluck(z.fontStyle)\n      }, m.lineHeight = setLineHeight(m), u = E._getCategoryArr(), H.labelIndexArr = [], (e = 0, L = u.length); e < L; e += 1) {\n        S = u[e].index, a = q[S], f = u[e].value, H.labelIndexArr.push(S), d = pluck(a.font, a.labelfont), g = pluck(a.fontsize, a.labelfontsize), h = pluck(a.fontbold, a.labelfontbold) ? pluckNumber(a.fontbold, a.labelfontbold, 0) ? 'bold' : NORMAL : UNDEF, c = pluck(a.fontitalic, a.labelfontitalic) ? pluckNumber(a.fontitalic, a.labelfontitalic, 0) ? 'italic' : NORMAL : UNDEF, b = convertColor(pluck(a.fontcolor, a.labelfontcolor, $.color, z.color), pluckNumber(a.labelalpha, M.rawAttr.labelFontAlpha, R.config.singleseries ? UNDEF : a.alpha, 100)), d || g || h || c ? (s = {}, d && (s.fontFamily = d), g && (s.fontSize = g), h && (s.fontWeight = h), c && (s.fontStyle = c), s.lineHeight = g ? setLineHeight(s) : m.lineHeight) : s = UNDEF, (s || m) && (o = (s || m).lineHeight, -1 !== o.indexOf('px') && (n = o.replace(/px/i, ''), n = parseFloat(n))), !1 === a.appliedSmartLabel && (W.setStyle(a._ovrStyle || m), V = W.getSmartText(a.oriLabel || a.label, P, A), a.oriLabel = a.oriLabel || a.label, a.label = V.text, a.labelTooltext = V.labelTooltext, a.appliedSmartLabel = !0), p = E.getPixel(f, queryOptions), G ? (t = a.label || '', r = +a.labelPadding || 0, x = {\n          fill: b,\n          \"line-height\": n,\n          opacity: 1,\n          \"text-anchor\": B ? POSITION_START : POSITION_END,\n          text: t,\n          cursor: !I.singleseries && a.link || a.labellink || z.labelLink ? POINTER : '',\n          x: B ? (U || Y) + J : (U || j) - J,\n          y: r ? p + r : p\n        }) : (t = a.label || '', r = +a.labelPadding || 0, x = {\n          fill: b,\n          \"line-height\": n,\n          opacity: 1,\n          text: t,\n          cursor: !I.singleseries && a.link || a.labellink || z.labelLink ? POINTER : '',\n          x: p,\n          y: B ? (Z || U) - J : (U || X) + J\n        }, l ? (x['text-anchor'] = B ? POSITION_START : POSITION_END, x['vertical-align'] = 'middle') : (x['text-anchor'] = POSITION_MIDDLE, x['vertical-align'] = B ? POSITION_BOTTOM : POSITION_TOP), ie ? (T = a.labelCount % ae, T && (!(n = a.style.lineHeight) && (n = M.labels.style.lineHeight), y = n.replace(/px/i, '') * T, x.y = B ? x.y - y : x.y + y), W.setStyle(a._ovrStyle || m), V = W.getSmartText(a.oriLabel || a.label, k, A), a.oriLabel = a.oriLabel || a.label, x.text = a.label = V.text, a.labelTooltext = V.labelTooltext, a.appliedSmartLabel = !0) : r && (B ? x.y -= r : x.y += r)), v = {\n          label: a.label,\n          lineHeight: o,\n          border: pluckNumber(a.borderthickness, a.labelborderthickness) ? pluckNumber(a.borderthickness, a.labelborderthickness, 1) + 'px solid' : '',\n          borderColor: a.bordercolor || a.labelbordercolor ? convertColor(a.bordercolor || a.labelbordercolor, pluckNumber(a.borderalpha, a.labelborderalpha, a.alpha, a.labelalpha, 100)) : BLANKSTRING,\n          borderThickness: pluckNumber(a.borderthickness, a.labelborderthickness),\n          borderPadding: pluckNumber(a.borderpadding, a.labelborderpadding),\n          borderRadius: pluckNumber(a.borderradius, a.labelborderradius),\n          backgroundColor: a.bgcolor || a.labelbgcolor ? convertColor(a.bgcolor || a.labelbgcolor, pluckNumber(a.bgalpha, a.labelbgalpha, a.alpha, a.labelalpha, M.rawAttr.labelFontAlpha, 100)) : BLANKSTRING,\n          borderDash: pluckNumber(a.borderdashed, a.labelborderdashed, 0) ? getDashStyle(pluckNumber(a.borderdashlen, a.labelborderdashlen, 4), pluckNumber(a.borderdashgap, a.labelborderdashgap, 2)) : 0 === pluckNumber(a.borderdashed, a.labelborderdashed) ? DASH_DEF : z.borderDash\n        }, x['text-bound'] = a.label ? [pluck(v.backgroundColor, z.backgroundColor), pluck(v.borderColor, z.borderColor), pluck(v.borderThickness, z.borderThickness), pluck(v.borderPadding, z.borderPadding), pluck(v.borderRadius, z.borderRadius), pluck(v.borderDash, z.borderDash)] : [], _.shiftX && (x.x += _.shiftX), _.shiftY && (x.y += _.shiftY), x.transform = getSuggestiveRotation(l, x.x, x.y), N[S] = N[S] || {\n          config: {\n            props: {\n              label: {}\n            }\n          }\n        }, N[S].config.props.label.attr = x, N[S].config.props.label.css = s;\n      }\n    }\n  }, {\n    key: \"allocatePosition\",\n    value: function allocatePosition() {\n      var e = this,\n          a = e.config;\n      a.tickValues ? a.drawLabels && e._parseCategory() : a.drawLabels && e._parseLabel(), e.getChildren('scrollBar') && e.getChildren('scrollBar')[0] && e.getChildren('scrollBar')[0].setDimension(e.getScrollerDimension());\n    }\n  }, {\n    key: \"_drawCategory\",\n    value: function _drawCategory() {\n      var e,\n          a,\n          t,\n          l,\n          n,\n          o,\n          r,\n          s,\n          d,\n          g,\n          h,\n          c,\n          m = this,\n          x = m.config,\n          b = m.getFromEnv('chart'),\n          p = b.config,\n          f = x.labels,\n          v = m.getFromEnv('animationManager'),\n          u = f.style,\n          L = this.getFromEnv('toolTipController'),\n          w = x.axisContainer,\n          T = m.config.categoryLabel || (m.config.categoryLabel = []),\n          y = function y(e) {\n        return function (a) {\n          var i = this;\n          b.plotEventHandler(i, a, e);\n        };\n      },\n          k = x.tickValues.tickValue,\n          C = [];\n\n      if (x.labels.isDraw) {\n        for (w.css(x.ParentCss), r = m._getCategoryArr(), n = differenceWith(function (e, a) {\n          return e.value === a.value;\n        }, x.prevCategoryIntervalArr, r), (e = 0, d = n.length); e < d; e++) {\n          h = m.getGraphicalElement(\"\".concat(n[e].value).concat(LABEL_ID)), h && m.removeGraphicalElement(h);\n        }\n\n        for (x.prevCategoryIntervalArr = extend2([], r), e = 0, d = r.length; e < d; e += 1) {\n          C[e] = \"\".concat(r[e].value).concat(LABEL_ID);\n        }\n\n        for (e = 0, d = r.length; e < d; e += 1) {\n          c = r[e].index, a = k[c], g = m.components.labels[c].config, l = g.props.label.attr, s = m.getGraphicalElement(C[e]), t = v.setAnimation({\n            el: s || 'text',\n            attr: l,\n            container: w,\n            data: {\n              value: o\n            },\n            component: m,\n            label: 'text',\n            css: g.props.label.css\n          }), s || (m.addGraphicalElement(C[e], t), t.on('fc-click', y('dataLabelClick')).hover(y('dataLabelRollOver'), y('dataLabelRollOut'))), t.data(EVENTARGS, {\n            link: !p.singleseries && a.link || a.labellink || u.labelLink,\n            text: l.text,\n            index: c\n          }), a.labelTooltext ? L.enableToolTip(t, a.labelTooltext) : L.disableToolTip(t), T[c] = t;\n        }\n      } else for (e = 0, d = x.prevCategoryIntervalArr.length; e < d; e++) {\n        h = m.getGraphicalElement(\"\".concat(x.prevCategoryIntervalArr[e].value).concat(LABEL_ID)), h && m.removeGraphicalElement(h);\n      }\n    }\n  }, {\n    key: \"_getCategoryArr\",\n    value: function _getCategoryArr() {\n      var e,\n          a,\n          t,\n          l,\n          n,\n          o,\n          r,\n          s,\n          d,\n          g,\n          h = this,\n          c = h.config,\n          m = c.isVertical,\n          x = 0,\n          b = 0,\n          p = [];\n\n      for (e = c.tickValues.tickValue, l = minimumEnquiry(e), t = e ? e.length - 1 : 0, m && (d = Math.abs(h.getPixel(0, queryOptions) - h.getPixel(1, queryOptions)), c.labelMaxH > d && (x = Math.ceil(c.labelMaxH / d)), x > c.labels.step && (c.labels.step = x)), s = 0 < c.labels.step ? c.labels.step : 1, g = 1 !== h.getZoom(), o = this.getVisibleConfig(), a = l; a <= t; a += s) {\n        if ((n = e[a], !!n) && (r = pluckNumber(n.x, n.y, a), 0 !== pluckNumber(n.showlabel, c.showLabels, 1))) {\n          if (g && (r < o.minValue || r > o.maxValue)) {\n            n.labelCount = b++;\n            continue;\n          }\n\n          ('auto' !== c.xAxisLabelMode && 'mixed' !== c.xAxisLabelMode || 0 !== c.showZeroPlane && 0 !== c.showZeroPlaneValue || 0 !== r) && (c.labels.drawNormalVal || c.labels.drawLimitVal && (a == l || a == t)) && (c.labels.drawNormalVal || a == l || a == t) && (c.labels.drawLimitVal || a != l && a != t) && (n.labelCount = b++, p.push({\n            index: a,\n            value: r\n          }));\n        }\n      }\n\n      return p;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(e) {\n      var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        wrtVisible: !1\n      };\n      var i = this.getScale(),\n          t = this.getTranslation(),\n          l = i.getDomainValue(a.wrtVisible ? e : e - t);\n      return l;\n    }\n  }, {\n    key: \"getPixel\",\n    value: function getPixel(e) {\n      var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        wrtVisible: !1\n      };\n      var i = this.getScale(),\n          t = this.getTranslation(),\n          l = i.getRangeValue(e);\n      return a.wrtVisible ? l : l + t;\n    }\n  }, {\n    key: \"_getCustomPixel\",\n    value: function _getCustomPixel(e, a) {\n      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        wrtVisible: !1\n      };\n      if (!a) return this.getPixel(e, i);\n\n      var t = this.getScale().copy(),\n          _t$getRange = t.getRange(),\n          _t$getRange2 = _slicedToArray(_t$getRange, 2),\n          l = _t$getRange2[0],\n          n = _t$getRange2[1],\n          o = Math.min(l, n),\n          r = t.getRangeValue(e),\n          s = this.getTranslation();\n\n      return t.setRange([o, o + a]), i.wrtVisible ? r : r + s;\n    }\n  }, {\n    key: \"getTranslation\",\n    value: function getTranslation() {\n      return this.config.translation || 0;\n    }\n  }, {\n    key: \"setScrollType\",\n    value: function setScrollType(e) {\n      ('none' === e || 'smart' === e || 'always' === e) && (this.config.scrollType = e, 'none' === e ? this.disableScroll() : this.enableScroll());\n    }\n  }, {\n    key: \"getScrollType\",\n    value: function getScrollType() {\n      return this.config.scrollType;\n    }\n  }, {\n    key: \"_createScrollBar\",\n    value: function _createScrollBar() {\n      var e,\n          a = this,\n          i = a.config,\n          t = a.getFromEnv('chart'),\n          l = a.getFromEnv('animationManager'),\n          n = a.getChildren('scrollBar') && a.getChildren('scrollBar')[0];\n      n || (n = a.attachChild(new Scroller(), 'scrollBar')), n.configure({\n        isHorizontal: !i.isVertical\n      }), n.attachEventHandlers({\n        scrollStart: function scrollStart(a) {\n          e = a, t.fireChartInstanceEvent('scrollstart', {\n            scrollPosition: a\n          });\n        },\n        scroll: function scroll(e) {\n          var n = i.axisRange.max,\n              o = i.axisRange.min,\n              r = a.getVisibleConfig(),\n              s = r.minValue,\n              d = r.maxValue,\n              g = d - s,\n              h = interpolateNumber(o, n - g),\n              c = i.isReverse ? h(1 - e) : h(e);\n          a.setState('scrolling', !0), l.setAnimationState('scroll'), t.fireChartInstanceEvent('onScroll', {\n            scrollPosition: e\n          }), a.setVisibleConfig(c, c + g);\n        },\n        scrollEnd: function scrollEnd(a) {\n          t.fireChartInstanceEvent('scrollend', {\n            scrollPosition: a,\n            prevScrollPosition: e\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_disposeScrollBar\",\n    value: function _disposeScrollBar() {\n      var e = this,\n          a = e.getChildren('scrollBar') && e.getChildren('scrollBar')[0];\n      a && a.remove();\n    }\n  }, {\n    key: \"getScrollerDimension\",\n    value: function getScrollerDimension() {\n      var e,\n          a,\n          i,\n          t,\n          l,\n          n,\n          o,\n          r,\n          s,\n          d,\n          g,\n          h,\n          c,\n          m,\n          x,\n          b,\n          p,\n          f,\n          v = this,\n          u = v.getFromEnv('chart'),\n          L = v.config,\n          w = L.axisRange,\n          T = L.scrollOptions || (L.scrollOptions = {}),\n          y = w.max,\n          k = w.min,\n          C = T.vxLength,\n          V = v.getChildren('scrollBar')[0],\n          P = u.getChildren('canvas')[0].config,\n          A = L.scrollerContainer;\n      if (V) return e = V.config, a = P.canvasLeft, i = P.canvasTop, t = P.canvasHeight, l = P.canvasWidth, n = P.canvasBorderWidth, o = L.showAxisLine ? L.axisLineThickness || 0 : 0, r = pluckNumber(n, L.lineStartExtension), s = pluckNumber(n, L.lineEndExtension), T.viewPortMin = k, T.viewPortMax = y, c = v.getVisibleConfig(), m = c.maxValue, x = c.minValue, b = m - x, p = w.max - w.min, d = b / p, f = (x - w.min) / (p - b), g = T.windowedCanvasWidth = v.getPixel(C, queryOptions), h = T.fullCanvasWidth = v.getPixel(y - k, queryOptions) - g, e.scrollRatio = d, e.roundEdges = P.isRoundEdges, e.fullCanvasWidth = h, e.windowedCanvasWidth = g, e.parentLayer = A, e.scrollPosition = f, L.isVertical ? (e.scrollPosition = L.isReverse ? 1 - f : f, {\n        x: a,\n        y: i,\n        height: t\n      }) : (e.scrollPosition = f, {\n        x: a - r,\n        y: i + t + n + o - 2,\n        width: l + r + s\n      });\n    }\n  }, {\n    key: \"enableScroll\",\n    value: function enableScroll() {\n      this._createScrollBar();\n    }\n  }, {\n    key: \"disableScroll\",\n    value: function disableScroll() {\n      this._disposeScrollBar();\n    }\n  }, {\n    key: \"isScrollEnabled\",\n    value: function isScrollEnabled() {\n      return !!this.getChildren('scrollBar');\n    }\n  }, {\n    key: \"setVisibleConfig\",\n    value: function setVisibleConfig(e, a) {\n      var i,\n          t = this,\n          l = t.config,\n          n = t.getZoom(),\n          o = t.getScale();\n      return !(e >= a || e < l.axisRange.min || a > l.axisRange.max) && (i = o.setDomain([e, a]).getDomain(), l.visibleMin = i[0], l.visibleMax = i[1], l.zoom = t._computeZoom(), l.translation = t._computeTranslation(), (1 !== n || 1 !== t.getZoom()) && (l.ticks = t.generateTicks(), l.minorTicks = t.generateMinorTicks(), l.tickValues && t.calculateTicksOnLabelMode && t.calculateTicksOnLabelMode()), t.clearReferenceInfo(), t._parseReferenceVisuals(), t.fireEvent('visiblerangeset', {\n        minValue: e,\n        maxValue: a\n      }), t.asyncDraw(), !0);\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var e = this,\n          a = e.config;\n      a.axisContainer && (a.axisLabelContainerTop.hide(), a.axisContainer.hide(), a.axisNameContainer.hide(), a.axisTrendLabelContainer.hide(), a.axisAxisLineContainer.hide(), a.axisAxisLineContainerBottom.hide());\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      var e = this,\n          a = e.config;\n      a.axisContainer && (a.axisLabelContainerTop.show(), a.axisContainer.show(), a.axisNameContainer.show(), a.axisTrendLabelContainer.show(), a.axisAxisLineContainer.show(), a.axisAxisLineContainerBottom.show());\n    }\n  }, {\n    key: \"getZoom\",\n    value: function getZoom() {\n      return this.config.zoom || 1;\n    }\n  }, {\n    key: \"_computeTranslation\",\n    value: function _computeTranslation() {\n      var e = this.config,\n          a = this.getVisibleConfig(),\n          i = pluckNumber(a.minValue, e.axisRange.min, 0),\n          t = pluckNumber(e.axisRange.min, a.minValue, 0);\n      return this.getPixel(i) - this.getPixel(t);\n    }\n  }, {\n    key: \"_computeZoom\",\n    value: function _computeZoom() {\n      var e = this.config,\n          a = this.getVisibleConfig(),\n          i = pluckNumber(a.minValue, e.axisRange.min, 0),\n          t = pluckNumber(a.maxValue, e.axisRange.max, 1),\n          l = pluckNumber(e.axisRange.min, a.minValue, 0),\n          n = pluckNumber(e.axisRange.max, a.maxValue, 1),\n          o = e.maxZoomLimit,\n          r = (n - l) / (t - i);\n      return r > o ? o : r;\n    }\n  }, {\n    key: \"getTickValues\",\n    value: function getTickValues() {\n      var e = this.config.tickValues;\n      return e && e.tickValue || [];\n    }\n  }, {\n    key: \"dataLabels\",\n    value: function dataLabels(e) {\n      var a = this,\n          i = a.config.axisIndex,\n          t = a.getFromEnv('number-formatter');\n      return t.dataLabels(e, i);\n    }\n  }, {\n    key: \"getAxisBase\",\n    value: function getAxisBase() {\n      var _this$getVisibleConfi = this.getVisibleConfig(),\n          e = _this$getVisibleConfi.minValue,\n          a = _this$getVisibleConfi.maxValue;\n\n      return 0 > e && 0 < a ? 0 : 0 >= a ? a : e;\n    }\n  }, {\n    key: \"_parseReferenceVisuals\",\n    value: function _parseReferenceVisuals() {\n      var e,\n          a,\n          i = this,\n          t = i.config,\n          l = i.getTickValues(),\n          n = l.length,\n          o = i.getFromEnv('chartConfig').is3D;\n      t.isActive || (e = t.lines.isDraw, a = t.band.isDraw, t.lines.isDraw = 0, t.band.isDraw = 0), t.tickValues ? t.drawLabels && i._parseCategoryLine(l, 0, n) : t.drawPlotlines && i._parsePlotLine(), t.tickValues && 'auto' !== t.xAxisLabelMode ? (t.drawPlotlines && !o && i._parseCategoryPlotLine(), t.drawPlotBands && !o && i._parseCategoryPlotBand(), 'mixed' === t.xAxisLabelMode && t.drawPlotBands && !o && i._parsePlotBand()) : t.drawPlotBands && !o && i._parsePlotBand(), t.isActive || (t.lines.isDraw = e, t.band.isDraw = a), t.drawTrendLines && i._parseTrendLine();\n    }\n  }, {\n    key: \"_parseCategoryPlotBand\",\n    value: function _parseCategoryPlotBand() {\n      var e,\n          a,\n          t,\n          l,\n          n,\n          o = this,\n          r = o.config,\n          s = r.tickValues.tickValue,\n          d = r.showAlternateGridColor,\n          g = r.alternateGridColor,\n          h = r.alternateGridAlpha,\n          c = r._allTicks,\n          m = o.getLimit(),\n          x = m.min,\n          b = m.max,\n          p = isVisible(o.getVisibleConfig());\n      if (!(s[0] && (s[0].x !== UNDEF || s[0].y !== UNDEF)) && d && r.band.isDraw && r.categoryNumDivLines) for (e = {\n        fill: toRaphaelColor(convertColor(g, h)),\n        \"stroke-width\": 0\n      }, a = 0, n = 0; n < c.length; ++a, ++n) {\n        p(c[n], c[n + 1]) && (t = c[n], 0 == a % 2) && (l = c[n + 1], l !== UNDEF) && (t === x && (t = 'canvasStart'), l === b && (l = 'canvasEnd'), o.setReferenceInfo({\n          from: t,\n          to: l,\n          layer: 0,\n          type: 'band',\n          attr: e\n        }));\n      }\n    }\n  }, {\n    key: \"_parseTrendLine\",\n    value: function _parseTrendLine() {\n      var e,\n          a,\n          t,\n          l,\n          n,\n          o,\n          r,\n          s,\n          d,\n          g,\n          h,\n          c,\n          m,\n          x,\n          b,\n          p,\n          f,\n          v,\n          u,\n          L,\n          w = this,\n          T = w.config,\n          y = T.isVertical,\n          k = T.axisIndex,\n          C = w.getFromEnv('chart-attrib'),\n          V = w.getFromEnv('number-formatter'),\n          P = T.axisRange,\n          A = P.max,\n          S = P.min,\n          D = T.trend.trendStyle,\n          E = {\n        fontFamily: D.fontFamily,\n        fontSize: D.fontSize,\n        lineHeight: D.lineHeight,\n        fontWeight: D.fontWeight,\n        fontStyle: D.fontStyle\n      },\n          M = T.vTrendLines,\n          F = T.trendLines,\n          R = 0;\n      if (r = F || M, r) for (t = 0, l = r.length; t < l; t += 1) {\n        for (e = 0, a = r[t].line && r[t].line.length; e < a; e += 1) {\n          (h = r[t].line[e], f = y ? 'yAxis' : 'xAxis', x = h.startvalue || h.value || 0, x = V.getCleanValue(pluck(h.startvalue, h.value, 0)), b = +h.endvalue || UNDEF, n = getValidValue(parseUnsafeString(pluck(r[t].line[e].tooltext, r[0].tooltext, T.trendlineToolText))), n = parseTooltext(n, [7, 15, 16, 17, 18, 19], {\n            startValue: x,\n            startDataValue: V[f](x, k),\n            endValue: b || x,\n            endDataValue: V[f](b || x, k),\n            axisName: T.axisName\n          }, h), !(x > A || x < S || b > A || b < S)) && (M ? (c = parseUnsafeString(h.displayvalue || ''), s = pluckNumber(h.istrendzone, T.isTrendZone, 1), b !== UNDEF && '' !== b && b !== x && s ? (d = {\n            fill: convertColor(pluck(h.color, T.trendlineColor), pluck(h.alpha, T.trendlineAlpha, 40)),\n            \"stroke-width\": 0\n          }, g = {\n            fill: convertColor(pluck(h.color, D.color), pluck(D.valueAlpha, h.alpha, T.trendlineAlpha, 99)),\n            \"vertical-align\": POSITION_TOP,\n            text: c\n          }) : (p = pluckNumber(h.thickness, T.trendlineThickness, 1), d = {\n            stroke: convertColor(pluck(h.color, T.trendlineColor), pluck(h.alpha, T.trendlineAlpha, 99)),\n            \"stroke-width\": p,\n            \"stroke-dasharray\": pluck(h.dashed, T.trendlinesAreDashed) === ONESTRING ? getDashStyle(pluckNumber(h.dashlen, T.trendlinesDashLen), pluckNumber(h.dashgap, T.trendlinesDashGap)) : DASH_DEF\n          }, g = {\n            fill: convertColor(pluck(h.color, D.color), pluck(D.valueAlpha, h.alpha, T.trendlineAlpha, 99)),\n            \"vertical-align\": POSITION_TOP,\n            text: c\n          })) : F && (c = pluck(parseUnsafeString(h.displayvalue), h.startvalue, ''), m = pluckNumber(h.valueonright, 0), s = pluckNumber(h.istrendzone, T.isTrendZone, 0), b !== UNDEF && '' !== b && b !== x && s ? (d = {\n            fill: convertColor(pluck(h.color, T.trendlineColor), pluck(h.alpha, T.trendlineAlpha, 40)),\n            \"stroke-width\": 0\n          }, g = {\n            \"text-anchor\": m ? POSITION_START : POSITION_END,\n            fill: convertColor(pluck(h.color, D.color), pluck(D.valueAlpha, h.alpha, T.trendlineAlpha, 99)),\n            text: c\n          }) : (p = pluckNumber(h.thickness, T.trendlineThickness, 1), d = {\n            stroke: convertColor(pluck(h.color, T.trendlineColor), pluck(h.alpha, T.trendlineAlpha, 99)),\n            \"stroke-width\": p,\n            \"stroke-dasharray\": pluck(h.dashed, T.trendlinesAreDashed) === ONESTRING ? getDashStyle(pluckNumber(h.dashlen, T.trendlinesDashLen), pluckNumber(h.dashgap, T.trendlinesDashGap)) : DASH_DEF\n          }, g = {\n            \"text-anchor\": m ? POSITION_START : POSITION_END,\n            fill: convertColor(pluck(h.color, D.color), pluck(D.valueAlpha, h.alpha, T.trendlineAlpha, 99)),\n            text: c\n          })), g['text-bound'] = g.text ? [D.backgroundColor, D.borderColor, D.borderThickness, D.borderPadding, D.borderRadius, D.borderDash] : [], T.showTooltip && n || (n = ''), o = T.forceTrendBelow ? 0 : pluckNumber(h.showontop, C.showtrendlinesontop, 0), y ? (v = x, L = b === UNDEF ? x : b) : (v = b === UNDEF ? x : b, L = x), u = s && v !== L ? 'band' : 'line', v !== UNDEF && w.setReferenceInfo({\n            from: v,\n            to: L,\n            toolText: n,\n            attr: d,\n            layer: o ? 3 : 2,\n            type: u,\n            id: 'trend' + R + u\n          }), T.parsedTrendLabels.push({\n            css: E,\n            valueOnRight: m,\n            isTrendZone: s,\n            from: x,\n            to: b,\n            attr: g\n          }), R += 1);\n        }\n      }\n    }\n  }, {\n    key: \"_parsePlotLine\",\n    value: function _parsePlotLine() {\n      var e,\n          a,\n          t,\n          l,\n          n,\n          o = this,\n          r = o.config,\n          s = r.axisRange,\n          d = s.max,\n          g = s.min,\n          h = isInBetween(o.getVisibleConfig()),\n          c = r.showCanvasBorder,\n          m = convertColor(r.divLineColor, r.divLineAlpha),\n          x = r.divLineThickness,\n          b = r.divLineIsDashed ? getDashStyle(r.divLineDashLen, r.divLineDashGap) : DASH_DEF,\n          p = convertColor(r.zeroPlaneColor, r.zeroPlaneAlpha),\n          f = r.zeroPlaneThickness,\n          v = r._allTicks,\n          u = v.length,\n          L = r.showZeroPlaneOnTop,\n          w = r.minorTicks,\n          T = w && w.length;\n      if (r.lines.isDraw) for (a = 0; a < u; ++a) {\n        (e = v[a], !!h(e)) && (l = {\n          \"stroke-dasharray\": b\n        }, !(0 === r.showZeroPlane && 0 === e || c && (e === d || e === g))) && (0 === e && e !== g && e !== d ? (l.stroke = p, l['stroke-width'] = f, L = r.showZeroPlaneOnTop) : (L = 0, l.stroke = m, l['stroke-width'] = x), o.setReferenceInfo({\n          type: 'line',\n          from: e,\n          layer: 0 === e && L ? 3 : 1,\n          attr: l\n        }));\n      }\n\n      for (n = {\n        stroke: r.minorDivlinecolor,\n        \"stroke-width\": r.minorDivLineThickness,\n        \"stroke-dasharray\": b\n      }, a = 0; a < T; ++a) {\n        t = w[a], o.setReferenceInfo({\n          type: 'line',\n          from: t,\n          layer: 1,\n          attr: n\n        });\n      }\n    }\n  }, {\n    key: \"_parseCategoryLine\",\n    value: function _parseCategoryLine(e, a, t) {\n      var l,\n          n,\n          o,\n          r,\n          s,\n          d,\n          g = this,\n          h = g.config,\n          c = g.getFromEnv('color-manager'),\n          m = g.getFromEnv('chartInstance'),\n          x = m.getJSONData().categories,\n          b = {};\n      if (a = a || 0, t = t || e ? e.length - 1 : 0, h.drawPlotlines) for (d = 1 !== g.getZoom(), o = this.getVisibleConfig(), x && x[0] && (b.verticalLineColor = x[0].verticallinecolor, b.verticalLineAlpha = x[0].verticallinealpha, b.verticalLineThickness = x[0].verticallinethickness, b.verticalLineDashed = x[0].verticallinedashed, b.verticalLineDashLen = x[0].verticallinedashlen, b.verticalLineDashGap = x[0].verticallinedashgap), l = a; l <= t; l += 1) {\n        (n = e[l], !!n) && (s = pluckNumber(n.x, n.y, l), 1 === +n.showverticalline) && (d && (s < o.minValue || s > o.maxValue) || (r = {\n          stroke: convertColor(pluck(n.linecolor, b.verticalLineColor, h.divLineColor, c.getColor('divLineColor')), pluck(n.linealpha, b.verticalLineAlpha, c.getColor('divLineAlpha'))),\n          \"stroke-width\": pluckNumber(n.linethickness, b.verticalLineThickness, 1)\n        }, r['stroke-dasharray'] = pluckNumber(n.linedashed, b.verticalLineDashed, 0) ? getDashStyle(pluckNumber(n.linedashLen, b.verticalLineDashLen, 4), pluckNumber(n.linedashgap, b.verticalLineDashGap, 2), r['stroke-width']) : DASH_DEF, g.setReferenceInfo({\n          type: 'line',\n          from: s,\n          layer: 1,\n          attr: r\n        })));\n      }\n    }\n  }, {\n    key: \"_parsePlotBand\",\n    value: function _parsePlotBand() {\n      var e,\n          a,\n          t,\n          l,\n          n,\n          o,\n          r = Math.min,\n          s = Math.max,\n          d = this,\n          g = d.config,\n          h = g.showAlternateGridColor,\n          c = g.alternateGridColor,\n          m = g.alternateGridAlpha,\n          x = g._allTicks,\n          b = isVisible(d.getVisibleConfig()),\n          p = g.isReverse;\n      if (h && g.band.isDraw) for (a = 1, e = {\n        fill: toRaphaelColor(convertColor(c, m)),\n        \"stroke-width\": 0\n      }, (l = 0, t = x.length); l < t; ++l, ++a) {\n        b(x[l], x[l + 1]) && 0 == a % 2 && x[l + 1] !== UNDEF && (o = p ? s(x[l], x[l + 1]) : r(x[l], x[l + 1]), n = p ? r(x[l], x[l + 1]) : s(x[l], x[l + 1]), d.setReferenceInfo({\n          from: o,\n          to: n,\n          type: 'band',\n          layer: 0,\n          attr: e\n        }));\n      }\n    }\n  }, {\n    key: \"getReferenceInfo\",\n    value: function getReferenceInfo() {\n      return this.config.referenceInfo;\n    }\n  }, {\n    key: \"setReferenceInfo\",\n    value: function setReferenceInfo(e) {\n      this.config.referenceInfo.push(e);\n    }\n  }, {\n    key: \"clearReferenceInfo\",\n    value: function clearReferenceInfo() {\n      var e = this.config;\n      e.referenceInfo = [], e.parsedTrendLabels = [], e.parsedVlineInfo = [];\n    }\n  }, {\n    key: \"resetStoredLimits\",\n    value: function resetStoredLimits() {\n      this.config.dataLimit = {};\n    }\n  }, {\n    key: \"decideScroll\",\n    value: function decideScroll() {\n      var e = this,\n          a = e.getScrollType();\n      'always' === a || 'smart' === a && 1 !== e.getZoom() ? e.enableScroll() : e.disableScroll();\n    }\n  }, {\n    key: \"getAxisDimension\",\n    value: function getAxisDimension() {\n      var _this$config$axisDime = this.config.axisDimention,\n          e = _this$config$axisDime.x,\n          a = _this$config$axisDime.y,\n          i = _this$config$axisDime.opposite,\n          t = _this$config$axisDime.axisLength;\n      return {\n        x: e,\n        y: a,\n        opposite: i,\n        axisLength: t\n      };\n    }\n  }]);\n\n  return Cartesian;\n}(Axis);\n\nCartesian.prototype.setAxisDimention = setAxisDimention, Cartesian.prototype.shiftLabels = shiftLabels, Cartesian.prototype._createContainer = _createContainer;\nexport default Cartesian;\nexport { getCrispPath, minimumEnquiry };","map":null,"metadata":{},"sourceType":"module"}