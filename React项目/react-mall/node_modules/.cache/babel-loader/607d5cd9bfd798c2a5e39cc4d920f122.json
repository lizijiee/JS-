{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { raiseError } from '../../../fc-core/src/event-api';\n\nvar FCGlobal,\n    UNDEF,\n    jsonToCsv,\n    csvToJson,\n    multilevelPieCsv,\n    _recursiveCategoryCall,\n    multiPieData,\n    multiPieLineCount,\n    headerLen,\n    counter,\n    win = window,\n    COMMA = ',',\n    QUOTE = '\"',\n    APOS = '\\'',\n    TAB = '\\t',\n    CRLF = '\\r\\n',\n    LIT_QUOT = '{quot}',\n    LIT_TAB = '{tab}',\n    LIT_APOS = '{apos}',\n    toInt = win.parseInt,\n    toFloat = win.parseFloat,\n    returnFirstArgument = function returnFirstArgument(a) {\n  return a;\n};\n\nvar DSV =\n/*#__PURE__*/\nfunction () {\n  function DSV(a) {\n    _classCallCheck(this, DSV);\n\n    this.data = [], this.rowCount = 0, this.columnCount = 0, this.configure(a);\n  }\n\n  _createClass(DSV, [{\n    key: \"set\",\n    value: function set(a, b, c) {\n      var d;\n\n      if (this.rowCount <= a) {\n        for (d = this.rowCount; d <= a; d += 1) {\n          this.data[d] = [];\n        }\n\n        this.rowCount = a + 1;\n      }\n\n      this.columnCount <= b && (this.columnCount = b + 1), this.data[a][b] = c;\n    }\n  }, {\n    key: \"setRow\",\n    value: function setRow(a, b) {\n      var c;\n\n      if (this.rowCount <= a) {\n        for (c = this.rowCount; c <= a; c += 1) {\n          this.data[c] = [];\n        }\n\n        this.rowCount = a + 1;\n      }\n\n      this.columnCount < b.length && (this.columnCount = b.length), this.data[a] = b;\n    }\n  }, {\n    key: \"get\",\n    value: function get(a, b) {\n      var c = this.data;\n      return c[a] && c[a][b];\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(a) {\n      var b = DSV.decodeLiterals;\n      this.delimiter = b(a.delimiter, COMMA), this.qualifier = b(a.qualifier, QUOTE), this.eolCharacter = b(a.eolCharacter, CRLF), this.numberFormatted = !!toInt(a.numberFormatted, 0);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.data = [], this.rowCount = 0, this.columnCount = 0;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var a,\n          b,\n          c = '';\n\n      for (a = 0; a < this.rowCount; a += 1) {\n        b = this.qualifier + this.data[a].join(this.qualifier + this.delimiter + this.qualifier) + this.qualifier, c += '\"\"' === b ? this.eolCharacter : b + this.eolCharacter;\n      }\n\n      return 0 < this.rowCount && (c = c.slice(0, c.length - 2)), c;\n    }\n  }]);\n\n  return DSV;\n}();\n\nDSV.decodeLiterals = function (a, b) {\n  return a !== UNDEF && null !== a && a.toString ? a.replace(LIT_TAB, TAB).replace(LIT_QUOT, QUOTE).replace(LIT_APOS, APOS) : b;\n}, _recursiveCategoryCall = function recursiveCategoryCall(a, b) {\n  var c,\n      d = a.label || '';\n\n  if (multiPieData.push(d), counter++, headerLen = Math.max(headerLen, counter), a.category !== UNDEF) {\n    for (c = 0; c < a.category.length; ++c) {\n      _recursiveCategoryCall(a.category[c], b);\n    }\n\n    multiPieData.pop(), counter--;\n  } else b.setRow(multiPieLineCount++, multiPieData.slice()), multiPieData.pop(), counter--;\n}, multilevelPieCsv = function multilevelPieCsv(a) {\n  var b,\n      c,\n      d,\n      e = a,\n      f = e.chart,\n      g = e && e.category || [],\n      h = g.length,\n      j = [];\n\n  for (multiPieLineCount = 1, headerLen = 0, counter = 0, d = new DSV({\n    separator: f.exportdataseparator,\n    qualifier: f.exportdataqualifier,\n    numberFormatted: f.exportdataformattedval\n  }), b = 0; b < h; ++b) {\n    c = g[b], multiPieData = [], _recursiveCategoryCall(c, d);\n  }\n\n  for (b = 0; b < headerLen; ++b) {\n    j.push('category');\n  }\n\n  return d.setRow(0, j), {\n    data: d.toString(),\n    error: UNDEF,\n    predictedFormat: {\n      multilevel: !0\n    }\n  };\n}, jsonToCsv = function jsonToCsv(a, b) {\n  var c,\n      d,\n      e,\n      f,\n      h,\n      m,\n      n,\n      o,\n      p,\n      q,\n      r,\n      s,\n      t,\n      u,\n      v,\n      w,\n      x,\n      y,\n      z,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H,\n      I,\n      J,\n      K,\n      L,\n      M,\n      N,\n      O = a,\n      P = b && b.jsVars,\n      Q = b && b.args,\n      R = Q && Q.type,\n      S = P && P.instanceAPI,\n      T = O.chart || O.map || O.graph || {},\n      U = !!(T.exporterrorcolumns || 0),\n      V = O.categories && O.categories[0] && O.categories[0].category || [],\n      W = O.map && !O.chart || P && P.instanceAPI && 'geo' === P.instanceAPI.defaultSeriesType,\n      X = !1,\n      Y = !1,\n      Z = !1,\n      $ = !1,\n      _ = !1,\n      aa = returnFirstArgument,\n      ba = {},\n      ca = 0,\n      da = -1;\n\n  if ('multilevelpie' === R) return multilevelPieCsv(a);\n  if (c = new DSV({\n    separator: T.exportdataseparator,\n    qualifier: T.exportdataqualifier,\n    numberFormatted: T.exportdataformattedval\n  }), FCGlobal.formatNumber && c.numberFormatted && (aa = function aa(a, b) {\n    return FCGlobal.formatNumber(a, T, b);\n  }), W) for (H in ba.geo = !0, p = P.instanceAPI.getDatasets(), G = p && p[0] && p[0].components.data || [], c.setRow(0, ['Id', ' Short Name', 'Long Name', 'Value', 'Formatted Value']), h = 0, G) {\n    (I = G[H], J = I.config, M = J.cleanValue, !0 !== I.hidden) && c.setRow(++h, [H, J.shortLabel, J.label, null === M ? '' : M, J.formattedValue]);\n  } else if ((p = O.dials && O.dials.dial || O.pointers && O.pointers.pointer || O.value) !== UNDEF) {\n    if (ba.gauge = !0, 'string' == typeof p) c.set(0, 0, aa(p)), ba.singlevalue = !0, 'string' == typeof O.target && (c.set(0, 1, aa(O.target)), ba.bullet = !0);else for (c.setRow(0, ['Id', 'Value']), ba.multivalue = !0, (h = 0, n = 1, m = p.length); h < m; h += 1, n += 1) {\n      c.setRow(n, [n, aa(p[h].value)]);\n    }\n  } else if (p = O.dataset || !(O.data instanceof Array) && []) {\n    if (ba.multiseries = !0, e = 1, q = O.lineset, q && (p = p.concat(q), ba.lineset = !0), r = O.axis, r && (p = p.concat(r), ba.multiaxis = !0), u = p.length, t = V.length, !(u = p.length)) {\n      for (h = 0; h < t; h += 1) {\n        v = V[h], c.set(h + 1, 0, v.label || v.name);\n      }\n\n      ba.multilevel = !0;\n    }\n\n    for (h = 0; h < u; h += 1) {\n      for (w = p, w[h].dataset ? (w = w[h].dataset, f = 0, s = w.length) : (w = p, f = h, s = f + 1); f < s && !X && !Z; f += 1) {\n        if (x = w[f], da++, !(S && (D = S.getDatasets()) && D[da] && !1 === D[da].visible)) {\n          for (K = S && D && D[da], N = K && K.config && K.config.parentYAxis, c.set(0, e, x.seriesname), 'string' == typeof x.data && (ba.compactdata = !0, x.data = x.data.split(T.dataseparator || '|')), (m = 0, n = 0, y = x.data && x.data.length || 0); m < y || m < t; m += 1) {\n            if (v = V[m], d = n + 1, z = x.data && x.data[n] || {}, z.x !== UNDEF && z.y !== UNDEF) {\n              X = ba.xy = !0;\n              break;\n            }\n\n            if (z.open !== UNDEF || z.high !== UNDEF || z.close !== UNDEF || z.low !== UNDEF) {\n              $ = ba.ohlc = !0;\n              break;\n            }\n\n            if (z.rowid !== UNDEF && z.columnid !== UNDEF) {\n              Z = ba.heatmap = !0;\n              break;\n            }\n\n            m < t && !v.vline && (c.set(d, 0, v.label || v.name), A = toFloat(z ? z.value : ''), A = isNaN(A) ? '' : aa(A, N), c.set(d, e, A), (Y || U || z.errorvalue) && (!Y && c.set(0, e + 1, 'Error'), C = 1, c.set(d, e + 1, aa(z.errorvalue))), n += 1);\n          }\n\n          C && (e += C, C = 0), e += 1;\n        }\n      }\n    }\n\n    q && (p = p.slice(0, -q.length)), r && (p = p.slice(0, -r.length));\n  } else if (p = O.data) {\n    for (c.set(0, 1, T.yaxisname || 'Value'), ba.singleseries = !0, _ = '1' == T.showsumatend, (h = 0, t = p.length); h < t; h += 1) {\n      z = p[h], z.vline || (A = toFloat(z.value ? z.value : ''), c.setRow(h + 1, [z.label || z.name, isNaN(A) ? '' : (ca += A, aa(A))]));\n    }\n\n    _ && (ba.summation = !0, c.setRow(h + 1, [T.sumlabel || 'Total', aa(ca)]));\n  }\n  if ($) for (c.clear(), c.setRow(0, ['Open', 'Close', 'High', 'Low']), (h = 0, d = 1, p = O.dataset, s = p.length); h < s; h += 1) {\n    for (m = 0, x = p[h] && p[h].data || [], u = x.length; m < u; m += 1, d += 1) {\n      z = x[m] || {}, c.setRow(m + 1, [aa(z.open), aa(z.close), aa(z.high), aa(z.low)]);\n    }\n  } else if (X) {\n    for (c.clear(), Y = !1, C = 0, c.setRow(0, ['Series', 'x', 'y']), (h = 0, d = 1, p = O.dataset, s = p.length); h < s; h += 1) {\n      if (!(S && (D = S.getDatasets()) && D[h] && !1 === D[h].visible)) for (m = 0, x = p[h] && p[h].data || [], u = x.length; m < u; m += 1, d += 1) {\n        z = x[m] || {}, A = [p[h].seriesname, aa(z.x), aa(z.y)], z.z !== UNDEF && (A.push(aa(z.z)), !C && (c.set(0, 3, 'z'), C = 1)), (Y || U || z.errorvalue !== UNDEF || z.horizontalerrorvalue !== UNDEF || z.verticalerrorvalue !== UNDEF) && (B = aa(z.errorvalue), A.push(z.errorvalue, z.horizontalerrorvalue === UNDEF ? B : aa(z.horizontalerrorvalue), z.verticalerrorvalue === UNDEF ? B : aa(z.verticalerrorvalue)), !Y && (c.set(0, C + 3, 'Error'), c.set(0, C + 4, 'Horizontal Error'), c.set(0, C + 5, 'Vertical Error')), Y = ba.error = !0), c.setRow(d, A);\n      }\n    }\n  } else if (Z) {\n    for (c.clear(), E = {}, F = {}, (h = 0, m = 1, V = O.rows && O.rows.row || [], o = V.length); h < o; h += 1, m += 1) {\n      v = V[h], v.id && (E[v.id.toLowerCase()] = m, c.set(m, 0, v.label || v.id));\n    }\n\n    for (h = 0, m = 1, V = O.columns && O.columns.column || [], o = V.length; h < o; h += 1, m += 1) {\n      v = V[h], v.id && (F[v.id.toLowerCase()] = m, c.set(0, m, v.label || v.id));\n    }\n\n    for (x = O.dataset && O.dataset[0] && O.dataset[0].data || [], L = S && (D = S.getDatasets()) && D[0] && D[0].components && D[0].components.data || [], (h = 0, o = x.length); h < o; h += 1) {\n      (z = x[h], d = z.rowid.toLowerCase(), e = z.columnid.toLowerCase(), !(L[h] && !1 === L[h].visible)) && (E[d] || (E[d] = c.rowCount, c.set(c.rowCount, 0, z.rowid)), F[e] || (F[e] = c.columnCount, c.set(0, c.columnCount, z.columnid)), c.set(E[d], F[e], aa(z.value)));\n    }\n  }\n  return r = null, q = null, V = null, p = null, 0 < c.rowCount && c.get(0, 0) === UNDEF && c.set(0, 0, T.xaxisname || 'Label'), {\n    data: c.toString(),\n    error: UNDEF,\n    predictedFormat: ba\n  };\n}, csvToJson = function csvToJson(a, b) {\n  return raiseError(b, '0604111215', 'run', 'csvToJson()', 'fusionCharts CSV data-handler only supports encoding of data.'), a;\n};\n\nfunction getCSVData() {\n  return this.getChartData('csv');\n}\n\nfunction getDataAsCSV() {\n  return this.getCSVData();\n}\n\nfunction wrapper(a) {\n  return a && (FCGlobal = a, a.prototype.getDataAsCSV = getDataAsCSV, a.prototype.getCSVData = getCSVData), {\n    format: 'csv',\n    toJSON: csvToJson,\n    fromJSON: jsonToCsv\n  };\n}\n\nexport default {\n  extension: wrapper,\n  name: 'csv',\n  type: 'transcoder',\n  requiresFusionCharts: !0\n};","map":null,"metadata":{},"sourceType":"module"}