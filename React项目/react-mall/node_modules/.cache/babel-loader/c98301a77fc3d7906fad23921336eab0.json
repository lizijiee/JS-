{"ast":null,"code":"var UNDEF,\n    BGRATIOSTRING,\n    symbolStr = {\n  circle: 'circle',\n  triangle: 'triangle',\n  square: 'square',\n  diamond: 'diamond',\n  poly: 'poly_',\n  spoke: 'spoke_'\n},\n    COLOR_BLACK = '000000',\n    COLOR_WHITE = 'FFFFFF',\n    mathAbs = Math.abs,\n    stripWhitespace = /\\s+/g,\n    dropHash = /^#?/,\n    validhexcolor = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i,\n    COMMA = ',',\n    startsRGBA = /^rgba/i,\n    cleanColorCode = /[#\\s]/ig,\n    BLANK = '',\n    HASHSTRING = '#';\n\nfunction parsePointValue(a, b) {\n  return a = a || !1 === a || 0 === a ? +a : NaN, isNaN(a) ? null : b ? mathAbs(a) : a;\n}\n\nfunction getFirstColor(a, b) {\n  return a = a.split(COMMA)[b || 0], a = a.replace(stripWhitespace, BLANK), a == BLANK && (a = COLOR_BLACK), a.replace(dropHash, HASHSTRING);\n}\n\nfunction getFirstAlpha(a) {\n  return a = parseInt(a, 10), (isNaN(a) || 100 < a || 0 > a) && (a = 100), a;\n}\n\nfunction getAlpha(a, b) {\n  return a = +a, a = isNaN(a) ? 100 : a, b !== UNDEF && (a = a * b / 100), a % 101;\n}\n\nfunction parseAlpha(a, b, c) {\n  var d,\n      e = a.split(COMMA);\n\n  for (c !== UNDEF && (c = +c.split(COMMA)[0]), c = isNaN(c) ? UNDEF : c, e[0] = getAlpha(e[0], c), d = 1; d < b; d += 1) {\n    e[d] = e[0] * getAlpha(e[d], c) / 100;\n  }\n\n  return e.join(COMMA);\n}\n\nfunction convertColor(a, b, c) {\n  var d,\n      e,\n      f = 0,\n      g = 0,\n      h = 0;\n  if (c && c.match(startsRGBA) && (e = c.split(COMMA), f = e[0].slice(e[0].indexOf('(') + 1), g = e[1], h = e[2], !b && 0 !== b && (b = parseInt(100 * e[3].slice(0, e[3].indexOf(')')), 10))), a) if (a.match(startsRGBA)) e = a.split(COMMA), f = e[0].slice(e[0].indexOf('(') + 1), g = e[1], h = e[2];else {\n    switch (d = a.replace(cleanColorCode, BLANK).split(COMMA)[0], d.length) {\n      case 3:\n        d = d.charAt(0) + d.charAt(0) + d.charAt(1) + d.charAt(1) + d.charAt(2) + d.charAt(2);\n        break;\n\n      case 6:\n        break;\n\n      default:\n        d = (d + COLOR_WHITE).slice(0, 6);\n    }\n\n    f = parseInt(d.slice(0, 2), 16) || 0, g = parseInt(d.slice(2, 4), 16) || 0, h = parseInt(d.slice(4, 6), 16) || 0;\n  }\n  return b || 0 === b || (b = 100), 'string' == typeof b && (b = b.split(COMMA)[0]), b = parseInt(b, 10) / 100, 'rgba(' + f + COMMA + g + COMMA + h + COMMA + b + ')';\n}\n\nfunction getDarkColor(a, b) {\n  var c = Math.floor;\n  b = 0 > b || 100 < b ? 100 : b, b /= 100, a = a.replace(cleanColorCode, BLANK);\n  var d = parseInt(a, 16),\n      e = c(d / 65536),\n      f = c((d - 65536 * e) / 256);\n  return (COLOR_BLACK + (e * b << 16 | f * b << 8 | (d - 65536 * e - 256 * f) * b).toString(16)).slice(-6);\n}\n\nfunction getLightColor(a, b) {\n  var c = Math.floor;\n  b = 0 > b || 100 < b ? 100 : b, b /= 100, a = a.replace(cleanColorCode, BLANK);\n  var d = parseInt(a, 16),\n      e = c(d / 65536),\n      f = c((d - 65536 * e) / 256);\n  return (COLOR_BLACK + (256 - (256 - e) * b << 16 | 256 - (256 - f) * b << 8 | 256 - (256 - (d - 65536 * e - 256 * f)) * b).toString(16)).slice(-6);\n}\n\nfunction mapSymbolName(a, b) {\n  var c = symbolStr.circle;\n  return a = parsePointValue(a), 3 <= a && (c = (b ? symbolStr.spoke : symbolStr.poly) + a), c;\n}\n\nfunction getColumnColor(a, b, c, d, e, f, g, h, i) {\n  var j, k, l, m, n, o, p, q;\n  return l = a.split(COMMA), m = b.split(COMMA), n = f.split(COMMA), q = g.split(COMMA), a = a.replace(/\\s/g, BLANK).replace(/\\,$/, BLANK), i ? j = {\n    FCcolor: {\n      color: l[0],\n      alpha: m[0]\n    }\n  } : e ? (o = l[0], p = m[0], j = {\n    FCcolor: {\n      color: getDarkColor(o, 75) + COMMA + getLightColor(o, 10) + COMMA + getDarkColor(o, 90) + COMMA + getLightColor(o, 55) + COMMA + getDarkColor(o, 80),\n      alpha: p + COMMA + p + COMMA + p + COMMA + p + COMMA + p,\n      ratio: '0,11,14,57,18',\n      angle: h ? '90' : '0'\n    }\n  }, n = [getDarkColor(o, 70)]) : (b = parseAlpha(b, l.length), j = {\n    FCcolor: {\n      color: a,\n      alpha: b,\n      ratio: c,\n      angle: h ? -d : d\n    }\n  }), k = {\n    FCcolor: {\n      color: n[0],\n      alpha: q[0]\n    }\n  }, [j, k];\n}\n\nfunction getPointColor(a, b) {\n  var c, d, e;\n  return a = getFirstColor(a), b = getFirstAlpha(b), d = getLightColor(a, 70), e = getDarkColor(a, 50), c = {\n    FCcolor: {\n      gradientUnits: 'objectBoundingBox',\n      cx: .4,\n      cy: .4,\n      r: '100%',\n      color: d + COMMA + e,\n      alpha: b + COMMA + b,\n      ratio: BGRATIOSTRING,\n      radialGradient: !0\n    }\n  }, c;\n}\n\nfunction getAngle(a, b, c) {\n  var d = 180 * Math.atan(b / a) / Math.PI;\n  return 2 == c ? d = 180 - d : 3 == c ? d += 180 : 4 == c && (d = 360 - d), d;\n}\n\nfunction parseColor(a) {\n  return a.replace(cleanColorCode, BLANK).replace(dropHash, HASHSTRING);\n}\n\nfunction getValidColor(a) {\n  return validhexcolor.test(parseColor(a)) && a;\n}\n\nfunction RGBtoHex(a) {\n  return (COLOR_BLACK + (a[0] << 16 | a[1] << 8 | a[2]).toString(16)).slice(-6);\n}\n\nfunction rawRGBtoHEX(a) {\n  var b,\n      c = a.match(/[\\d+]+/g);\n  return b = c.splice(0, 3), (COLOR_BLACK + (b[0] << 16 | b[1] << 8 | b[2]).toString(16)).slice(-6);\n}\n\nfunction HEXtoRGB(a) {\n  var c = Math.floor,\n      d = parseInt(a, 16),\n      e = c(d / 65536),\n      f = c((d - 65536 * e) / 256),\n      g = c(d - 65536 * e - 256 * f);\n  return [e, f, g];\n}\n\nexport { convertColor, getDarkColor, getLightColor, mapSymbolName, getColumnColor, getPointColor, getAngle, parseColor, getValidColor, RGBtoHex, rawRGBtoHEX, HEXtoRGB, parsePointValue, getFirstColor, getFirstAlpha };","map":null,"metadata":{},"sourceType":"module"}