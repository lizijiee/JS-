{"ast":null,"code":"import { getArrayCopy, dashedAttr2CSSMap, loadRefImage, showRecursively } from './raphael.lib';\nexport default function (n) {\n  if (n.svg) {\n    var e = {\n      visibility: 'hidden',\n      \"font-size\": '0px'\n    },\n        t = String,\n        r = parseFloat,\n        i = parseInt,\n        o = {\n      top: 0,\n      bottom: -1,\n      middle: -.5\n    },\n        a = n._g.win,\n        s = a.navigator,\n        d = !!document.documentMode,\n        l = Math,\n        p = l.max,\n        c = l.abs,\n        h = l.pow,\n        f = l.sqrt,\n        u = /^xlink:/,\n        g = /[, ]+/,\n        y = /\\n|<br\\s*?\\/?>/i,\n        _ = /&lt|&gt|<br/i,\n        m = Array.prototype.shift,\n        v = !!(/AppleWebKit/.test(s.userAgent) && (!/Chrome/.test(s.userAgent) || 29 > s.appVersion.match(/Chrome\\/(\\d+)\\./)[1])),\n        b = n.eve,\n        w = !!s.platform && /iPad|iPhone|iPod/.test(s.platform),\n        x = {\n      block: 'M5,0 0,2.5 5,5z',\n      classic: 'M5,0 0,2.5 5,5 3.5,3 3.5,2z',\n      diamond: 'M2.5,0 5,2.5 2.5,5 0,2.5z',\n      open: 'M6,1 1,3.5 6,6',\n      oval: 'M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z'\n    },\n        k = {\n      speed: 'optimizeSpeed',\n      crisp: 'crispEdges',\n      precision: 'geometricPrecision'\n    },\n        C = s.userAgent.toLowerCase(),\n        A = function () {\n      var e = -1 != C.indexOf('msie') && parseInt(C.split('msie')[1]);\n      return !!(e && 9 === e);\n    }(),\n        S = n.supportsPointer,\n        L = n.supportsTouch,\n        E = {},\n        P = function P(e, t, r, i) {\n      n._preload(r[1], function () {\n        var r = this.offsetWidth,\n            a = this.offsetHeight;\n        O(e, {\n          width: r,\n          height: a\n        }), O(t, {\n          width: r,\n          height: a\n        }), i.safari();\n      });\n    },\n        B = function B(e, t) {\n      if (t) for (var r in t) {\n        e[r] = t[r];\n      }\n    },\n        N = {\n      elementInfo: []\n    },\n        T = n._g.doc,\n        a = n._g.win,\n        D = {\n      mouseover: 'touchstart',\n      mousedown: 'touchstart',\n      mouseup: 'touchend',\n      mousemove: 'touchmove',\n      mouseout: 'touchend'\n    };\n\n    L && T.addEventListener(S ? 'pointerover' : 'touchstart', function (t) {\n      if (N.srcElement && N.srcElement !== (t.srcElement || t.target)) {\n        var e,\n            r,\n            a,\n            e = N.elementInfo,\n            n = e.length;\n\n        for (a = 0; a < n; a++) {\n          r = e[a], r.callback.call(r.el, t);\n        }\n      }\n\n      N = {\n        elementInfo: []\n      };\n    }, !0), n.toString = function () {\n      return 'Your browser supports SVG.\\nYou are running Rapha\\xEBl ' + this.version;\n    }, n._url = '';\n\n    var I = function I(e, t) {\n      var r = e.gradient;\n\n      if (r) {\n        if (r === t) return;\n        r.refCount--, r.refCount || r.parentNode.removeChild(r), delete e.gradient;\n      }\n\n      t && (e.gradient = t, t.refCount++);\n    },\n        O = n._createNode = function (e, r) {\n      if ('string' == typeof e && (e = n._g.doc.createElementNS('http://www.w3.org/2000/svg', e)), r) {\n        var i, a;\n\n        for (i in r) {\n          a = A ? t(r[i]) : r[i], u.test(i) ? e.setAttributeNS('http://www.w3.org/1999/xlink', i.replace(u, ''), a) : e.setAttribute(i, a);\n        }\n      }\n\n      return e;\n    },\n        M = {\n      userSpaceOnUse: 'userSpaceOnUse',\n      objectBoundingBox: 'objectBoundingBox'\n    },\n        z = {\n      pad: 'pad',\n      redlect: 'reflect',\n      repeat: 'repeat'\n    },\n        R = function R(e, a) {\n      if (!e.paper || !e.paper.defs) return 0;\n\n      var d,\n          u,\n          g,\n          y,\n          _,\n          m,\n          v = 'linear',\n          w = e.paper,\n          x = n.getElementID((w.id + '-' + a).replace(/[()\\s%:,\\xb0#]/g, '_')),\n          b = .5,\n          k = .5,\n          C = e.node,\n          o = C.style,\n          s = n._g.doc.getElementById(x);\n\n      if (!s) {\n        if (a = t(a).replace(n._radial_gradient, function (e, t) {\n          v = 'radial', t = t ? t.split(',') : [], y = t[5], _ = t[6];\n          var i,\n              a,\n              n = t[0],\n              o = t[1],\n              s = t[2],\n              l = t[3],\n              p = t[4],\n              c = n && o;\n          return (s && (d = /%/.test(s) ? s : r(s)), y === M.userSpaceOnUse) ? (c && (b = n, k = o), l && p && (u = l, g = p, !c && (b = u, k = g)), '') : (c && (b = r(n), k = r(o), i = 2 * (.5 < k) - 1, .25 < (a = h(b - .5, 2)) + h(k - .5, 2) && .25 > a && (k = f(.25 - a) * i + .5) && .5 !== k && (k = k.toFixed(5) - 1e-5 * i)), l && p && (u = r(l), g = r(p), i = 2 * (.5 < g) - 1, .25 < (a = h(u - .5, 2)) + h(g - .5, 2) && .25 > a && (g = f(.25 - a) * i + .5) && .5 !== g && (g = g.toFixed(5) - 1e-5 * i), !c && (b = u, k = g)), '');\n        }), a = a.split(/\\s*-\\s*/), 'linear' == v) {\n          var A,\n              S = a.shift(),\n              L = S.match(/\\((.*)\\)/);\n          if (L = L && L[1] && L[1].split(/\\s*,\\s*/), S = -r(S), isNaN(S)) return null;\n          L && L.length ? (L[0] in M ? (y = L.shift(), L[0] in z && (_ = L.shift())) : (L[4] && (y = L[4]), L[5] && (_ = L[5])), m = [L[0] || '0%', L[1] || '0%', L[2] || '100%', L[3] || '0%']) : (m = [0, 0, l.cos(n.rad(S)), l.sin(n.rad(S))], A = 1 / (p(c(m[2]), c(m[3])) || 1), m[2] *= A, m[3] *= A, 0 > m[2] && (m[0] = -m[2], m[2] = 0), 0 > m[3] && (m[1] = -m[3], m[3] = 0));\n        }\n\n        var E = n._parseDots(a);\n\n        if (!E) return null;\n        s = O(v + 'Gradient', {\n          id: x\n        }), s.refCount = 0, y in M && s.setAttribute('gradientUnits', t(y)), _ in z && s.setAttribute('spreadMethod', t(_)), 'radial' == v ? (void 0 !== d && s.setAttribute('r', t(d)), void 0 !== u && void 0 !== g && (s.setAttribute('cx', t(u)), s.setAttribute('cy', t(g))), s.setAttribute('fx', t(b)), s.setAttribute('fy', t(k))) : O(s, {\n          x1: m[0],\n          y1: m[1],\n          x2: m[2],\n          y2: m[3]\n        });\n\n        for (var P = 0, B = E.length; P < B; P++) {\n          s.appendChild(O('stop', {\n            offset: E[P].offset ? E[P].offset : P ? '100%' : '0%',\n            \"stop-color\": E[P].color || '#fff',\n            \"stop-opacity\": void 0 === E[P].opacity ? 1 : E[P].opacity\n          }));\n        }\n\n        w.defs.appendChild(s);\n      }\n\n      return I(e, s), O(C, {\n        fill: 'url(\\'' + n._url + '#' + x + '\\')',\n        \"fill-opacity\": 1\n      }), o.fill = '', 1;\n    },\n        U = function U(e) {\n      var t = e.getBBox(1);\n      O(e.pattern, {\n        patternTransform: e.matrix.invert() + ' translate(' + t.x + ',' + t.y + ')'\n      });\n    },\n        H = function H(e, r, a) {\n      if ('path' == e.type) {\n        for (var o, s, d, l, c, f = t(r).toLowerCase().split('-'), u = e.paper, p = a ? 'end' : 'start', g = e.node, y = e.attrs, _ = y['stroke-width'], m = f.length, v = 'classic', b = 3, k = 3, C = 5; m--;) {\n          switch (f[m]) {\n            case 'block':\n            case 'classic':\n            case 'oval':\n            case 'diamond':\n            case 'open':\n            case 'none':\n              v = f[m];\n              break;\n\n            case 'wide':\n              k = 5;\n              break;\n\n            case 'narrow':\n              k = 2;\n              break;\n\n            case 'long':\n              b = 5;\n              break;\n\n            case 'short':\n              b = 2;\n          }\n        }\n\n        if ('open' == v ? (b += 2, k += 2, C += 2, d = 1, l = a ? 4 : 1, c = {\n          fill: 'none',\n          stroke: y.stroke\n        }) : (l = d = b / 2, c = {\n          fill: y.stroke,\n          stroke: 'none'\n        }), e._.arrows ? a ? (e._.arrows.endPath && E[e._.arrows.endPath]--, e._.arrows.endMarker && E[e._.arrows.endMarker]--) : (e._.arrows.startPath && E[e._.arrows.startPath]--, e._.arrows.startMarker && E[e._.arrows.startMarker]--) : e._.arrows = {}, 'none' != v) {\n          var A = 'raphael-marker-' + v,\n              S = 'raphael-marker-' + p + v + b + k + '-obj' + e.id;\n          n._g.doc.getElementById(A) ? E[A]++ : (u.defs.appendChild(O(O('path'), {\n            \"stroke-linecap\": 'round',\n            d: x[v],\n            id: A\n          })), E[A] = 1);\n\n          var L,\n              P = n._g.doc.getElementById(S);\n\n          P ? (E[S]++, L = P.getElementsByTagName('use')[0]) : (P = O(O('marker'), {\n            id: S,\n            markerHeight: k,\n            markerWidth: b,\n            orient: 'auto',\n            refX: l,\n            refY: k / 2\n          }), L = O(O('use'), {\n            \"xlink:href\": '#' + A,\n            transform: (a ? 'rotate(180 ' + b / 2 + ' ' + k / 2 + ') ' : '') + 'scale(' + b / C + ',' + k / C + ')',\n            \"stroke-width\": (1 / ((b / C + k / C) / 2)).toFixed(4)\n          }), P.appendChild(L), u.defs.appendChild(P), E[S] = 1), O(L, c);\n          var B = d * ('diamond' != v && 'oval' != v);\n          a ? (o = e._.arrows.startdx * _ || 0, s = n.getTotalLength(y.path) - B * _) : (o = B * _, s = n.getTotalLength(y.path) - (e._.arrows.enddx * _ || 0)), c = {}, c['marker-' + p] = 'url(\\'' + n._url + '#' + S + '\\')', (s || o) && (c.d = n.getSubpath(y.path, o, s)), O(g, c), e._.arrows[p + 'Path'] = A, e._.arrows[p + 'Marker'] = S, e._.arrows[p + 'dx'] = B, e._.arrows[p + 'Type'] = v, e._.arrows[p + 'String'] = r;\n        } else a ? (o = e._.arrows.startdx * _ || 0, s = n.getTotalLength(y.path) - o) : (o = 0, s = n.getTotalLength(y.path) - (e._.arrows.enddx * _ || 0)), e._.arrows[p + 'Path'] && O(g, {\n          d: n.getSubpath(y.path, o, s)\n        }), delete e._.arrows[p + 'Path'], delete e._.arrows[p + 'Marker'], delete e._.arrows[p + 'dx'], delete e._.arrows[p + 'Type'], delete e._.arrows[p + 'String'];\n\n        for (c in E) {\n          if (E.hasOwnProperty(c) && !E[c]) {\n            var N = n._g.doc.getElementById(c);\n\n            N && N.parentNode.removeChild(N);\n          }\n        }\n      }\n    },\n        F = {\n      \"\": ['none'],\n      none: ['none'],\n      \"-\": [3, 1],\n      \".\": [1, 1],\n      \"-.\": [3, 1, 1, 1],\n      \"-..\": [3, 1, 1, 1, 1, 1],\n      \". \": [1, 3],\n      \"- \": [4, 3],\n      \"--\": [8, 3],\n      \"- .\": [4, 3, 1, 3],\n      \"--.\": [8, 3, 1, 3],\n      \"--..\": [8, 3, 1, 3, 1, 3]\n    },\n        V = function V(e, t, r) {\n      if (void 0 !== t) {\n        var a,\n            o,\n            s,\n            d,\n            l,\n            p = F[t.toLowerCase && t.toLowerCase()];\n\n        if (t = p || [].concat(t), n.is(t, 'array')) {\n          if (o = r['stroke-width'] || e.attrs['stroke-width'] || 1, s = {\n            round: o,\n            square: o,\n            butt: 0\n          }[r['stroke-linecap'] || e.attrs['stroke-linecap']] || 0, d = t.length, l = p ? o : 1, 'none' === t[0]) a = t;else for (a = []; d--;) {\n            a[d] = t[d] * l + (d % 2 ? 1 : -1) * s, 0 >= a[d] && (a[d] = .01 + (1 >= o ? s : 0)), isNaN(a[d]) && (a[d] = 0);\n          }\n          return {\n            \"stroke-dasharray\": a.join(',')\n          };\n        }\n      }\n    },\n        G = n._setFillAndStroke = function (e, r) {\n      if (e.paper.canvas) {\n        var a,\n            o,\n            s,\n            d,\n            l,\n            h,\n            f = e.node,\n            u = e.attrs,\n            y = e.paper,\n            _ = {},\n            m = {};\n\n        for (o in 'image' === e.type && loadRefImage(e, r), r) {\n          if (o in n._availableAttrs) if (s = r[o], '' === s && o in u) delete u[o], f.removeAttribute('src' === o ? 'href' : o);else switch (u[o] = s, o) {\n            case 'blur':\n              e.blur(s);\n              break;\n\n            case 'href':\n            case 'title':\n            case 'target':\n              var w = f.parentNode;\n\n              if ('a' !== w.tagName.toLowerCase()) {\n                if ('' === s) break;\n                var x = O('a');\n                x.raphael = !0, x.raphaelid = f.raphaelid, w.insertBefore(x, f), x.appendChild(f), w = x;\n              }\n\n              'target' === o ? w.setAttributeNS('http://www.w3.org/1999/xlink', 'show', 'blank' === s ? 'new' : s) : w.setAttributeNS('http://www.w3.org/1999/xlink', o, s), f.titleNode = w;\n              break;\n\n            case 'cursor':\n              m.cursor = s;\n              break;\n\n            case 'transform':\n              e.transform(s);\n              break;\n\n            case 'rotation':\n              n.is(s, 'array') ? e.rotate.apply(e, s) : e.rotate(s);\n              break;\n\n            case 'arrow-start':\n              H(e, s);\n              break;\n\n            case 'arrow-end':\n              H(e, s, 1);\n              break;\n\n            case 'clip-path':\n              d = !0;\n\n            case 'clip-rect':\n              if (h = !d && t(s).split(g), e._.clipispath = !!d, d || 4 === h.length) {\n                e.clip && e.clip.parentNode.parentNode.removeChild(e.clip.parentNode);\n                var b = O(d ? 'path' : 'rect');\n                a = O('clipPath'), a.id = n.getElementID(n.createUUID()), O(b, d ? {\n                  d: s ? u['clip-path'] = n._pathToAbsolute(s) : n._availableAttrs.path,\n                  fill: 'none'\n                } : {\n                  x: h[0],\n                  y: h[1],\n                  width: h[2],\n                  height: h[3],\n                  transform: e.matrix.invert()\n                }), a.appendChild(b), y.defs.appendChild(a), _['clip-path'] = 'url(\\'' + n._url + '#' + a.id + '\\')', e.clip = b;\n              }\n\n              if (!s) {\n                var C = f.getAttribute('clip-path');\n\n                if (C) {\n                  var A = n._g.doc.getElementById(C.replace(/(^url\\(#|\\)$)/g, ''));\n\n                  A && A.parentNode.removeChild(A), _['clip-path'] = '', 11 === document.documentMode && f.removeAttribute('clip-path'), delete e.clip;\n                }\n              }\n\n              break;\n\n            case 'path':\n              'path' === e.type && (_.d = s ? u.path = n._stopabsolutePath ? n.sanitizePath(s) : n._pathToAbsolute(s) : n._availableAttrs.path, e._.dirty = 1, e._.arrows && ('startString' in e._.arrows && H(e, e._.arrows.startString), 'endString' in e._.arrows && H(e, e._.arrows.endString, 1)));\n              break;\n\n            case 'width':\n              if (_[o] = s, e._.dirty = 1, u.fx) o = 'x', s = u.x;else break;\n\n            case 'x':\n              u.fx && (s = -u.x - (u.width || 0));\n\n            case 'rx':\n              if ('rx' === o && 'rect' === e.type) break;\n\n            case 'cx':\n              _[o] = s, e.pattern && U(e), e._.dirty = 1;\n              break;\n\n            case 'height':\n              if (_[o] = s, e._.dirty = 1, u.fy) o = 'y', s = u.y;else break;\n\n            case 'y':\n              if ('text' === e.type) break;\n              u.fy && (s = -u.y - (u.height || 0));\n\n            case 'ry':\n              if ('ry' === o && 'rect' === e.type) break;\n\n            case 'cy':\n              _[o] = s, e.pattern && U(e), e._.dirty = 1;\n              break;\n\n            case 'r':\n              'rect' === e.type ? _.rx = _.ry = s : _[o] = s, e._.dirty = 1;\n              break;\n\n            case 'src':\n              'image' === e.type && f.setAttributeNS('http://www.w3.org/1999/xlink', 'href', s);\n              break;\n\n            case 'stroke-width':\n              (1 !== e._.sx || 1 !== e._.sy) && (s /= p(c(e._.sx), c(e._.sy)) || 1), y._vbSize && (s *= y._vbSize), v && 0 === s && (s = 1e-6), _[o] = s, !r['stroke-dasharray'] && u['stroke-dasharray'] && B(_, V(e, u['stroke-dasharray'], r)), e._.arrows && ('startString' in e._.arrows && n.addArrow && n.addArrow(e, e._.arrows.startString), 'endString' in e._.arrows && n.addArrow && n.addArrow(e, e._.arrows.endString, 1));\n              break;\n\n            case 'stroke-dasharray':\n              B(_, V(e, s, r));\n              break;\n\n            case 'fill':\n              var S = n._ISURL.test(s);\n\n              if (S) {\n                l = s.split(n._ISURL), a = O('pattern');\n                var L = O('image');\n                a.id = n.getElementID(n.createUUID()), O(a, {\n                  x: 0,\n                  y: 0,\n                  patternUnits: 'userSpaceOnUse',\n                  height: 1,\n                  width: 1\n                }), O(L, {\n                  x: 0,\n                  y: 0,\n                  \"xlink:href\": l[1]\n                }), a.appendChild(L), P(a, L, l, y), y.defs.appendChild(a), _.fill = 'url(\\'' + n._url + l[1] + '\\')', e.pattern = a, e.pattern && U(e);\n                break;\n              }\n\n              var E = n.getRGB(s);\n              if (!E.error) delete r.gradient, delete u.gradient, !n.is(u['fill-opacity'], 'undefined') && n.is(r['fill-opacity'], 'undefined') && (_['fill-opacity'] = u['fill-opacity']), e.gradient && I(e);else if (('circle' === e.type || 'ellipse' === e.type || 'r' !== t(s).charAt()) && R(e, s)) {\n                u.gradient = s;\n                break;\n              }\n              E.hasOwnProperty('opacity') ? (_['fill-opacity'] = 1 < E.opacity ? E.opacity / 100 : E.opacity, e._.fillOpacityDirty = !0) : e._.fillOpacityDirty && n.is(u['fill-opacity'], 'undefined') && n.is(r['fill-opacity'], 'undefined') && (f.removeAttribute('fill-opacity'), delete e._.fillOpacityDirty);\n\n            case 'stroke':\n              E = n.getRGB(s), _[o] = E.hex, 'stroke' === o && (E.hasOwnProperty('opacity') ? (_['stroke-opacity'] = 1 < E.opacity ? E.opacity / 100 : E.opacity, e._.strokeOpacityDirty = !0) : e._.strokeOpacityDirty && n.is(u['stroke-opacity'], 'undefined') && n.is(r['stroke-opacity'], 'undefined') && (f.removeAttribute('stroke-opacity'), delete e._.strokeOpacityDirty), e._.arrows && ('startString' in e._.arrows && H(e, e._.arrows.startString), 'endString' in e._.arrows && H(e, e._.arrows.endString, 1)));\n              break;\n\n            case 'gradient':\n              ('circle' === e.type || 'ellipse' === e.type || 'r' !== t(s).charAt()) && R(e, s);\n              break;\n\n            case 'visibility':\n              'hidden' === s ? e.hide() : e.show();\n              break;\n\n            case 'opacity':\n              s = 1 < s ? s / 100 : s, _.opacity = s;\n              break;\n\n            case 'fill-opacity':\n              s = 1 < s ? s / 100 : s, _['fill-opacity'] = s;\n              break;\n\n            case 'shape-rendering':\n              e.attrs[o] = s = k[s] || s || 'auto', _[o] = s, f.style.shapeRendering = s;\n              break;\n\n            case 'line-height':\n            case 'vertical-align':\n              break;\n\n            default:\n              'font-size' === o && (s = i(s, 10) + 'px'), e._.dirty = 1, _[o] = s, dashedAttr2CSSMap[o] && (m[dashedAttr2CSSMap[o]] = s);\n          }\n        }\n\n        for (o in m) {\n          f.style[o] = m[o];\n        }\n\n        for (o in _) {\n          f.setAttribute(o, _[o]);\n        }\n\n        'text' !== e.type || r['_do-not-tune'] || j(e, r);\n      }\n    },\n        Y = n._updateFollowers = function () {\n      var e,\n          t,\n          r,\n          a = getArrayCopy(arguments),\n          n = m.call(a),\n          o = m.call(a);\n\n      for (e = 0, t = n.followers.length; e < t; e++) {\n        r = n.followers[e].el, r[o].apply(r, a);\n      }\n    },\n        j = function j(s, p) {\n      if ('text' === s.type && (p.hasOwnProperty('text') || p.hasOwnProperty('font') || p.hasOwnProperty('font-size') || p.hasOwnProperty('x') || p.hasOwnProperty('y') || p.hasOwnProperty('line-height') || p.hasOwnProperty('vertical-align'))) {\n        var c,\n            h,\n            f,\n            u,\n            g,\n            m,\n            v,\n            w,\n            x,\n            b,\n            k,\n            C = s.attrs,\n            a = s.parent,\n            A = s.node,\n            S = s._oldAttr = s._oldAttr || {\n          baseLineDiff: 8,\n          valign: -.5\n        },\n            L = r(p['line-height'] || C['line-height']),\n            E = p.direction || C.direction || a && a.attrs && a.attrs.direction || S.direction || 'initial',\n            P = !1,\n            B = !1,\n            N = d || 'rtl' !== E ? 1 : 2,\n            T = !1,\n            D = !1,\n            I = !d && S.direction && E !== S.direction;\n        if (S.direction = E, L || (c = p.fontSize || p['font-size'] || C['font-size'] || a && a.attrs && a.attrs.fontSize, c = c ? c.toString().replace('px', '') : 10, L = c * 1.2), p.hasOwnProperty('text') && (k = n.is(p.text, 'array') ? p.text.join('<br>') : p.text, k !== S.text && (D = !0, k && _.test(k) && (k = k.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&<br\\/>lt;|&l<br\\/>t;|&lt<br\\/>;/g, '<<br/>').replace(/&<br\\/>gt;|&g<br\\/>t;|&gt<br\\/>;/g, '><br/>')), S.text = C.text = k, y.test(k) ? (S.noTSpan && (S.noTSpan = !(I = !0)), v = t(k).split(y), g = v.length) : (I = !0, S.noTSpan = !0, g = 1), S.lineCount !== g && (S.lineCount = g, T = !0))), L !== S.lineHeight && (S.lineHeight = L, S.baseLineDiff = .75 * L, T = !0), I) for (; A.firstChild;) {\n          A.removeChild(A.firstChild);\n        }\n        if (!(1 < S.lineCount)) D && A.appendChild(n._g.doc.createTextNode(k));else if (f = {}, S.tspanAttr || (S.tspanAttr = {}, S.tspan0Attr = {}), S.tspanAttr.dy !== S.lineHeight && (S.tspanAttr.dy = f.dy = S.lineHeight, B = !0), p.hasOwnProperty('x') && S.tspanAttr.x !== p.x && (S.tspan0Attr.x = S.tspanAttr.x = f.x = C.x, B = !0), D) {\n          for (b = A.getElementsByTagName('tspan'), u = 0; u < g; u++) {\n            if (x = b[u * N], x) {\n              if (x.innerHTML = '', d) for (; x.firstChild;) {\n                x.removeChild(x.firstChild);\n              }\n              B && O(x, u ? f : S.tspan0Attr);\n            } else x = O('tspan', u ? S.tspanAttr : S.tspan0Attr), A.appendChild(x), d || 'rtl' !== E || (w = O('tspan', e), w.appendChild(n._g.doc.createTextNode('i')), A.appendChild(w));\n\n            v[u] || (x.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve'), v[u] = ' '), x.appendChild(n._g.doc.createTextNode(v[u]));\n          }\n\n          if (m = g * N, b.length > m) for (u = b.length - 1; u >= m; u -= 1) {\n            A.removeChild(b[u]);\n          }\n        } else if (B) for (b = A.getElementsByTagName('tspan'), m = b.length, u = 0; u < m; u += N) {\n          O(b[u], u ? f : S.tspan0Attr);\n        }\n        p['vertical-align'] && (h = o[C['vertical-align']] || 0, h !== S.valign && (S.valign = h, T = !0)), T && (S.shift = S.baseLineDiff + S.lineCount * S.lineHeight * S.valign, P = !0), (p.y || 0 === p.y) && S.y !== p.y && (S.y = C.y, P = !0), P && (S.y || 0 === S.y) && (S.shift || 0 === S.shift) && O(A, {\n          y: Math.round(S.y + S.shift)\n        });\n      }\n    },\n        X = function X(e, t, r) {\n      var i = this,\n          a = r || t;\n      a.canvas && a.canvas.appendChild(e), i.node = i[0] = e, e.raphael = !0, e.raphaelid = i.id = n._oid++, i.matrix = n.matrix(), i.realPath = null, i.attrs = i.attrs || {}, i.followers = i.followers || [], i.paper = t, i.ca = i.customAttributes = i.customAttributes || new t._CustomAttributes(), i._ = {\n        transform: [],\n        sx: 1,\n        sy: 1,\n        deg: 0,\n        dx: 0,\n        dy: 0,\n        dirty: 1\n      }, i.parent = a, a.bottom || (a.bottom = i), i.prev = a.top, a.top && (a.top.next = i), a.top = i, i.next = null;\n    },\n        W = function W(e, t, r) {\n      var i = r ? 'pageY' : 'pageX';\n      return Math.abs(t[i] - e[i]);\n    },\n        q = n.storeHandlers = function (e, t, r) {\n      e._actualListners || (e._actualListners = []), e._derivedListeners || (e._derivedListeners = []), e._actualListners.push(t), e._derivedListeners.push(r);\n    },\n        Q = function Q(e, t) {\n      var r,\n          i = e._actualListners.indexOf(t);\n\n      return -1 !== i && (r = e._derivedListeners[i], e._actualListners.splice(i, 1), e._derivedListeners.splice(i, 1)), r;\n    },\n        J = n.el;\n\n    X.prototype = J, J.constructor = X, n._engine.getNode = function (e) {\n      var t = e.node || e[0].node;\n      return t.titleNode || t;\n    }, n._engine.getLastNode = function (e) {\n      var t = e.node || e[e.length - 1].node;\n      return t.titleNode || t;\n    }, J.rotate = function (e, i, a) {\n      var n,\n          s = this;\n      return s.removed ? s : (Y(s, 'rotate', e, i, a), e = t(e).split(g), e.length - 1 && (i = r(e[1]), a = r(e[2])), e = r(e[0]), null == a && (i = a), (null == i || null == a) && (n = s.getBBox(1), i = n.x + n.width / 2, a = n.y + n.height / 2), s.transform(s._.transform.concat([['r', e, i, a]])), s);\n    }, J.scale = function (e, i, a, n) {\n      var s,\n          d = this;\n      return d.removed ? d : (Y(d, 'scale', e, i, a, n), e = t(e).split(g), e.length - 1 && (i = r(e[1]), a = r(e[2]), n = r(e[3])), e = r(e[0]), null == i && (i = e), null == n && (a = n), (null == a || null == n) && (s = d.getBBox(1)), a = null == a ? s.x + s.width / 2 : a, n = null == n ? s.y + s.height / 2 : n, d.transform(d._.transform.concat([['s', e, i, a, n]])), d);\n    }, J.translate = function (e, i) {\n      var a = this;\n      return a.removed ? a : (Y(a, 'translate', e, i), e = t(e).split(g), e.length - 1 && (i = r(e[1])), e = r(e[0]) || 0, i = +i || 0, a.transform(a._.transform.concat([['t', e, i]])), a);\n    }, J.transform = function (e) {\n      var t,\n          r = this,\n          i = r._;\n      return null == e ? i.transform : (n._extractTransform(r, e), r.clip && !i.clipispath && O(r.clip, {\n        transform: r.matrix.invert()\n      }), r.pattern && U(r), r.node && O(r.node, {\n        transform: r.matrix\n      }), (1 !== i.sx || 1 !== i.sy) && (t = r.attrs['stroke-width'], t && r.attr({\n        \"stroke-width\": t\n      })), r);\n    }, J.hide = function () {\n      var e = this;\n      return Y(e, 'hide'), e.removed || e.paper.safari(e.node.style.display = 'none'), e;\n    }, J.show = function () {\n      var e = this;\n      return Y(e, 'show'), e.removed || e.paper.safari(e.node.style.display = ''), e;\n    }, J.remove = function () {\n      if (!this.removed && this.parent.canvas) {\n        var e,\n            t = this,\n            r = n._engine.getNode(t),\n            a = t.paper,\n            o = a.defs;\n\n        for (a.__set__ && a.__set__.exclude(t), b.unbind('raphael.*.*.' + t.id), t.gradient && o && I(t); e = t.followers.pop();) {\n          e.el.remove();\n        }\n\n        for (; e = t.bottom;) {\n          e.remove();\n        }\n\n        if (t._drag && t.undrag(), t.events) for (; e = t.events.pop();) {\n          e.unbind();\n        }\n\n        for (e in t.parent.canvas.contains(r) && t.parent.canvas.removeChild(r), t.removeData(), delete a._elementsById[t.id], n._tear(t, t.parent), t) {\n          t[e] = 'function' == typeof t[e] ? n._removedFactory(e) : null;\n        }\n\n        t.removed = !0;\n      }\n    }, J._getBBox = function () {\n      var e,\n          t,\n          r,\n          i = this,\n          n = i.node,\n          o = {},\n          s = i.attrs,\n          a = 'text' === i.type;\n      d && a ? e = showRecursively(i) : 'none' === n.style.display && (i.show(), r = !0);\n\n      try {\n        o = n.getBBox(), a && (void 0 === o.x && (o.isCalculated = !0, t = s['text-anchor'], o.x = (s.x || 0) - o.width * ('start' === t ? 0 : 'middle' === t ? .5 : 1)), void 0 === o.y && (o.isCalculated = !0, t = s['vertical-align'], o.y = (s.y || 0) - o.height * ('bottom' === t ? 1 : 'middle' === t ? .5 : 0)));\n      } catch (t) {} finally {\n        o = o || {};\n      }\n\n      return d && a ? e && e() : r && i.hide(), o;\n    }, J.attr = function (e, t) {\n      if (this.removed) return this;\n      var r,\n          a,\n          o,\n          s,\n          d,\n          l,\n          p,\n          c,\n          h = this,\n          f = this.attrs,\n          u = {},\n          g = h._invokedCa || (h._invokedCa = {}),\n          y = this.ca;\n\n      if (null == e) {\n        var _ = {};\n\n        for (r in f) {\n          f.hasOwnProperty(r) && (_[r] = f[r]);\n        }\n\n        return _.gradient && 'none' === _.fill && (_.fill = _.gradient) && delete _.gradient, _.transform = this._.transform, _.visibility = 'none' === this.node.style.display ? 'hidden' : 'visible', _;\n      }\n\n      if (null != t) s = {}, s[e] = t;else if (n.is(e, 'object')) s = e;else if (n.is(e, 'string')) return 'fill' === e && 'none' === f.fill && f.gradient ? f.gradient : 'transform' === e ? this._.transform : 'visibility' === e ? 'none' === this.node.style.display ? 'hidden' : 'visible' : e in f ? f[e] : n.is(y[e], 'function') ? y[e].def : n._availableAttrs[e];\n      if (!n.stopPartialEventPropagation) for (r in s) {\n        b('raphael.attr.' + r + '.' + this.id, this, s[r], r);\n      }\n\n      for (r in s) {\n        if (c = y[r], c && !g[r] && n.is(c, 'function')) {\n          for (d in g[r] = !0, l = c.apply(this, [].concat(s[r])), g[r] = !1, l) {\n            u[d] = l[d];\n          }\n\n          f[r] = s[r];\n        } else u[r] = s[r];\n      }\n\n      for (G(this, u), a = 0, o = this.followers.length; a < o; a++) {\n        p = this.followers[a], p.cb && !p.cb.call(p.el, u, this) || p.el.attr(u);\n      }\n\n      return this;\n    }, J.pinchstart = function (t, r) {\n      var i = this,\n          a = {},\n          e = function e(o) {\n        if (o.touches && 2 === o.touches.length) {\n          var _e = o.touches[0],\n              _s = o.touches[1];\n          i._blockDrag = !0, o && o.preventDefault(), n.makeSelectiveCopy(a, o), a.data = {\n            finger0: _e,\n            finger1: _s,\n            distanceX: W(_e, _s),\n            distanceY: W(_e, _s, !0)\n          }, t.call(r || i, a);\n        } else i._blockDrag = !1;\n      };\n\n      q(i, t, e), i.node.addEventListener('touchstart', e);\n    }, J.unpinchstart = function (e) {\n      var t = this,\n          r = Q(t, e);\n      t.__blockDrag = !1, t._pinchDragStarted = !1, r && t.node.removeEventListener('touchstart', r);\n    }, J.pinchmove = function (t, r) {\n      var i = this,\n          a = {},\n          e = function e(o) {\n        if (o.touches && 2 === o.touches.length) {\n          var _e2 = o.touches[0],\n              _s2 = o.touches[1];\n          o && o.preventDefault(), i._pinchDragStarted = !0, n.makeSelectiveCopy(a, o), a.data = {\n            finger0: _e2,\n            finger1: _s2,\n            distanceX: W(_e2, _s2),\n            distanceY: W(_e2, _s2, !0)\n          }, t.call(r || i, a);\n        }\n      };\n\n      q(i, t, e), i.node.addEventListener('touchmove', e);\n    }, J.unpinchmove = function (e) {\n      var t = this,\n          r = Q(t, e);\n      r && t.node.removeEventListener('touchmove', r);\n    }, J.pinchend = function (t, r) {\n      var i = this,\n          e = function e(a) {\n        i._pinchDragStarted && (i._pinchDragStarted = !1, t.call(r || i, a));\n      };\n\n      q(i, t, e), i.node.addEventListener('touchend', e);\n    }, J.unpinchend = function (e) {\n      var t = this,\n          r = Q(t, e);\n      t._pinchDragStarted = !1, r && t.node.removeEventListener('touchend', r);\n    }, J.pinch = function (e, t, r) {\n      J.pinchstart.call(this, e), J.pinchin.call(this, t), J.pinchend.call(this, r);\n    }, J.unpinch = function (e, t, r) {\n      J.unpinchstart.call(this, e), J.unpinchin.call(this, t), J.unpinchend.call(this, r);\n    }, J.fcwheel = function (t, r) {\n      var i = this,\n          a = {},\n          e = function e(o) {\n        o && o.preventDefault(), n.makeSelectiveCopy(a, o), t.call(r || i, a);\n      };\n\n      q(i, t, e), i.node.addEventListener('wheel', e);\n    }, J.fcunwheel = function (e) {\n      var t = this,\n          r = Q(t, e);\n      r && t.node.removeEventListener('wheel', r);\n    }, J.on = function (e, t, r) {\n      if (t && e) {\n        var i,\n            a,\n            o = this,\n            s = e.match(/fc-/),\n            d = t;\n        if (this.removed) return this;\n\n        switch (o._actualListners || (o._actualListners = []), o._derivedListeners || (o._derivedListeners = []), e) {\n          case 'fc-dragstart':\n            return o.drag(null, t), o;\n\n          case 'fc-dragmove':\n            return o.drag(t), o;\n\n          case 'fc-dragend':\n            return o.drag(null, null, t), o;\n\n          case 'fc-dbclick':\n            return o.dbclick(t, r), o;\n\n          case 'fc-pinchstart':\n            return o.pinchstart(t, r), o;\n\n          case 'fc-pinchmove':\n            return o.pinchmove(t, r), o;\n\n          case 'fc-pinchend':\n            return o.pinchend(t, r), o;\n\n          case 'fc-click':\n            return o.fcclick(t, r), o;\n\n          case 'fc-wheel':\n            return o.fcwheel(t, r), o;\n        }\n\n        return s && (e = e.replace(/fc-/, '')), s && L && (a = e, e = (S ? n.safePointerEventMapping[e] : D[e]) || e, 'mouseout' === a && (d = function d(i) {\n          S && L && !i.isPrimary || (N.elementInfo.push({\n            el: r || o,\n            callback: t\n          }), N.srcElement = i.srcElement || i.target);\n        }, e = S ? 'pointerover' : 'touchstart')), this._ && this._.RefImg && ('load' === e || 'error' === e) ? (i = this._.RefImg, d = function d(r) {\n          S && L && !r.isPrimary || o.removed || t.call(o, r);\n        }) : i = this.node, d === t && (d = function d(i) {\n          S && L && !i.isPrimary || t.call(r || o, i);\n        }), o._actualListners.push(t), o._derivedListeners.push(d), i.addEventListener ? i.addEventListener(e, d) : i['on' + e] = d, this;\n      }\n    }, J.off = function (e, t) {\n      var r,\n          i,\n          a,\n          o = this,\n          s = t,\n          d = e.match(/fc-/);\n      if (this.removed || !o._actualListners || !e || !t) return this;\n      return 'fc-dragstart' === e ? (o.undragstart(t), o) : 'fc-dragmove' === e ? (o.undragmove(t), o) : 'fc-dragend' === e ? (o.undragend(t), o) : 'fc-dbclick' === e ? (o.undbclick(t), o) : 'fc-pinchstart' === e ? (o.unpinchstart(t), o) : 'fc-pinchmove' === e ? (o.unpinchmove(t), o) : 'fc-pinchend' === e ? (o.unpinchend(t), o) : 'fc-click' === e ? (o.fcunclick(t), o) : 'fc-wheel' === e ? (o.fcunwheel(t), o) : (d && (e = e.replace(/fc-/, '')), s = t, d && L && (r = e, e = (S ? n.safePointerEventMapping[e] : D[e]) || e, 'mouseout' === r && (e = S ? 'pointerover' : 'touchstart')), a = this._ && this._.RefImg ? this._.RefImg : this.node, i = o._actualListners.indexOf(s), -1 !== i && (s = o._derivedListeners[i], o._actualListners.splice(i, 1), o._derivedListeners.splice(i, 1)), a.removeEventListener ? a.removeEventListener(e, s) : a['on' + e] = null, this);\n    }, n._engine.path = function (e, t, r) {\n      var i = O('path'),\n          a = new X(i, e, r);\n      return a.type = 'path', t && a.attr(t), a;\n    }, n._engine.group = function (e, t, r) {\n      var i = O('g'),\n          a = new X(i, e, r);\n      return a.type = 'group', a.canvas = a.node, a.top = a.bottom = null, a._id = t || '', t && i.setAttribute('class', 'raphael-group-' + a.id + '-' + t), a;\n    }, n._engine.circle = function (e, t, r) {\n      var i = O('circle'),\n          a = new X(i, e, r);\n      return a.type = 'circle', t && a.attr(t), a;\n    }, n._engine.rect = function (e, t, r) {\n      var i = O('rect'),\n          a = new X(i, e, r);\n      return a.type = 'rect', t.rx = t.ry = t.r, t && a.attr(t), a;\n    }, n._engine.ellipse = function (e, t, r) {\n      var i = O('ellipse'),\n          a = new X(i, e, r);\n      return a.type = 'ellipse', t && a.attr(t), a;\n    }, n._engine.image = function (e, t, r) {\n      var i = O('image'),\n          a = new X(i, e, r, !0);\n      return a._.group = r || e, a.type = 'image', i.setAttribute('preserveAspectRatio', 'none'), t && a.attr(t), a;\n    }, n._engine.text = function (e, t, r, i) {\n      var a = O('text'),\n          n = new X(a, e, r);\n      return n.type = 'text', i && n.css && n.css(i, void 0, !0), t && n.attr(t), n;\n    }, n._engine.setSize = function (e, t) {\n      return this.width = e || this.width, this.height = t || this.height, this.canvas.setAttribute('width', this.width), this.canvas.setAttribute('height', this.height), this._viewBox && this.setViewBox.apply(this, this._viewBox), this;\n    }, n._engine.create = function () {\n      var e,\n          t = n._getContainer.apply(0, arguments),\n          r = t && t.container,\n          i = t.x,\n          a = t.y,\n          o = t.width,\n          s = t.height;\n\n      if (!r) throw new Error('SVG container not found.');\n      var d,\n          l = O('svg'),\n          p = 'overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-moz-user-select:-moz-none;-khtml-user-select:none;-ms-user-select:none;user-select:none;-o-user-select:none;cursor:default;vertical-align:middle;';\n      return L && (n.isEdge ? p += 'touch-action:none;' : n.isFirefox && n.isWindows ? p += 'touch-action:none;' : n.isIE11 && (p += '-ms-touch-action:none;')), i = i || 0, a = a || 0, o = o || 512, s = s || 342, O(l, {\n        height: s,\n        version: 1.1,\n        width: o,\n        xmlns: 'http://www.w3.org/2000/svg'\n      }), 1 === r ? (l.style.cssText = p + 'position:absolute;left:' + i + 'px;top:' + a + 'px', r = n._g.doc.body, r.appendChild(l), d = 1) : (l.style.cssText = p + 'position:relative', r.firstChild ? r.insertBefore(l, r.firstChild) : r.appendChild(l)), e = new n._Paper(), e.width = o, e.height = s, e.canvas = l, e.container = r, O(l, {\n        id: 'raphael-paper-' + e.id\n      }), e.clear(), e._left = e._top = 0, d && (e.renderfix = function () {}), e.renderfix(), e;\n    }, n._engine.setViewBox = function (e, t, r, i, a) {\n      b('raphael.setViewBox', this, this._viewBox, [e, t, r, i, a]);\n      var n,\n          o,\n          s = p(r / this.width, i / this.height),\n          d = this.top,\n          l = a ? 'meet' : 'xMinYMin';\n      if (null == e ? (this._vbSize && (s = 1), delete this._vbSize, n = '0 0 ' + this.width + ' ' + this.height) : (this._vbSize = s, n = e + ' ' + t + ' ' + r + ' ' + i), O(this.canvas, {\n        viewBox: n,\n        preserveAspectRatio: l\n      }), s) for (; d;) {\n        o = 'stroke-width' in d.attrs ? d.attrs['stroke-width'] : 1, d.attr({\n          \"stroke-width\": o\n        }), d._.dirty = 1, d._.dirtyT = 1, d = d.prev;\n      }\n      return this._viewBox = [e, t, r, i, !!a], this;\n    }, n.prototype.detachPaper = function () {\n      !1 !== this._detached && (this.container.removeChild(this.canvas), this._detached = !0);\n    }, n.prototype.attachPaper = function () {\n      this._detached && (this.container.appendChild(this.canvas), this._detached = !1);\n    }, n.prototype.renderfix = function () {\n      var e,\n          t = this.canvas,\n          r = t.style;\n\n      try {\n        e = t.getScreenCTM() || t.createSVGMatrix();\n      } catch (r) {\n        e = t.createSVGMatrix();\n      }\n\n      var i = -e.e % 1,\n          a = -e.f % 1;\n      (i || a) && (i && (this._left = (this._left + i) % 1, r.left = this._left + 'px'), a && (this._top = (this._top + a) % 1, r.top = this._top + 'px'));\n    }, n.prototype._desc = function (e) {\n      var t = this.desc;\n      if (!t) this.desc = t = O('desc'), this.canvas.appendChild(t);else for (; t.firstChild;) {\n        t.removeChild(t.firstChild);\n      }\n      t.appendChild(n._g.doc.createTextNode(n.is(e, 'string') ? e : 'Created with Red Rapha\\xEBl ' + n.version));\n    }, n.prototype.clear = function () {\n      var e;\n\n      for (b('raphael.clear', this); e = this.bottom;) {\n        e.remove();\n      }\n\n      for (e = this.canvas; e.firstChild;) {\n        e.removeChild(e.firstChild);\n      }\n\n      this.bottom = this.top = null, e.appendChild(this.desc = O('desc')), e.appendChild(this.defs = O('defs'));\n    }, n.prototype.remove = function () {\n      for (b('raphael.remove', this); e = this.bottom;) {\n        e.remove();\n      }\n\n      for (var e in this.defs && this.defs.parentNode.removeChild(this.defs), this.desc && this.desc.parentNode.removeChild(this.desc), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this) {\n        this[e] = 'function' == typeof this[e] ? n._removedFactory(e) : null;\n      }\n\n      this.removed = !0;\n    }, n.prototype.setHTMLClassName = function () {};\n  }\n}","map":null,"metadata":{},"sourceType":"module"}