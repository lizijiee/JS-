{"ast":null,"code":"import _classCallCheck from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"F:\\\\App Store\\\\Coding\\\\Github_Download\\\\JS-\\\\React\\u9879\\u76EE\\\\react-mall\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { ComponentInterface } from '../../../../../fc-core/src/component-interface';\nimport { pluckNumber, pluck, preDefStr, toRaphaelColor, chartPaletteStr, canvasBorderColorStr, canvasBGAlphaStr, convertColor } from '../../../../../fc-core/src/lib';\nimport { addDep } from '../../../../../fc-core/src/dependency-manager';\nimport canvasAnimation from './canvas.animation';\n\nvar mathMax = Math.max,\n    MAX_MITER_LINEJOIN = 2,\n    miterStr = preDefStr.miterStr,\n    NONE = preDefStr.noneStr,\n    ROUND = preDefStr.ROUND,\n    clipSumValue = 'clip-sum-value',\n    clipCanvasInitStr = 'clip-canvas-init',\n    clipCanvasStr = 'clip-canvas',\n    _createGroup = function createGroup(a, b, c) {\n  var d = c.getFromEnv('animationManager');\n  return d.setAnimation({\n    el: 'group',\n    attr: {\n      name: a\n    },\n    container: b,\n    component: c,\n    label: 'group'\n  });\n};\n\naddDep({\n  name: 'canvasAnimation',\n  type: 'animationRule',\n  extension: canvasAnimation\n});\n\nvar Canvas =\n/*#__PURE__*/\nfunction (_ComponentInterface) {\n  _inherits(Canvas, _ComponentInterface);\n\n  function Canvas() {\n    var _this;\n\n    _classCallCheck(this, Canvas);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Canvas).call(this));\n\n    var a = _assertThisInitialized(_this);\n\n    a.config = {}, a.config.axes = a.config.axes || [], a.setLinkedItem('axes', []), a.setLinkedItem('primaryAxis', {}), a.addToEnv('canvasConfig', _this.config);\n    return _this;\n  }\n\n  _createClass(Canvas, [{\n    key: \"getName\",\n    value: function getName() {\n      return 'canvas';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'canvas';\n    }\n  }, {\n    key: \"createGroup\",\n    value: function createGroup() {\n      var a = this,\n          b = a.getFromEnv('chart'),\n          c = b.getChildContainer(),\n          d = b.getContainer('parentgroup'),\n          e = a.getEffectiveDimensions(),\n          f = a.getFromEnv('chart-attrib'),\n          g = pluckNumber(f.areaovercolumns, 1),\n          h = a.getChildContainer('axisReferenceVisualsFloor'),\n          i = a.getChildContainer('axisReferenceVisualsBottom'),\n          j = a.getChildContainer('axisReferenceVisualsMiddle'),\n          k = a.getChildContainer('axisReferenceVisualsTop'),\n          l = a.getChildContainer('axisReferenceVisualsCeil'),\n          m = a.getChildContainer('areaGroup'),\n          n = a.getChildContainer('areaShadowGroup'),\n          o = a.getChildContainer('columnGroup'),\n          p = a.getChildContainer('columnShadowGroup'),\n          q = c.plotGroup,\n          r = [e.left, e.top, e.width, e.height].toString();\n      a.getContainer('canvasGroup') || a.addContainer('canvasGroup', _createGroup('canvas', d, a)).insertAfter(c.backgroundGroup), i || (i = a.addChildContainer('axisReferenceVisualsBottom', _createGroup('axisReferenceVisualsBottom', d, a)).insertAfter(c.axisBottomGroup)), h || (h = a.addChildContainer('axisReferenceVisualsFloor', _createGroup('axisReferenceVisualsFloor', d, a)).insertAfter(c.axisBottomGroup)), h.attr({\n        \"clip-rect\": r\n      }), a.getChildContainer('crossline') || a.addChildContainer('crossline', _createGroup('crossline', d, a)).insertBefore(c.plotGroup), a.getChildContainer('crosslineBottom') || a.addChildContainer('crosslineBottom', _createGroup('crosslineBottom', d, a)).insertBefore(c.plotGroup), a.getChildContainer('crosslineTop') || a.addChildContainer('crosslineTop', _createGroup('crosslineTop', d, a)).insertBefore(c.abovePlotGroup), a.getChildContainer('datalabelsGroup') || a.addChildContainer('datalabelsGroup', _createGroup('canvasdatalabel', b.getChildContainer('datalabelsGroup'), a)), j || (j = a.addChildContainer('axisReferenceVisualsMiddle', _createGroup('axisReferenceVisualsMiddle', d, a)).insertBefore(c.plotGroup)), j.attr({\n        \"clip-rect\": r\n      }), k || (k = a.addChildContainer('axisReferenceVisualsTop', _createGroup('axisReferenceVisualsTop', d, a)).insertBefore(c.datalabelsGroup)), a.getChildContainer('quadrantGroup') || a.addChildContainer('quadrantGroup', _createGroup('quadrant', d, a)).insertAfter(j), l || a.addChildContainer('axisReferenceVisualsCeil', _createGroup('axisReferenceVisualsCeil', d, a)).insertBefore(c.datalabelsGroup), a.getChildContainer('sumLabelsLayer') || a.addChildContainer('sumLabelsLayer', c.sumLabelsLayer), p || (p = a.addChildContainer('columnShadowGroup', _createGroup('column-shadow-group', q, a))), o || (o = a.addChildContainer('columnGroup', _createGroup('column', q, a))), n || (n = a.addChildContainer('areaShadowGroup', _createGroup('area-shadow-group', q, a))), m || (m = a.addChildContainer('areaGroup', _createGroup('area', q, a))), g ? (p.insertBefore(n), o.insertBefore(n)) : (n.insertBefore(p), m.insertBefore(p)), a.getChildContainer('lineShadowGroup') || a.addChildContainer('lineShadowGroup', _createGroup('line-shadow-group', q, a)), a.getChildContainer('lineGroup') || a.addChildContainer('lineGroup', _createGroup('line', q, a)), a.getChildContainer('defaultShadowGroup') || a.addChildContainer('defaultShadowGroup', _createGroup('default-shadow-group', q, a)), a.getChildContainer('defaultGroup') || a.addChildContainer('defaultGroup', _createGroup('default', q, a));\n    }\n  }, {\n    key: \"isWithinCanvas\",\n    value: function isWithinCanvas(a, b) {\n      var c = this,\n          d = c.config,\n          e = d.canvasLeft,\n          f = e + d.canvasWidth,\n          g = d.canvasTop,\n          h = g + d.canvasHeight;\n      return a >= e && a <= f && b >= g && b <= h;\n    }\n  }, {\n    key: \"setCanvasPadding\",\n    value: function setCanvasPadding() {\n      var a,\n          b = this,\n          c = b.config;\n      a = b.getCanvasPadding(), c.canvasPaddingLeft = mathMax(c.canvasPaddingLeft, a.paddingLeft || 0), c.canvasPaddingRight = mathMax(c.canvasPaddingRight, a.paddingRight || 0), c.canvasPaddingTop = mathMax(c.canvasPaddingTop, a.paddingTop || 0), c.canvasPaddingBottom = mathMax(c.canvasPaddingBottom, a.paddingBottom || 0);\n    }\n  }, {\n    key: \"getEffectiveDimensions\",\n    value: function getEffectiveDimensions() {\n      var a = this,\n          b = a.config,\n          c = b.canvasLeft,\n          d = b.canvasTop,\n          e = b.canvasWidth,\n          f = b.canvasHeight,\n          g = b.canvasPaddingLeft,\n          h = b.canvasPaddingTop,\n          i = b.canvasPaddingRight,\n          j = b.canvasPaddingBottom;\n      return {\n        left: c,\n        top: d,\n        width: e,\n        height: f,\n        paddingLeft: g,\n        paddingTop: h,\n        paddingRight: i,\n        paddingBottom: j\n      };\n    }\n  }, {\n    key: \"setDimension\",\n    value: function setDimension(a) {\n      var b = this,\n          c = b.config;\n      c.canvasTop = a.top, c.canvasLeft = a.left, c.canvasWidth = a.width, c.canvasHeight = a.height;\n    }\n  }, {\n    key: \"getCanvasPadding\",\n    value: function getCanvasPadding() {\n      var a,\n          b,\n          c,\n          d,\n          e = this,\n          f = e.getFromEnv('chartConfig'),\n          g = f.canvasWidth,\n          h = e.config,\n          i = h.maxPaddingPercent * g / 100,\n          j = {\n        paddingLeft: 0,\n        paddingRight: 0,\n        paddingTop: 0,\n        paddingBottom: 0\n      };\n      return e._mapChildren(function (c) {\n        for (b in a = c.getCanvasPadding && c.getCanvasPadding() || {}, a) {\n          a.hasOwnProperty(b) && (j[b] = mathMax(a[b], j[b]));\n        }\n      }), c = j.paddingLeft || 0, d = j.paddingRight || 0, i < c && (j.paddingLeft = i), i < d && (j.paddingRight = i), j;\n    }\n  }, {\n    key: \"configureAttributes\",\n    value: function configureAttributes() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g = this,\n          h = g.getLinkedParent(),\n          i = g.getFromEnv('chartConfig'),\n          j = g.config,\n          k = g.getFromEnv('chart-attrib'),\n          l = g.getFromEnv('color-manager'),\n          m = i.is3D,\n          n = m ? chartPaletteStr.chart3D : chartPaletteStr.chart2D,\n          o = j.isRoundEdges = pluckNumber(k.useroundedges, 0),\n          p = pluckNumber(k.showxaxisline, k.showyaxisline, k.showaxislines, 0),\n          q = p ? 0 : 1;\n      j.canvasBorderRadius = pluckNumber(k.plotborderradius, o ? 2 : 0), d = j.showCanvasBorder = !!pluckNumber(k.showcanvasborder, q, b, o ? 0 : 1), f = j.oriCanvasBorderThickness = mathMax(pluckNumber(k.canvasborderthickness, o ? 0 : pluckNumber(h.canvasborderthickness, 2), 0)), b = j.canvasBorderWidth = m ? 0 : d ? f : 0, j.canvasBorderColor = convertColor(pluck(k.canvasbordercolor, l.getColor(canvasBorderColorStr)), pluck(k.canvasborderalpha, l.getColor('canvasBorderAlpha'))), c = j.canBGAlpha = pluck(k.canvasbgalpha, l.getColor(canvasBGAlphaStr)), j.canBGColor = {\n        FCcolor: {\n          color: pluck(k.canvasbgcolor, l.getColor(n.canvasBgColor)),\n          alpha: pluck(k.canvasbgalpha, 100),\n          angle: pluck(k.canvasbgangle, 0),\n          ratio: pluck(k.canvasbgratio)\n        }\n      }, e = j.shadow = pluckNumber(k.showshadow, o, 0) && o ? {\n        enabled: !0,\n        opacity: c / 100\n      } : 0, j.shadowOnCanvasFill = e && e.enabled, j.canvasPadding = pluckNumber(k.canvaspadding, 0), j.origCanvasTopPad = pluckNumber(k.canvastoppadding, 0), j.origCanvasBottomPad = pluckNumber(k.canvasbottompadding, 0), j.origCanvasLeftPad = pluckNumber(k.canvasleftpadding, 0), j.origCanvasRightPad = pluckNumber(k.canvasrightpadding, 0), Object.assign(j, a), g.config.inputComponents = [], g.config.maxPaddingPercent = 12.5, g._mapChildren(function (a) {\n        a.getState('removed') || a.getType && 'dataset' === a.getType() || 'axisRefVisuals' === a.getType() || a.configure && a.configure();\n      });\n    }\n  }, {\n    key: \"disposeAllInputs\",\n    value: function disposeAllInputs() {\n      this.config.inputComponents.forEach(function (a) {\n        a.dispose();\n      }), this.config.inputComponents.length = 0;\n    }\n  }, {\n    key: \"axisExists\",\n    value: function axisExists(a) {\n      var b,\n          c,\n          d = this.getLinkedItem('axes'),\n          e = !1;\n\n      for (b = 0, c = d.length; b < c; b++) {\n        if (d[b].axis === a) {\n          e = !0;\n          break;\n        }\n      }\n\n      return e;\n    }\n  }, {\n    key: \"attachAxis\",\n    value: function attachAxis(a, b, c) {\n      var d = this.getLinkedItem('axes'),\n          e = b ? 'yAxis' : 'xAxis',\n          f = this.getFromEnv(e) || [];\n      return this.axisExists(a) || (d.push({\n        axis: a,\n        isY: b,\n        config: c || {}\n      }), f.push(a), this.addToEnv(e, f)), this;\n    }\n  }, {\n    key: \"setPrimaryAxis\",\n    value: function setPrimaryAxis(a, b) {\n      var c = this.getLinkedItem('primaryAxis');\n      c[a] = this.getLinkedItem('axes').find(function (a) {\n        return a.axis === b;\n      });\n    }\n  }, {\n    key: \"getAxes\",\n    value: function getAxes() {\n      var a;\n      return Object.keys(a = this.getLinkedItem('primaryAxis')).length ? [a.xAxis, a.yAxis] : this.getLinkedItem('axes').slice(0);\n    }\n  }, {\n    key: \"detachAxis\",\n    value: function detachAxis(a, b) {\n      var c = this.getLinkedItem('axes'),\n          d = 1 / 0;\n      return b ? c.splice(b, 1) : (c.forEach(function (b, c) {\n        b.axis === a && (d = c);\n      }), c.splice(d, 1));\n    }\n  }, {\n    key: \"preDraw\",\n    value: function preDraw() {\n      this._mapChildren(function (a) {\n        !a.getState('removed') && a.preDraw && a.preDraw();\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      this.createGroup(), this.getFromEnv('chart').config.skipCanvasDrawing || this.drawCanvas();\n    }\n  }, {\n    key: \"drawCanvas\",\n    value: function drawCanvas() {\n      var a,\n          b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h = this,\n          i = h.getFromEnv('chart'),\n          j = i.isBar,\n          k = i.getFromEnv('dataSource'),\n          l = k.chart,\n          m = h.getFromEnv('animationManager'),\n          n = i.config,\n          o = h.config,\n          p = o.clip = {},\n          q = i.getChildContainer('plotGroup'),\n          r = i.getChildContainer('datalabelsGroup'),\n          s = h.getGraphicalElement('canvasBorderElement'),\n          t = h.getGraphicalElement('canvasElement'),\n          u = o.canvasLeft || (o.canvasLeft = n.canvasLeft),\n          v = o.canvasTop || (o.canvasTop = n.canvasTop),\n          w = o.canvasWidth || (o.canvasWidth = n.canvasWidth),\n          x = o.canvasHeight || (o.canvasHeight = n.canvasHeight),\n          y = o.xDepth = n.xDepth || 0,\n          z = o.yDepth = n.yDepth || 0,\n          A = h.getContainer('canvasGroup'),\n          B = h.getChildContainer('quadrantGroup'),\n          C = o.canvasBorderRadius,\n          D = o.canvasBorderWidth,\n          E = .5 * D,\n          F = o.canvasBorderColor,\n          G = o.canBGColor,\n          H = o.canBGAlpha,\n          I = o.shadow,\n          J = o.showCanvasBG = !!pluckNumber(l.showcanvasbg, 1),\n          K = o.shadowOnCanvasFill,\n          L = o.showCanvasBorder;\n      d = G, e = {\n        x: u - E,\n        y: v - E,\n        width: w + D,\n        height: x + D,\n        r: C,\n        \"stroke-width\": D,\n        stroke: F,\n        \"stroke-linejoin\": D > MAX_MITER_LINEJOIN ? ROUND : miterStr\n      }, L ? (s && s.show(), b = m.setAnimation({\n        el: s || 'rect',\n        component: h,\n        attr: {\n          x: u - E,\n          y: v - E,\n          width: w + D,\n          height: x + D,\n          r: C,\n          \"stroke-width\": D,\n          stroke: F,\n          \"stroke-linejoin\": D > MAX_MITER_LINEJOIN ? ROUND : miterStr\n        },\n        label: 'rect',\n        container: A\n      }).shadow(I), !s && h.addGraphicalElement('canvasBorderElement', b)) : s && (h.removeGraphicalElement(s), m.setAnimation({\n        el: s,\n        component: h,\n        callback: function callback() {\n          s.hide();\n        }\n      })), f = L ? 0 : o.oriCanvasBorderThickness, p[clipCanvasStr] = [mathMax(0, u - y - f), mathMax(0, v - z - f), mathMax(1, w + 2 * y + 2 * f), mathMax(1, x + z + 2 * f)], p[clipSumValue] = [mathMax(0, u - y), j ? v : 0, mathMax(1, j ? n.width - u : w + 2 * y), mathMax(1, j ? x + z : v + x)], p[clipCanvasInitStr] = [mathMax(0, u - y), mathMax(0, v - z), 1, mathMax(1, x + 2 * z)], a = p[clipCanvasStr].slice(0), g = function g(a, b) {\n        m.setAnimation({\n          el: a,\n          attr: {\n            \"clip-rect\": b\n          },\n          label: 'container',\n          component: h,\n          state: a.attrs['clip-rect'] ? 'updating' : 'appearing'\n        });\n      }, n.skipClipping || (g(q, a), g(r, a), g(B, a), g(h.getChildContainer('sumLabelsLayer'), p[clipSumValue])), J ? (e = {\n        x: u,\n        y: v,\n        width: w,\n        height: x,\n        r: C,\n        \"stroke-width\": 0,\n        stroke: NONE,\n        fill: toRaphaelColor(d)\n      }, t && t.show(), c = m.setAnimation({\n        el: t || 'rect',\n        attr: e,\n        label: 'rect',\n        container: A,\n        component: h\n      }), !t && h.addGraphicalElement('canvasElement', c), K ? c.shadow({\n        opacity: H / 100\n      }) : c.shadow(!1)) : t && m.setAnimation({\n        el: t,\n        component: h,\n        callback: function callback() {\n          t.hide();\n        }\n      });\n    }\n  }]);\n\n  return Canvas;\n}(ComponentInterface);\n\nexport default Canvas;","map":null,"metadata":{},"sourceType":"module"}